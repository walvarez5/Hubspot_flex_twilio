{"version":3,"file":"telemetrytracker.js","sources":["../../src/services/telemetrytracker.ts"],"sourcesContent":["import { Configuration } from \"../configuration\";\nimport { PacketInterface } from \"../packetinterface\";\nimport { Telemetry, TelemetryEvent } from \"../protocol/messages/telemetry\";\nimport { log } from \"../logger\";\n\nclass TelemetryEventDescription {\n  end?: Date | null;\n\n  constructor(\n    readonly title: string,\n    readonly details: string,\n    readonly start: Date,\n    end?: Date | null,\n    readonly type?: string,\n    readonly id?: string\n  ) {\n    this.end = end;\n  }\n\n  // Prepare telemetry event right before sending it.\n  // Convert times to relative.\n  public toTelemetryEvent(): TelemetryEvent {\n    // Fix dates\n    const now = new Date();\n    let actualStart = this.start;\n    let actualEnd = this.end ? this.end : now;\n    if (actualEnd < actualStart) {\n      const tmp = actualEnd;\n      actualEnd = actualStart;\n      actualStart = tmp;\n    }\n\n    // Converting dates to relative offset from current moment in ms\n    const startOffset = actualStart.getTime() - now.getTime();\n    const endOffset = actualEnd.getTime() - now.getTime();\n\n    const result = new TelemetryEvent(\n      startOffset,\n      endOffset,\n      this.title,\n      this.details,\n      this.id,\n      this.type\n    );\n\n    return result;\n  }\n}\n\nenum TelemetryPoint {\n  Start,\n  End,\n}\n\nenum EventSendingLimitation {\n  MinEventsPortion, // check for minimal amount of telemetry events, skip sending if less than 100 events are ready to send\n  AnyEvents, // send all collected events, do not check for count, skip sending only if no events are ready to send\n  AnyEventsIncludingUnfinished, // send all collected (ready to send) as well as unfinished (just started) events\n}\n\nclass TelemetryTracker {\n  // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)\n  private readonly minEventsPortionToSend = 50;\n  // max events batch size to be sent in a single Telemetry message\n  private readonly maxEventsPortionToSend = 100;\n  private readonly config: Configuration; // to check confirmed capabilities\n  private readonly packetInterface: PacketInterface;\n  private pendingEvents = new Map(); // started events: have TelemetryEvent::startTime only\n  private readyEvents: TelemetryEventDescription[] = []; // events ready to send\n  private hasInitializationFinished = false;\n\n  private _canSendTelemetry = false;\n\n  constructor(config: Configuration, packetInterface: PacketInterface) {\n    this.config = config;\n    this.packetInterface = packetInterface;\n  }\n\n  // Keeping this private prevents the type declaration from being generated properly.\n  // Ideally, this should be private.\n  get isTelemetryEnabled(): boolean {\n    return this.config.confirmedCapabilities.has(\"telemetry.v1\");\n  }\n\n  public get canSendTelemetry(): boolean {\n    return this._canSendTelemetry && this.isTelemetryEnabled;\n  }\n\n  public set canSendTelemetry(enable: boolean) {\n    log.debug(\n      `TelemetryTracker.canSendTelemetry: ${enable} TelemetryTracker.isTelemetryEnabled: ${this.isTelemetryEnabled}`\n    );\n\n    // We want to keep telemetry events added in advance but\n    // we need to purge events from previous connection when being disconnected\n    if (this._canSendTelemetry && !enable) {\n      this.pendingEvents.clear();\n      this.readyEvents = [];\n    }\n\n    this._canSendTelemetry = enable;\n\n    if (enable) {\n      this.sendTelemetry(EventSendingLimitation.AnyEvents);\n    }\n\n    if (enable && !this.hasInitializationFinished) {\n      this.hasInitializationFinished = true;\n    }\n  }\n\n  // Add complete event\n  public addTelemetryEvent(event: TelemetryEventDescription): void {\n    // Allow adding events before initialization.\n    if (!this.canSendTelemetry && this.hasInitializationFinished) {\n      return;\n    }\n\n    this.readyEvents.push(event);\n  }\n\n  // Add incomplete event (with either starting or ending time point)\n  public addPartialEvent(\n    incompleteEvent: TelemetryEventDescription,\n    eventKey: string,\n    point: TelemetryPoint\n  ): void {\n    log.debug(\n      `Adding ${\n        point === TelemetryPoint.Start ? \"starting\" : \"ending\"\n      } timepoint for '${eventKey}' event`\n    );\n    const exists = this.pendingEvents.has(eventKey);\n    if (point === TelemetryPoint.Start) {\n      if (exists) {\n        log.debug(`Overwriting starting point for '${eventKey}' event`);\n      }\n      this.pendingEvents.set(eventKey, incompleteEvent);\n    } else {\n      if (!exists) {\n        log.info(`Could not find started event for '${eventKey}' event`);\n        return;\n      }\n      this.addTelemetryEvent(\n        this.merge(this.pendingEvents.get(eventKey), incompleteEvent)\n      );\n      this.pendingEvents.delete(eventKey);\n    }\n  }\n\n  public getTelemetryToSend(\n    sendingLimit: EventSendingLimitation\n  ): TelemetryEventDescription[] {\n    if (!this.canSendTelemetry || this.readyEvents.length == 0) {\n      return []; // Events are collected but not sent until telemetry is enabled\n    }\n\n    if (\n      sendingLimit == EventSendingLimitation.MinEventsPortion &&\n      this.readyEvents.length < this.minEventsPortionToSend\n    ) {\n      return [];\n    }\n\n    return this.getTelemetryPortion(\n      sendingLimit == EventSendingLimitation.AnyEventsIncludingUnfinished\n    );\n  }\n\n  private getTelemetryPortion(\n    includeUnfinished: boolean\n  ): TelemetryEventDescription[] {\n    const eventsPortionToSend = Math.min(\n      this.readyEvents.length,\n      this.maxEventsPortionToSend\n    );\n    const res = this.readyEvents.splice(0, eventsPortionToSend);\n\n    if (includeUnfinished && res.length < this.maxEventsPortionToSend) {\n      this.pendingEvents.forEach((value, key) => {\n        if (res.length >= this.maxEventsPortionToSend) {\n          return; // @fixme does not end the loop early\n        }\n        const event = this.pendingEvents.get(key);\n        this.pendingEvents.delete(key);\n        res.push(\n          new TelemetryEventDescription(\n            `[UNFINISHED] ${event.title}`, // add prefix title to mark unfinished events for CleanSock\n            event.details,\n            event.start,\n            null, // Not ended, on sending will be replaced with now\n            event.type,\n            event.id\n          )\n        );\n      });\n    }\n\n    return res;\n  }\n\n  // Merging 2 partial events:\n  //   use start.startTime & end.endTime.\n  // For other fields,\n  //   if there are values in end, use them,\n  //   else use values from start.\n  private merge(\n    start: TelemetryEventDescription,\n    end: TelemetryEventDescription\n  ): TelemetryEventDescription {\n    return new TelemetryEventDescription(\n      end.title ? end.title : start.title,\n      end.details ? end.details : start.details,\n      start.start,\n      end.end,\n      end.type ? end.type : start.type,\n      end.id ? end.id : start.id\n    );\n  }\n\n  public sendTelemetryIfMinimalPortionCollected(): void {\n    this.sendTelemetry(EventSendingLimitation.MinEventsPortion);\n  }\n\n  // NB: getTelemetryToSend will return non-empty array only if we have already received initReply\n  // and telemetry.v1 capability is enabled there.\n  public sendTelemetry(limit: EventSendingLimitation): void {\n    const events = this.getTelemetryToSend(limit);\n\n    if (events.length === 0) {\n      return; // not enough telemetry data collected\n    }\n\n    try {\n      this.packetInterface.send(\n        new Telemetry(events.map((e) => e.toTelemetryEvent()))\n      );\n    } catch (err) {\n      log.debug(\n        `Error while sending ${events.length} telemetry events due to ${err}; they will be resubmitted`\n      );\n      this.readyEvents = this.readyEvents.concat(events);\n    }\n  }\n}\n\nexport {\n  TelemetryTracker,\n  TelemetryEventDescription,\n  TelemetryPoint,\n  EventSendingLimitation,\n};\n"],"names":["TelemetryEvent","TelemetryPoint","EventSendingLimitation","log","Telemetry"],"mappings":"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"}