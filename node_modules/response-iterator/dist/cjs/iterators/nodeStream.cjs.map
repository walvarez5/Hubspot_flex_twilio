{"version":3,"sources":["/Users/kevin/Dev/OpenSource/http/response-iterator/src/iterators/nodeStream.ts"],"sourcesContent":["import type { Readable as NodeReadableStream } from 'stream';\n\nconst hasIterator = typeof Symbol !== 'undefined' && Symbol.asyncIterator;\n\n/* c8 ignore start */\nexport default function nodeStreamIterator<T>(stream: NodeReadableStream): AsyncIterableIterator<T> {\n  let cleanup = null;\n  let error = null;\n  let done = false;\n  const data = [];\n  const waiting = [];\n\n  function onData(chunk) {\n    if (error) return;\n    if (waiting.length) return waiting.shift()[0]({ value: chunk, done: false });\n    data.push(chunk);\n  }\n  function onError(err) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach((pair) => {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach((pair) => {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = () => {\n    cleanup = null;\n    stream.removeListener('data', onData);\n    stream.removeListener('error', onError);\n    stream.removeListener('end', onEnd);\n    stream.removeListener('finish', onEnd);\n    stream.removeListener('close', onEnd);\n  };\n  stream.on('data', onData);\n  stream.on('error', onError);\n  stream.on('end', onEnd);\n  stream.on('finish', onEnd);\n  stream.on('close', onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean>> {\n    return new Promise((resolve, reject) => {\n      if (error) return reject(error);\n      if (data.length) return resolve({ value: data.shift(), done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator = {\n    next(): Promise<IteratorResult<T, boolean>> {\n      return getNext();\n    },\n  };\n\n  if (hasIterator) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n/* c8 ignore stop */\n"],"names":["nodeStreamIterator","hasIterator","Symbol","asyncIterator","stream","cleanup","error","done","data","waiting","onData","chunk","length","shift","value","push","onError","err","all","slice","forEach","pair","onEnd","undefined","removeListener","on","getNext","Promise","resolve","reject","iterator","next"],"mappings":";;;;+BAIA,mBAAmB,GACnB,UAkEA,kBAAkB;;;eAlEMA;;;AAHxB,IAAMC,cAAc,OAAOC,WAAW,eAAeA,OAAOC,aAAa;AAG1D,SAASH,mBAAsBI,MAA0B;IACtE,IAAIC,UAAU;IACd,IAAIC,QAAQ;IACZ,IAAIC,OAAO;IACX,IAAMC,OAAO,EAAE;IACf,IAAMC,UAAU,EAAE;IAElB,SAASC,OAAOC,KAAK;QACnB,IAAIL,OAAO;QACX,IAAIG,QAAQG,MAAM,EAAE,OAAOH,QAAQI,KAAK,EAAE,CAAC,EAAE,CAAC;YAAEC,OAAOH;YAAOJ,MAAM;QAAM;QAC1EC,KAAKO,IAAI,CAACJ;IACZ;IACA,SAASK,QAAQC,GAAG;QAClBX,QAAQW;QACR,IAAMC,MAAMT,QAAQU,KAAK;QACzBD,IAAIE,OAAO,CAAC,SAACC;YACXA,IAAI,CAAC,EAAE,CAACJ;QACV;QACA,CAACZ,WAAWA;IACd;IACA,SAASiB;QACPf,OAAO;QACP,IAAMW,MAAMT,QAAQU,KAAK;QACzBD,IAAIE,OAAO,CAAC,SAACC;YACXA,IAAI,CAAC,EAAE,CAAC;gBAAEP,OAAOS;gBAAWhB,MAAM;YAAK;QACzC;QACA,CAACF,WAAWA;IACd;IAEAA,UAAU;QACRA,UAAU;QACVD,OAAOoB,cAAc,CAAC,QAAQd;QAC9BN,OAAOoB,cAAc,CAAC,SAASR;QAC/BZ,OAAOoB,cAAc,CAAC,OAAOF;QAC7BlB,OAAOoB,cAAc,CAAC,UAAUF;QAChClB,OAAOoB,cAAc,CAAC,SAASF;IACjC;IACAlB,OAAOqB,EAAE,CAAC,QAAQf;IAClBN,OAAOqB,EAAE,CAAC,SAAST;IACnBZ,OAAOqB,EAAE,CAAC,OAAOH;IACjBlB,OAAOqB,EAAE,CAAC,UAAUH;IACpBlB,OAAOqB,EAAE,CAAC,SAASH;IAEnB,SAASI;QACP,OAAO,IAAIC,QAAQ,SAACC,SAASC;YAC3B,IAAIvB,OAAO,OAAOuB,OAAOvB;YACzB,IAAIE,KAAKI,MAAM,EAAE,OAAOgB,QAAQ;gBAAEd,OAAON,KAAKK,KAAK;gBAAIN,MAAM;YAAM;YACnE,IAAIA,MAAM,OAAOqB,QAAQ;gBAAEd,OAAOS;gBAAWhB,MAAM;YAAK;YACxDE,QAAQM,IAAI,CAAC;gBAACa;gBAASC;aAAO;QAChC;IACF;IAEA,IAAMC,WAAW;QACfC,MAAAA,SAAAA;YACE,OAAOL;QACT;IACF;IAEA,IAAIzB,aAAa;QACf6B,QAAQ,CAAC5B,OAAOC,aAAa,CAAC,GAAG;YAC/B,OAAO,IAAI;QACb;IACF;IAEA,OAAO2B;AACT"}