var __create=Object.create;var __defProp=Object.defineProperty;var __getOwnPropDesc=Object.getOwnPropertyDescriptor;var __getOwnPropNames=Object.getOwnPropertyNames;var __getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty;var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:!0})},__copyProps=(to2,from,except,desc)=>{if(from&&typeof from=="object"||typeof from=="function")for(let key of __getOwnPropNames(from))!__hasOwnProp.call(to2,key)&&key!==except&&__defProp(to2,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable});return to2};var __toESM=(mod,isNodeMode,target)=>(target=mod!=null?__create(__getProtoOf(mod)):{},__copyProps(isNodeMode||!mod||!mod.__esModule?__defProp(target,"default",{value:mod,enumerable:!0}):target,mod)),__toCommonJS=mod=>__copyProps(__defProp({},"__esModule",{value:!0}),mod);var src_exports={};__export(src_exports,{Globals:()=>globals,animated:()=>animated,interpolate:()=>interpolate2,isRenderingOnServer:()=>isRenderingOnServer,useChain:()=>useChain,useReducedMotion:()=>useReducedMotion,useSpring:()=>useSpring,useSprings:()=>useSprings,useTrail:()=>useTrail,useTransition:()=>useTransition});module.exports=__toCommonJS(src_exports);var updateQueue=makeQueue(),raf=fn=>schedule(fn,updateQueue),writeQueue=makeQueue();raf.write=fn=>schedule(fn,writeQueue);var onStartQueue=makeQueue();raf.onStart=fn=>schedule(fn,onStartQueue);var onFrameQueue=makeQueue();raf.onFrame=fn=>schedule(fn,onFrameQueue);var onFinishQueue=makeQueue();raf.onFinish=fn=>schedule(fn,onFinishQueue);var timeouts=[];raf.setTimeout=(handler,ms)=>{let time=raf.now()+ms,cancel=()=>{let i=timeouts.findIndex(t=>t.cancel==cancel);~i&&timeouts.splice(i,1),pendingCount-=~i?1:0},timeout={time,handler,cancel};return timeouts.splice(findTimeout(time),0,timeout),pendingCount+=1,start(),timeout};var findTimeout=time=>~(~timeouts.findIndex(t=>t.time>time)||~timeouts.length);raf.cancel=fn=>{onStartQueue.delete(fn),onFrameQueue.delete(fn),updateQueue.delete(fn),writeQueue.delete(fn),onFinishQueue.delete(fn)};raf.sync=fn=>{sync=!0,raf.batchedUpdates(fn),sync=!1};raf.throttle=fn=>{let lastArgs;function queuedFn(){try{fn(...lastArgs)}finally{lastArgs=null}}function throttled(...args){lastArgs=args,raf.onStart(queuedFn)}return throttled.handler=fn,throttled.cancel=()=>{onStartQueue.delete(queuedFn),lastArgs=null},throttled};var nativeRaf=typeof window<"u"?window.requestAnimationFrame:()=>{};raf.use=impl=>nativeRaf=impl;raf.now=typeof performance<"u"?()=>performance.now():Date.now;raf.batchedUpdates=fn=>fn();raf.catch=console.error;raf.frameLoop="always";raf.advance=()=>{raf.frameLoop!=="demand"?console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"):update()};var ts=-1,pendingCount=0,sync=!1;function schedule(fn,queue){sync?(queue.delete(fn),fn(0)):(queue.add(fn),start())}function start(){ts<0&&(ts=0,raf.frameLoop!=="demand"&&nativeRaf(loop))}function stop(){ts=-1}function loop(){~ts&&(nativeRaf(loop),raf.batchedUpdates(update))}function update(){let prevTs=ts;ts=raf.now();let count=findTimeout(ts);count&&(eachSafely(timeouts.splice(0,count),t=>t.handler()),pendingCount-=count),onStartQueue.flush(),updateQueue.flush(prevTs?Math.min(64,ts-prevTs):16.667),onFrameQueue.flush(),writeQueue.flush(),onFinishQueue.flush(),pendingCount||stop()}function makeQueue(){let next=new Set,current=next;return{add(fn){pendingCount+=current==next&&!next.has(fn)?1:0,next.add(fn)},delete(fn){return pendingCount-=current==next&&next.has(fn)?1:0,next.delete(fn)},flush(arg){current.size&&(next=new Set,pendingCount-=current.size,eachSafely(current,fn=>fn(arg)&&next.add(fn)),pendingCount+=next.size,current=next)}}}function eachSafely(values,each2){values.forEach(value=>{try{each2(value)}catch(e){raf.catch(e)}})}var React=__toESM(require("react")),import_react=require("react");function noop(){}var defineHidden=(obj,key,value)=>Object.defineProperty(obj,key,{value,writable:!0,configurable:!0}),is={arr:Array.isArray,obj:a=>!!a&&a.constructor.name==="Object",fun:a=>typeof a=="function",str:a=>typeof a=="string",num:a=>typeof a=="number",und:a=>a===void 0};function isEqual(a,b){if(is.arr(a)){if(!is.arr(b)||a.length!==b.length)return!1;for(let i=0;i<a.length;i++)if(a[i]!==b[i])return!1;return!0}return a===b}var each=(obj,fn)=>obj.forEach(fn);function eachProp(obj,fn,ctx2){if(is.arr(obj)){for(let i=0;i<obj.length;i++)fn.call(ctx2,obj[i],`${i}`);return}for(let key in obj)obj.hasOwnProperty(key)&&fn.call(ctx2,obj[key],key)}var toArray=a=>is.und(a)?[]:is.arr(a)?a:[a];function flush(queue,iterator){if(queue.size){let items=Array.from(queue);queue.clear(),each(items,iterator)}}var flushCalls=(queue,...args)=>flush(queue,fn=>fn(...args)),isSSR=()=>typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),createStringInterpolator$1,to,colors$1=null,skipAnimation=!1,willAdvance=noop,assign=globals2=>{globals2.to&&(to=globals2.to),globals2.now&&(raf.now=globals2.now),globals2.colors!==void 0&&(colors$1=globals2.colors),globals2.skipAnimation!=null&&(skipAnimation=globals2.skipAnimation),globals2.createStringInterpolator&&(createStringInterpolator$1=globals2.createStringInterpolator),globals2.requestAnimationFrame&&raf.use(globals2.requestAnimationFrame),globals2.batchedUpdates&&(raf.batchedUpdates=globals2.batchedUpdates),globals2.willAdvance&&(willAdvance=globals2.willAdvance),globals2.frameLoop&&(raf.frameLoop=globals2.frameLoop)},globals=Object.freeze({__proto__:null,get createStringInterpolator(){return createStringInterpolator$1},get to(){return to},get colors(){return colors$1},get skipAnimation(){return skipAnimation},get willAdvance(){return willAdvance},assign}),startQueue=new Set,currentFrame=[],prevFrame=[],priority=0,frameLoop={get idle(){return!startQueue.size&&!currentFrame.length},start(animation){priority>animation.priority?(startQueue.add(animation),raf.onStart(flushStartQueue)):(startSafely(animation),raf(advance))},advance,sort(animation){if(priority)raf.onFrame(()=>frameLoop.sort(animation));else{let prevIndex=currentFrame.indexOf(animation);~prevIndex&&(currentFrame.splice(prevIndex,1),startUnsafely(animation))}},clear(){currentFrame=[],startQueue.clear()}};function flushStartQueue(){startQueue.forEach(startSafely),startQueue.clear(),raf(advance)}function startSafely(animation){currentFrame.includes(animation)||startUnsafely(animation)}function startUnsafely(animation){currentFrame.splice(findIndex(currentFrame,other=>other.priority>animation.priority),0,animation)}function advance(dt){let nextFrame=prevFrame;for(let i=0;i<currentFrame.length;i++){let animation=currentFrame[i];priority=animation.priority,animation.idle||(willAdvance(animation),animation.advance(dt),animation.idle||nextFrame.push(animation))}return priority=0,prevFrame=currentFrame,prevFrame.length=0,currentFrame=nextFrame,currentFrame.length>0}function findIndex(arr,test){let index=arr.findIndex(test);return index<0?arr.length:index}var colors={transparent:0,aliceblue:4042850303,antiquewhite:4209760255,aqua:16777215,aquamarine:2147472639,azure:4043309055,beige:4126530815,bisque:4293182719,black:255,blanchedalmond:4293643775,blue:65535,blueviolet:2318131967,brown:2771004159,burlywood:3736635391,burntsienna:3934150143,cadetblue:1604231423,chartreuse:2147418367,chocolate:3530104575,coral:4286533887,cornflowerblue:1687547391,cornsilk:4294499583,crimson:3692313855,cyan:16777215,darkblue:35839,darkcyan:9145343,darkgoldenrod:3095792639,darkgray:2846468607,darkgreen:6553855,darkgrey:2846468607,darkkhaki:3182914559,darkmagenta:2332068863,darkolivegreen:1433087999,darkorange:4287365375,darkorchid:2570243327,darkred:2332033279,darksalmon:3918953215,darkseagreen:2411499519,darkslateblue:1211993087,darkslategray:793726975,darkslategrey:793726975,darkturquoise:13554175,darkviolet:2483082239,deeppink:4279538687,deepskyblue:12582911,dimgray:1768516095,dimgrey:1768516095,dodgerblue:512819199,firebrick:2988581631,floralwhite:4294635775,forestgreen:579543807,fuchsia:4278255615,gainsboro:3705462015,ghostwhite:4177068031,gold:4292280575,goldenrod:3668254975,gray:2155905279,green:8388863,greenyellow:2919182335,grey:2155905279,honeydew:4043305215,hotpink:4285117695,indianred:3445382399,indigo:1258324735,ivory:4294963455,khaki:4041641215,lavender:3873897215,lavenderblush:4293981695,lawngreen:2096890111,lemonchiffon:4294626815,lightblue:2916673279,lightcoral:4034953471,lightcyan:3774873599,lightgoldenrodyellow:4210742015,lightgray:3553874943,lightgreen:2431553791,lightgrey:3553874943,lightpink:4290167295,lightsalmon:4288707327,lightseagreen:548580095,lightskyblue:2278488831,lightslategray:2005441023,lightslategrey:2005441023,lightsteelblue:2965692159,lightyellow:4294959359,lime:16711935,limegreen:852308735,linen:4210091775,magenta:4278255615,maroon:2147483903,mediumaquamarine:1724754687,mediumblue:52735,mediumorchid:3126187007,mediumpurple:2473647103,mediumseagreen:1018393087,mediumslateblue:2070474495,mediumspringgreen:16423679,mediumturquoise:1221709055,mediumvioletred:3340076543,midnightblue:421097727,mintcream:4127193855,mistyrose:4293190143,moccasin:4293178879,navajowhite:4292783615,navy:33023,oldlace:4260751103,olive:2155872511,olivedrab:1804477439,orange:4289003775,orangered:4282712319,orchid:3664828159,palegoldenrod:4008225535,palegreen:2566625535,paleturquoise:2951671551,palevioletred:3681588223,papayawhip:4293907967,peachpuff:4292524543,peru:3448061951,pink:4290825215,plum:3718307327,powderblue:2967529215,purple:2147516671,rebeccapurple:1714657791,red:4278190335,rosybrown:3163525119,royalblue:1097458175,saddlebrown:2336560127,salmon:4202722047,sandybrown:4104413439,seagreen:780883967,seashell:4294307583,sienna:2689740287,silver:3233857791,skyblue:2278484991,slateblue:1784335871,slategray:1887473919,slategrey:1887473919,snow:4294638335,springgreen:16744447,steelblue:1182971135,tan:3535047935,teal:8421631,thistle:3636451583,tomato:4284696575,turquoise:1088475391,violet:4001558271,wheat:4125012991,white:4294967295,whitesmoke:4126537215,yellow:4294902015,yellowgreen:2597139199},NUMBER="[-+]?\\d*\\.?\\d+",PERCENTAGE=NUMBER+"%";function call(...parts){return"\\(\\s*("+parts.join(")\\s*,\\s*(")+")\\s*\\)"}var rgb=new RegExp("rgb"+call(NUMBER,NUMBER,NUMBER)),rgba=new RegExp("rgba"+call(NUMBER,NUMBER,NUMBER,NUMBER)),hsl=new RegExp("hsl"+call(NUMBER,PERCENTAGE,PERCENTAGE)),hsla=new RegExp("hsla"+call(NUMBER,PERCENTAGE,PERCENTAGE,NUMBER)),hex3=/^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex4=/^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6=/^#([0-9a-fA-F]{6})$/,hex8=/^#([0-9a-fA-F]{8})$/;function normalizeColor(color){let match;return typeof color=="number"?color>>>0===color&&color>=0&&color<=4294967295?color:null:(match=hex6.exec(color))?parseInt(match[1]+"ff",16)>>>0:colors$1&&colors$1[color]!==void 0?colors$1[color]:(match=rgb.exec(color))?(parse255(match[1])<<24|parse255(match[2])<<16|parse255(match[3])<<8|255)>>>0:(match=rgba.exec(color))?(parse255(match[1])<<24|parse255(match[2])<<16|parse255(match[3])<<8|parse1(match[4]))>>>0:(match=hex3.exec(color))?parseInt(match[1]+match[1]+match[2]+match[2]+match[3]+match[3]+"ff",16)>>>0:(match=hex8.exec(color))?parseInt(match[1],16)>>>0:(match=hex4.exec(color))?parseInt(match[1]+match[1]+match[2]+match[2]+match[3]+match[3]+match[4]+match[4],16)>>>0:(match=hsl.exec(color))?(hslToRgb(parse360(match[1]),parsePercentage(match[2]),parsePercentage(match[3]))|255)>>>0:(match=hsla.exec(color))?(hslToRgb(parse360(match[1]),parsePercentage(match[2]),parsePercentage(match[3]))|parse1(match[4]))>>>0:null}function hue2rgb(p,q,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?p+(q-p)*6*t:t<1/2?q:t<2/3?p+(q-p)*(2/3-t)*6:p}function hslToRgb(h,s,l){let q=l<.5?l*(1+s):l+s-l*s,p=2*l-q,r=hue2rgb(p,q,h+1/3),g=hue2rgb(p,q,h),b=hue2rgb(p,q,h-1/3);return Math.round(r*255)<<24|Math.round(g*255)<<16|Math.round(b*255)<<8}function parse255(str){let int=parseInt(str,10);return int<0?0:int>255?255:int}function parse360(str){return(parseFloat(str)%360+360)%360/360}function parse1(str){let num=parseFloat(str);return num<0?0:num>1?255:Math.round(num*255)}function parsePercentage(str){let int=parseFloat(str);return int<0?0:int>100?1:int/100}function colorToRgba(input){let int32Color=normalizeColor(input);if(int32Color===null)return input;int32Color=int32Color||0;let r=(int32Color&4278190080)>>>24,g=(int32Color&16711680)>>>16,b=(int32Color&65280)>>>8,a=(int32Color&255)/255;return`rgba(${r}, ${g}, ${b}, ${a})`}var createInterpolator=(range,output,extrapolate)=>{if(is.fun(range))return range;if(is.arr(range))return createInterpolator({range,output,extrapolate});if(is.str(range.output[0]))return createStringInterpolator$1(range);let config2=range,outputRange=config2.output,inputRange=config2.range||[0,1],extrapolateLeft=config2.extrapolateLeft||config2.extrapolate||"extend",extrapolateRight=config2.extrapolateRight||config2.extrapolate||"extend",easing=config2.easing||(t=>t);return input=>{let range2=findRange(input,inputRange);return interpolate(input,inputRange[range2],inputRange[range2+1],outputRange[range2],outputRange[range2+1],easing,extrapolateLeft,extrapolateRight,config2.map)}};function interpolate(input,inputMin,inputMax,outputMin,outputMax,easing,extrapolateLeft,extrapolateRight,map){let result=map?map(input):input;if(result<inputMin){if(extrapolateLeft==="identity")return result;extrapolateLeft==="clamp"&&(result=inputMin)}if(result>inputMax){if(extrapolateRight==="identity")return result;extrapolateRight==="clamp"&&(result=inputMax)}return outputMin===outputMax?outputMin:inputMin===inputMax?input<=inputMin?outputMin:outputMax:(inputMin===-1/0?result=-result:inputMax===1/0?result=result-inputMin:result=(result-inputMin)/(inputMax-inputMin),result=easing(result),outputMin===-1/0?result=-result:outputMax===1/0?result=result+outputMin:result=result*(outputMax-outputMin)+outputMin,result)}function findRange(input,inputRange){for(var i=1;i<inputRange.length-1&&!(inputRange[i]>=input);++i);return i-1}function _extends(){return _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}var $get=Symbol.for("FluidValue.get"),$observers=Symbol.for("FluidValue.observers"),hasFluidValue=arg=>Boolean(arg&&arg[$get]),getFluidValue=arg=>arg&&arg[$get]?arg[$get]():arg,getFluidObservers=target=>target[$observers]||null;function callFluidObserver(observer,event){observer.eventObserved?observer.eventObserved(event):observer(event)}function callFluidObservers(target,event){let observers=target[$observers];observers&&observers.forEach(observer=>{callFluidObserver(observer,event)})}var FluidValue=class{constructor(get){if(this[$get]=void 0,this[$observers]=void 0,!get&&!(get=this.get))throw Error("Unknown getter");setFluidGetter(this,get)}},setFluidGetter=(target,get)=>setHidden(target,$get,get);function addFluidObserver(target,observer){if(target[$get]){let observers=target[$observers];observers||setHidden(target,$observers,observers=new Set),observers.has(observer)||(observers.add(observer),target.observerAdded&&target.observerAdded(observers.size,observer))}return observer}function removeFluidObserver(target,observer){let observers=target[$observers];if(observers&&observers.has(observer)){let count=observers.size-1;count?observers.delete(observer):target[$observers]=null,target.observerRemoved&&target.observerRemoved(count,observer)}}var setHidden=(target,key,value)=>Object.defineProperty(target,key,{value,writable:!0,configurable:!0}),numberRegex=/[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,colorRegex=/(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi,unitRegex=new RegExp(`(${numberRegex.source})(%|[a-z]+)`,"i"),rgbaRegex=/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi,cssVariableRegex=/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/,variableToRgba=input=>{let[token,fallback]=parseCSSVariable(input);if(!token||isSSR())return input;let value=window.getComputedStyle(document.documentElement).getPropertyValue(token);if(value)return value.trim();if(fallback&&fallback.startsWith("--")){let _value=window.getComputedStyle(document.documentElement).getPropertyValue(fallback);return _value||input}else{if(fallback&&cssVariableRegex.test(fallback))return variableToRgba(fallback);if(fallback)return fallback}return input},parseCSSVariable=current=>{let match=cssVariableRegex.exec(current);if(!match)return[,];let[,token,fallback]=match;return[token,fallback]},namedColorRegex,rgbaRound=(_,p1,p2,p3,p4)=>`rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`,createStringInterpolator=config2=>{namedColorRegex||(namedColorRegex=colors$1?new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`,"g"):/^\b$/);let output=config2.output.map(value=>getFluidValue(value).replace(cssVariableRegex,variableToRgba).replace(colorRegex,colorToRgba).replace(namedColorRegex,colorToRgba)),keyframes=output.map(value=>value.match(numberRegex).map(Number)),interpolators=keyframes[0].map((_,i)=>keyframes.map(values=>{if(!(i in values))throw Error('The arity of each "output" value must be equal');return values[i]})).map(output2=>createInterpolator(_extends({},config2,{output:output2})));return input=>{var _output$find;let missingUnit=!unitRegex.test(output[0])&&((_output$find=output.find(value=>unitRegex.test(value)))==null?void 0:_output$find.replace(numberRegex,"")),i=0;return output[0].replace(numberRegex,()=>`${interpolators[i++](input)}${missingUnit||""}`).replace(rgbaRegex,rgbaRound)}},prefix="react-spring: ",once=fn=>{let func=fn,called=!1;if(typeof func!="function")throw new TypeError(`${prefix}once requires a function parameter`);return(...args)=>{called||(func(...args),called=!0)}},warnInterpolate=once(console.warn);function deprecateInterpolate(){warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`)}var warnDirectCall=once(console.warn);function deprecateDirectCall(){warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`)}function isAnimatedString(value){return is.str(value)&&(value[0]=="#"||/\d/.test(value)||!isSSR()&&cssVariableRegex.test(value)||value in(colors$1||{}))}var useOnce=effect=>(0,import_react.useEffect)(effect,emptyDeps),emptyDeps=[];function useForceUpdate(){let update3=(0,import_react.useState)()[1],mounted=(0,import_react.useState)(makeMountedRef)[0];return useOnce(mounted.unmount),()=>{mounted.current&&update3({})}}function makeMountedRef(){let mounted={current:!0,unmount:()=>()=>{mounted.current=!1}};return mounted}function useMemoOne(getResult,inputs){let[initial]=(0,import_react.useState)(()=>({inputs,result:getResult()})),committed=(0,import_react.useRef)(),prevCache=committed.current,cache=prevCache;return cache?Boolean(inputs&&cache.inputs&&areInputsEqual(inputs,cache.inputs))||(cache={inputs,result:getResult()}):cache=initial,(0,import_react.useEffect)(()=>{committed.current=cache,prevCache==initial&&(initial.inputs=initial.result=void 0)},[cache]),cache.result}function areInputsEqual(next,prev){if(next.length!==prev.length)return!1;for(let i=0;i<next.length;i++)if(next[i]!==prev[i])return!1;return!0}function usePrev(value){let prevRef=(0,import_react.useRef)();return(0,import_react.useEffect)(()=>{prevRef.current=value}),prevRef.current}var useLayoutEffect2=typeof window<"u"&&window.document&&window.document.createElement?React.useLayoutEffect:React.useEffect;var React3=__toESM(require("react")),import_react3=require("react");var React2=__toESM(require("react")),import_react2=require("react"),$node=Symbol.for("Animated:node"),isAnimated=value=>!!value&&value[$node]===value,getAnimated=owner=>owner&&owner[$node],setAnimated=(owner,node)=>defineHidden(owner,$node,node),getPayload=owner=>owner&&owner[$node]&&owner[$node].getPayload(),Animated=class{constructor(){this.payload=void 0,setAnimated(this,this)}getPayload(){return this.payload||[]}},AnimatedValue=class extends Animated{constructor(_value){super(),this.done=!0,this.elapsedTime=void 0,this.lastPosition=void 0,this.lastVelocity=void 0,this.v0=void 0,this.durationProgress=0,this._value=_value,is.num(this._value)&&(this.lastPosition=this._value)}static create(value){return new AnimatedValue(value)}getPayload(){return[this]}getValue(){return this._value}setValue(value,step){return is.num(value)&&(this.lastPosition=value,step&&(value=Math.round(value/step)*step,this.done&&(this.lastPosition=value))),this._value===value?!1:(this._value=value,!0)}reset(){let{done}=this;this.done=!1,is.num(this._value)&&(this.elapsedTime=0,this.durationProgress=0,this.lastPosition=this._value,done&&(this.lastVelocity=null),this.v0=null)}},AnimatedString=class extends AnimatedValue{constructor(value){super(0),this._string=null,this._toString=void 0,this._toString=createInterpolator({output:[value,value]})}static create(value){return new AnimatedString(value)}getValue(){let value=this._string;return value==null?this._string=this._toString(this._value):value}setValue(value){if(is.str(value)){if(value==this._string)return!1;this._string=value,this._value=1}else if(super.setValue(value))this._string=null;else return!1;return!0}reset(goal){goal&&(this._toString=createInterpolator({output:[this.getValue(),goal]})),this._value=0,super.reset()}},TreeContext={dependencies:null},AnimatedObject=class extends Animated{constructor(source){super(),this.source=source,this.setValue(source)}getValue(animated2){let values={};return eachProp(this.source,(source,key)=>{isAnimated(source)?values[key]=source.getValue(animated2):hasFluidValue(source)?values[key]=getFluidValue(source):animated2||(values[key]=source)}),values}setValue(source){this.source=source,this.payload=this._makePayload(source)}reset(){this.payload&&each(this.payload,node=>node.reset())}_makePayload(source){if(source){let payload=new Set;return eachProp(source,this._addToPayload,payload),Array.from(payload)}}_addToPayload(source){TreeContext.dependencies&&hasFluidValue(source)&&TreeContext.dependencies.add(source);let payload=getPayload(source);payload&&each(payload,node=>this.add(node))}},AnimatedArray=class extends AnimatedObject{constructor(source){super(source)}static create(source){return new AnimatedArray(source)}getValue(){return this.source.map(node=>node.getValue())}setValue(source){let payload=this.getPayload();return source.length==payload.length?payload.map((node,i)=>node.setValue(source[i])).some(Boolean):(super.setValue(source.map(makeAnimated)),!0)}};function makeAnimated(value){return(isAnimatedString(value)?AnimatedString:AnimatedValue).create(value)}function getAnimatedType(value){let parentNode=getAnimated(value);return parentNode?parentNode.constructor:is.arr(value)?AnimatedArray:isAnimatedString(value)?AnimatedString:AnimatedValue}function _extends2(){return _extends2=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends2.apply(this,arguments)}var withAnimated=(Component,host2)=>{let hasInstance=!is.fun(Component)||Component.prototype&&Component.prototype.isReactComponent;return(0,import_react2.forwardRef)((givenProps,givenRef)=>{let instanceRef=(0,import_react2.useRef)(null),ref=hasInstance&&(0,import_react2.useCallback)(value=>{instanceRef.current=updateRef(givenRef,value)},[givenRef]),[props,deps]=getAnimatedState(givenProps,host2),forceUpdate=useForceUpdate(),callback=()=>{let instance=instanceRef.current;if(hasInstance&&!instance)return;(instance?host2.applyAnimatedValues(instance,props.getValue(!0)):!1)===!1&&forceUpdate()},observer=new PropsObserver(callback,deps),observerRef=(0,import_react2.useRef)();useLayoutEffect2(()=>{let lastObserver=observerRef.current;observerRef.current=observer,each(deps,dep=>addFluidObserver(dep,observer)),lastObserver&&(each(lastObserver.deps,dep=>removeFluidObserver(dep,lastObserver)),raf.cancel(lastObserver.update))}),(0,import_react2.useEffect)(callback,[]),useOnce(()=>()=>{let observer2=observerRef.current;each(observer2.deps,dep=>removeFluidObserver(dep,observer2))});let usedProps=host2.getComponentProps(props.getValue());return React2.createElement(Component,_extends2({},usedProps,{ref}))})},PropsObserver=class{constructor(update3,deps){this.update=update3,this.deps=deps}eventObserved(event){event.type=="change"&&raf.write(this.update)}};function getAnimatedState(props,host2){let dependencies=new Set;return TreeContext.dependencies=dependencies,props.style&&(props=_extends2({},props,{style:host2.createAnimatedStyle(props.style)})),props=new AnimatedObject(props),TreeContext.dependencies=null,[props,dependencies]}function updateRef(ref,value){return ref&&(is.fun(ref)?ref(value):ref.current=value),value}var cacheKey=Symbol.for("AnimatedComponent"),createHost=(components,{applyAnimatedValues:_applyAnimatedValues=()=>!1,createAnimatedStyle:_createAnimatedStyle=style=>new AnimatedObject(style),getComponentProps:_getComponentProps=props=>props}={})=>{let hostConfig={applyAnimatedValues:_applyAnimatedValues,createAnimatedStyle:_createAnimatedStyle,getComponentProps:_getComponentProps},animated2=Component=>{let displayName=getDisplayName(Component)||"Anonymous";return is.str(Component)?Component=animated2[Component]||(animated2[Component]=withAnimated(Component,hostConfig)):Component=Component[cacheKey]||(Component[cacheKey]=withAnimated(Component,hostConfig)),Component.displayName=`Animated(${displayName})`,Component};return eachProp(components,(Component,key)=>{is.arr(components)&&(key=getDisplayName(Component)),animated2[key]=animated2(Component)}),{animated:animated2}},getDisplayName=arg=>is.str(arg)?arg:arg&&is.str(arg.displayName)?arg.displayName:is.fun(arg)&&arg.name||null;function _extends3(){return _extends3=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends3.apply(this,arguments)}function callProp(value,...args){return is.fun(value)?value(...args):value}var matchProp=(value,key)=>value===!0||!!(key&&value&&(is.fun(value)?value(key):toArray(value).includes(key))),resolveProp=(prop,key)=>is.obj(prop)?key&&prop[key]:prop,getDefaultProp=(props,key)=>props.default===!0?props[key]:props.default?props.default[key]:void 0,noopTransform=value=>value,getDefaultProps=(props,transform=noopTransform)=>{let keys=DEFAULT_PROPS;props.default&&props.default!==!0&&(props=props.default,keys=Object.keys(props));let defaults2={};for(let key of keys){let value=transform(props[key],key);is.und(value)||(defaults2[key]=value)}return defaults2},DEFAULT_PROPS=["config","onProps","onStart","onChange","onPause","onResume","onRest"],RESERVED_PROPS={config:1,from:1,to:1,ref:1,loop:1,reset:1,pause:1,cancel:1,reverse:1,immediate:1,default:1,delay:1,onProps:1,onStart:1,onChange:1,onPause:1,onResume:1,onRest:1,onResolve:1,items:1,trail:1,sort:1,expires:1,initial:1,enter:1,update:1,leave:1,children:1,onDestroyed:1,keys:1,callId:1,parentId:1};function getForwardProps(props){let forward={},count=0;if(eachProp(props,(value,prop)=>{RESERVED_PROPS[prop]||(forward[prop]=value,count++)}),count)return forward}function inferTo(props){let to2=getForwardProps(props);if(to2){let out={to:to2};return eachProp(props,(val,key)=>key in to2||(out[key]=val)),out}return _extends3({},props)}function computeGoal(value){return value=getFluidValue(value),is.arr(value)?value.map(computeGoal):isAnimatedString(value)?globals.createStringInterpolator({range:[0,1],output:[value,value]})(1):value}function hasProps(props){for(let _ in props)return!0;return!1}function isAsyncTo(to2){return is.fun(to2)||is.arr(to2)&&is.obj(to2[0])}function detachRefs(ctrl,ref){var _ctrl$ref;(_ctrl$ref=ctrl.ref)==null||_ctrl$ref.delete(ctrl),ref==null||ref.delete(ctrl)}function replaceRef(ctrl,ref){if(ref&&ctrl.ref!==ref){var _ctrl$ref2;(_ctrl$ref2=ctrl.ref)==null||_ctrl$ref2.delete(ctrl),ref.add(ctrl),ctrl.ref=ref}}function useChain(refs,timeSteps,timeFrame=1e3){useLayoutEffect2(()=>{if(timeSteps){let prevDelay=0;each(refs,(ref,i)=>{let controllers=ref.current;if(controllers.length){let delay=timeFrame*timeSteps[i];isNaN(delay)?delay=prevDelay:prevDelay=delay,each(controllers,ctrl=>{each(ctrl.queue,props=>{let memoizedDelayProp=props.delay;props.delay=key=>delay+callProp(memoizedDelayProp||0,key)})}),ref.start()}})}else{let p=Promise.resolve();each(refs,ref=>{let controllers=ref.current;if(controllers.length){let queues=controllers.map(ctrl=>{let q=ctrl.queue;return ctrl.queue=[],q});p=p.then(()=>(each(controllers,(ctrl,i)=>each(queues[i]||[],update3=>ctrl.queue.push(update3))),Promise.all(ref.start())))}})}})}var config={default:{tension:170,friction:26},gentle:{tension:120,friction:14},wobbly:{tension:180,friction:12},stiff:{tension:210,friction:20},slow:{tension:280,friction:60},molasses:{tension:280,friction:120}},c1=1.70158,c2=c1*1.525,c3=c1+1,c4=2*Math.PI/3,c5=2*Math.PI/4.5,bounceOut=x=>x<1/2.75?7.5625*x*x:x<2/2.75?7.5625*(x-=1.5/2.75)*x+.75:x<2.5/2.75?7.5625*(x-=2.25/2.75)*x+.9375:7.5625*(x-=2.625/2.75)*x+.984375,easings={linear:x=>x,easeInQuad:x=>x*x,easeOutQuad:x=>1-(1-x)*(1-x),easeInOutQuad:x=>x<.5?2*x*x:1-Math.pow(-2*x+2,2)/2,easeInCubic:x=>x*x*x,easeOutCubic:x=>1-Math.pow(1-x,3),easeInOutCubic:x=>x<.5?4*x*x*x:1-Math.pow(-2*x+2,3)/2,easeInQuart:x=>x*x*x*x,easeOutQuart:x=>1-Math.pow(1-x,4),easeInOutQuart:x=>x<.5?8*x*x*x*x:1-Math.pow(-2*x+2,4)/2,easeInQuint:x=>x*x*x*x*x,easeOutQuint:x=>1-Math.pow(1-x,5),easeInOutQuint:x=>x<.5?16*x*x*x*x*x:1-Math.pow(-2*x+2,5)/2,easeInSine:x=>1-Math.cos(x*Math.PI/2),easeOutSine:x=>Math.sin(x*Math.PI/2),easeInOutSine:x=>-(Math.cos(Math.PI*x)-1)/2,easeInExpo:x=>x===0?0:Math.pow(2,10*x-10),easeOutExpo:x=>x===1?1:1-Math.pow(2,-10*x),easeInOutExpo:x=>x===0?0:x===1?1:x<.5?Math.pow(2,20*x-10)/2:(2-Math.pow(2,-20*x+10))/2,easeInCirc:x=>1-Math.sqrt(1-Math.pow(x,2)),easeOutCirc:x=>Math.sqrt(1-Math.pow(x-1,2)),easeInOutCirc:x=>x<.5?(1-Math.sqrt(1-Math.pow(2*x,2)))/2:(Math.sqrt(1-Math.pow(-2*x+2,2))+1)/2,easeInBack:x=>c3*x*x*x-c1*x*x,easeOutBack:x=>1+c3*Math.pow(x-1,3)+c1*Math.pow(x-1,2),easeInOutBack:x=>x<.5?Math.pow(2*x,2)*((c2+1)*2*x-c2)/2:(Math.pow(2*x-2,2)*((c2+1)*(x*2-2)+c2)+2)/2,easeInElastic:x=>x===0?0:x===1?1:-Math.pow(2,10*x-10)*Math.sin((x*10-10.75)*c4),easeOutElastic:x=>x===0?0:x===1?1:Math.pow(2,-10*x)*Math.sin((x*10-.75)*c4)+1,easeInOutElastic:x=>x===0?0:x===1?1:x<.5?-(Math.pow(2,20*x-10)*Math.sin((20*x-11.125)*c5))/2:Math.pow(2,-20*x+10)*Math.sin((20*x-11.125)*c5)/2+1,easeInBounce:x=>1-bounceOut(1-x),easeOutBounce:bounceOut,easeInOutBounce:x=>x<.5?(1-bounceOut(1-2*x))/2:(1+bounceOut(2*x-1))/2},defaults=_extends3({},config.default,{mass:1,damping:1,easing:easings.linear,clamp:!1}),AnimationConfig=class{constructor(){this.tension=void 0,this.friction=void 0,this.frequency=void 0,this.damping=void 0,this.mass=void 0,this.velocity=0,this.restVelocity=void 0,this.precision=void 0,this.progress=void 0,this.duration=void 0,this.easing=void 0,this.clamp=void 0,this.bounce=void 0,this.decay=void 0,this.round=void 0,Object.assign(this,defaults)}};function mergeConfig(config2,newConfig,defaultConfig){defaultConfig&&(defaultConfig=_extends3({},defaultConfig),sanitizeConfig(defaultConfig,newConfig),newConfig=_extends3({},defaultConfig,newConfig)),sanitizeConfig(config2,newConfig),Object.assign(config2,newConfig);for(let key in defaults)config2[key]==null&&(config2[key]=defaults[key]);let{mass,frequency,damping}=config2;return is.und(frequency)||(frequency<.01&&(frequency=.01),damping<0&&(damping=0),config2.tension=Math.pow(2*Math.PI/frequency,2)*mass,config2.friction=4*Math.PI*damping*mass/frequency),config2}function sanitizeConfig(config2,props){if(!is.und(props.decay))config2.duration=void 0;else{let isTensionConfig=!is.und(props.tension)||!is.und(props.friction);(isTensionConfig||!is.und(props.frequency)||!is.und(props.damping)||!is.und(props.mass))&&(config2.duration=void 0,config2.decay=void 0),isTensionConfig&&(config2.frequency=void 0)}}var emptyArray=[],Animation=class{constructor(){this.changed=!1,this.values=emptyArray,this.toValues=null,this.fromValues=emptyArray,this.to=void 0,this.from=void 0,this.config=new AnimationConfig,this.immediate=!1}};function scheduleProps(callId,{key,props,defaultProps,state,actions}){return new Promise((resolve,reject)=>{var _props$cancel;let delay,timeout,cancel=matchProp((_props$cancel=props.cancel)!=null?_props$cancel:defaultProps==null?void 0:defaultProps.cancel,key);if(cancel)onStart();else{is.und(props.pause)||(state.paused=matchProp(props.pause,key));let pause=defaultProps==null?void 0:defaultProps.pause;pause!==!0&&(pause=state.paused||matchProp(pause,key)),delay=callProp(props.delay||0,key),pause?(state.resumeQueue.add(onResume),actions.pause()):(actions.resume(),onResume())}function onPause(){state.resumeQueue.add(onResume),state.timeouts.delete(timeout),timeout.cancel(),delay=timeout.time-raf.now()}function onResume(){delay>0&&!globals.skipAnimation?(state.delayed=!0,timeout=raf.setTimeout(onStart,delay),state.pauseQueue.add(onPause),state.timeouts.add(timeout)):onStart()}function onStart(){state.delayed&&(state.delayed=!1),state.pauseQueue.delete(onPause),state.timeouts.delete(timeout),callId<=(state.cancelId||0)&&(cancel=!0);try{actions.start(_extends3({},props,{callId,cancel}),resolve)}catch(err){reject(err)}}})}var getCombinedResult=(target,results)=>results.length==1?results[0]:results.some(result=>result.cancelled)?getCancelledResult(target.get()):results.every(result=>result.noop)?getNoopResult(target.get()):getFinishedResult(target.get(),results.every(result=>result.finished)),getNoopResult=value=>({value,noop:!0,finished:!0,cancelled:!1}),getFinishedResult=(value,finished,cancelled=!1)=>({value,finished,cancelled}),getCancelledResult=value=>({value,cancelled:!0,finished:!1});function runAsync(to2,props,state,target){let{callId,parentId,onRest}=props,{asyncTo:prevTo,promise:prevPromise}=state;return!parentId&&to2===prevTo&&!props.reset?prevPromise:state.promise=(async()=>{state.asyncId=callId,state.asyncTo=to2;let defaultProps=getDefaultProps(props,(value,key)=>key==="onRest"?void 0:value),preventBail,bail,bailPromise=new Promise((resolve,reject)=>(preventBail=resolve,bail=reject)),bailIfEnded=bailSignal=>{let bailResult=callId<=(state.cancelId||0)&&getCancelledResult(target)||callId!==state.asyncId&&getFinishedResult(target,!1);if(bailResult)throw bailSignal.result=bailResult,bail(bailSignal),bailSignal},animate=(arg1,arg2)=>{let bailSignal=new BailSignal,skipAnimationSignal=new SkipAniamtionSignal;return(async()=>{if(globals.skipAnimation)throw stopAsync(state),skipAnimationSignal.result=getFinishedResult(target,!1),bail(skipAnimationSignal),skipAnimationSignal;bailIfEnded(bailSignal);let props2=is.obj(arg1)?_extends3({},arg1):_extends3({},arg2,{to:arg1});props2.parentId=callId,eachProp(defaultProps,(value,key)=>{is.und(props2[key])&&(props2[key]=value)});let result2=await target.start(props2);return bailIfEnded(bailSignal),state.paused&&await new Promise(resume=>{state.resumeQueue.add(resume)}),result2})()},result;if(globals.skipAnimation)return stopAsync(state),getFinishedResult(target,!1);try{let animating;is.arr(to2)?animating=(async queue=>{for(let props2 of queue)await animate(props2)})(to2):animating=Promise.resolve(to2(animate,target.stop.bind(target))),await Promise.all([animating.then(preventBail),bailPromise]),result=getFinishedResult(target.get(),!0,!1)}catch(err){if(err instanceof BailSignal)result=err.result;else if(err instanceof SkipAniamtionSignal)result=err.result;else throw err}finally{callId==state.asyncId&&(state.asyncId=parentId,state.asyncTo=parentId?prevTo:void 0,state.promise=parentId?prevPromise:void 0)}return is.fun(onRest)&&raf.batchedUpdates(()=>{onRest(result,target,target.item)}),result})()}function stopAsync(state,cancelId){flush(state.timeouts,t=>t.cancel()),state.pauseQueue.clear(),state.resumeQueue.clear(),state.asyncId=state.asyncTo=state.promise=void 0,cancelId&&(state.cancelId=cancelId)}var BailSignal=class extends Error{constructor(){super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."),this.result=void 0}},SkipAniamtionSignal=class extends Error{constructor(){super("SkipAnimationSignal"),this.result=void 0}},isFrameValue=value=>value instanceof FrameValue,nextId$1=1,FrameValue=class extends FluidValue{constructor(...args){super(...args),this.id=nextId$1++,this.key=void 0,this._priority=0}get priority(){return this._priority}set priority(priority2){this._priority!=priority2&&(this._priority=priority2,this._onPriorityChange(priority2))}get(){let node=getAnimated(this);return node&&node.getValue()}to(...args){return globals.to(this,args)}interpolate(...args){return deprecateInterpolate(),globals.to(this,args)}toJSON(){return this.get()}observerAdded(count){count==1&&this._attach()}observerRemoved(count){count==0&&this._detach()}_attach(){}_detach(){}_onChange(value,idle=!1){callFluidObservers(this,{type:"change",parent:this,value,idle})}_onPriorityChange(priority2){this.idle||frameLoop.sort(this),callFluidObservers(this,{type:"priority",parent:this,priority:priority2})}},$P=Symbol.for("SpringPhase"),HAS_ANIMATED=1,IS_ANIMATING=2,IS_PAUSED=4,hasAnimated=target=>(target[$P]&HAS_ANIMATED)>0,isAnimating=target=>(target[$P]&IS_ANIMATING)>0,isPaused=target=>(target[$P]&IS_PAUSED)>0,setActiveBit=(target,active)=>active?target[$P]|=IS_ANIMATING|HAS_ANIMATED:target[$P]&=~IS_ANIMATING,setPausedBit=(target,paused)=>paused?target[$P]|=IS_PAUSED:target[$P]&=~IS_PAUSED,SpringValue=class extends FrameValue{constructor(arg1,arg2){if(super(),this.key=void 0,this.animation=new Animation,this.queue=void 0,this.defaultProps={},this._state={paused:!1,delayed:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set},this._pendingCalls=new Set,this._lastCallId=0,this._lastToId=0,this._memoizedDuration=0,!is.und(arg1)||!is.und(arg2)){let props=is.obj(arg1)?_extends3({},arg1):_extends3({},arg2,{from:arg1});is.und(props.default)&&(props.default=!0),this.start(props)}}get idle(){return!(isAnimating(this)||this._state.asyncTo)||isPaused(this)}get goal(){return getFluidValue(this.animation.to)}get velocity(){let node=getAnimated(this);return node instanceof AnimatedValue?node.lastVelocity||0:node.getPayload().map(node2=>node2.lastVelocity||0)}get hasAnimated(){return hasAnimated(this)}get isAnimating(){return isAnimating(this)}get isPaused(){return isPaused(this)}get isDelayed(){return this._state.delayed}advance(dt){let idle=!0,changed=!1,anim=this.animation,{config:config2,toValues}=anim,payload=getPayload(anim.to);!payload&&hasFluidValue(anim.to)&&(toValues=toArray(getFluidValue(anim.to))),anim.values.forEach((node2,i)=>{if(node2.done)return;let to2=node2.constructor==AnimatedString?1:payload?payload[i].lastPosition:toValues[i],finished=anim.immediate,position=to2;if(!finished){if(position=node2.lastPosition,config2.tension<=0){node2.done=!0;return}let elapsed=node2.elapsedTime+=dt,from=anim.fromValues[i],v0=node2.v0!=null?node2.v0:node2.v0=is.arr(config2.velocity)?config2.velocity[i]:config2.velocity,velocity;if(is.und(config2.duration))if(config2.decay){let decay=config2.decay===!0?.998:config2.decay,e=Math.exp(-(1-decay)*elapsed);position=from+v0/(1-decay)*(1-e),finished=Math.abs(node2.lastPosition-position)<.1,velocity=v0*e}else{velocity=node2.lastVelocity==null?v0:node2.lastVelocity;let precision=config2.precision||(from==to2?.005:Math.min(1,Math.abs(to2-from)*.001)),restVelocity=config2.restVelocity||precision/10,bounceFactor=config2.clamp?0:config2.bounce,canBounce=!is.und(bounceFactor),isGrowing=from==to2?node2.v0>0:from<to2,isMoving,isBouncing=!1,step=1,numSteps=Math.ceil(dt/step);for(let n=0;n<numSteps&&(isMoving=Math.abs(velocity)>restVelocity,!(!isMoving&&(finished=Math.abs(to2-position)<=precision,finished)));++n){canBounce&&(isBouncing=position==to2||position>to2==isGrowing,isBouncing&&(velocity=-velocity*bounceFactor,position=to2));let springForce=-config2.tension*1e-6*(position-to2),dampingForce=-config2.friction*.001*velocity,acceleration=(springForce+dampingForce)/config2.mass;velocity=velocity+acceleration*step,position=position+velocity*step}}else{let p=1;config2.duration>0&&(this._memoizedDuration!==config2.duration&&(this._memoizedDuration=config2.duration,node2.durationProgress>0&&(node2.elapsedTime=config2.duration*node2.durationProgress,elapsed=node2.elapsedTime+=dt)),p=(config2.progress||0)+elapsed/this._memoizedDuration,p=p>1?1:p<0?0:p,node2.durationProgress=p),position=from+config2.easing(p)*(to2-from),velocity=(position-node2.lastPosition)/dt,finished=p==1}node2.lastVelocity=velocity,Number.isNaN(position)&&(console.warn("Got NaN while animating:",this),finished=!0)}payload&&!payload[i].done&&(finished=!1),finished?node2.done=!0:idle=!1,node2.setValue(position,config2.round)&&(changed=!0)});let node=getAnimated(this),currVal=node.getValue();if(idle){let finalVal=getFluidValue(anim.to);(currVal!==finalVal||changed)&&!config2.decay?(node.setValue(finalVal),this._onChange(finalVal)):changed&&config2.decay&&this._onChange(currVal),this._stop()}else changed&&this._onChange(currVal)}set(value){return raf.batchedUpdates(()=>{this._stop(),this._focus(value),this._set(value)}),this}pause(){this._update({pause:!0})}resume(){this._update({pause:!1})}finish(){if(isAnimating(this)){let{to:to2,config:config2}=this.animation;raf.batchedUpdates(()=>{this._onStart(),config2.decay||this._set(to2,!1),this._stop()})}return this}update(props){return(this.queue||(this.queue=[])).push(props),this}start(to2,arg2){let queue;return is.und(to2)?(queue=this.queue||[],this.queue=[]):queue=[is.obj(to2)?to2:_extends3({},arg2,{to:to2})],Promise.all(queue.map(props=>this._update(props))).then(results=>getCombinedResult(this,results))}stop(cancel){let{to:to2}=this.animation;return this._focus(this.get()),stopAsync(this._state,cancel&&this._lastCallId),raf.batchedUpdates(()=>this._stop(to2,cancel)),this}reset(){this._update({reset:!0})}eventObserved(event){event.type=="change"?this._start():event.type=="priority"&&(this.priority=event.priority+1)}_prepareNode(props){let key=this.key||"",{to:to2,from}=props;to2=is.obj(to2)?to2[key]:to2,(to2==null||isAsyncTo(to2))&&(to2=void 0),from=is.obj(from)?from[key]:from,from==null&&(from=void 0);let range={to:to2,from};return hasAnimated(this)||(props.reverse&&([to2,from]=[from,to2]),from=getFluidValue(from),is.und(from)?getAnimated(this)||this._set(to2):this._set(from)),range}_update(_ref,isLoop){let props=_extends3({},_ref),{key,defaultProps}=this;props.default&&Object.assign(defaultProps,getDefaultProps(props,(value,prop)=>/^on/.test(prop)?resolveProp(value,key):value)),mergeActiveFn(this,props,"onProps"),sendEvent(this,"onProps",props,this);let range=this._prepareNode(props);if(Object.isFrozen(this))throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");let state=this._state;return scheduleProps(++this._lastCallId,{key,props,defaultProps,state,actions:{pause:()=>{isPaused(this)||(setPausedBit(this,!0),flushCalls(state.pauseQueue),sendEvent(this,"onPause",getFinishedResult(this,checkFinished(this,this.animation.to)),this))},resume:()=>{isPaused(this)&&(setPausedBit(this,!1),isAnimating(this)&&this._resume(),flushCalls(state.resumeQueue),sendEvent(this,"onResume",getFinishedResult(this,checkFinished(this,this.animation.to)),this))},start:this._merge.bind(this,range)}}).then(result=>{if(props.loop&&result.finished&&!(isLoop&&result.noop)){let nextProps=createLoopUpdate(props);if(nextProps)return this._update(nextProps,!0)}return result})}_merge(range,props,resolve){if(props.cancel)return this.stop(!0),resolve(getCancelledResult(this));let hasToProp=!is.und(range.to),hasFromProp=!is.und(range.from);if(hasToProp||hasFromProp)if(props.callId>this._lastToId)this._lastToId=props.callId;else return resolve(getCancelledResult(this));let{key,defaultProps,animation:anim}=this,{to:prevTo,from:prevFrom}=anim,{to:to2=prevTo,from=prevFrom}=range;hasFromProp&&!hasToProp&&(!props.default||is.und(to2))&&(to2=from),props.reverse&&([to2,from]=[from,to2]);let hasFromChanged=!isEqual(from,prevFrom);hasFromChanged&&(anim.from=from),from=getFluidValue(from);let hasToChanged=!isEqual(to2,prevTo);hasToChanged&&this._focus(to2);let hasAsyncTo=isAsyncTo(props.to),{config:config2}=anim,{decay,velocity}=config2;(hasToProp||hasFromProp)&&(config2.velocity=0),props.config&&!hasAsyncTo&&mergeConfig(config2,callProp(props.config,key),props.config!==defaultProps.config?callProp(defaultProps.config,key):void 0);let node=getAnimated(this);if(!node||is.und(to2))return resolve(getFinishedResult(this,!0));let reset=is.und(props.reset)?hasFromProp&&!props.default:!is.und(from)&&matchProp(props.reset,key),value=reset?from:this.get(),goal=computeGoal(to2),isAnimatable=is.num(goal)||is.arr(goal)||isAnimatedString(goal),immediate=!hasAsyncTo&&(!isAnimatable||matchProp(defaultProps.immediate||props.immediate,key));if(hasToChanged){let nodeType=getAnimatedType(to2);if(nodeType!==node.constructor)if(immediate)node=this._set(goal);else throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`)}let goalType=node.constructor,started=hasFluidValue(to2),finished=!1;if(!started){let hasValueChanged=reset||!hasAnimated(this)&&hasFromChanged;(hasToChanged||hasValueChanged)&&(finished=isEqual(computeGoal(value),goal),started=!finished),(!isEqual(anim.immediate,immediate)&&!immediate||!isEqual(config2.decay,decay)||!isEqual(config2.velocity,velocity))&&(started=!0)}if(finished&&isAnimating(this)&&(anim.changed&&!reset?started=!0:started||this._stop(prevTo)),!hasAsyncTo&&((started||hasFluidValue(prevTo))&&(anim.values=node.getPayload(),anim.toValues=hasFluidValue(to2)?null:goalType==AnimatedString?[1]:toArray(goal)),anim.immediate!=immediate&&(anim.immediate=immediate,!immediate&&!reset&&this._set(prevTo)),started)){let{onRest}=anim;each(ACTIVE_EVENTS,type=>mergeActiveFn(this,props,type));let result=getFinishedResult(this,checkFinished(this,prevTo));flushCalls(this._pendingCalls,result),this._pendingCalls.add(resolve),anim.changed&&raf.batchedUpdates(()=>{anim.changed=!reset,onRest==null||onRest(result,this),reset?callProp(defaultProps.onRest,result):anim.onStart==null||anim.onStart(result,this)})}reset&&this._set(value),hasAsyncTo?resolve(runAsync(props.to,props,this._state,this)):started?this._start():isAnimating(this)&&!hasToChanged?this._pendingCalls.add(resolve):resolve(getNoopResult(value))}_focus(value){let anim=this.animation;value!==anim.to&&(getFluidObservers(this)&&this._detach(),anim.to=value,getFluidObservers(this)&&this._attach())}_attach(){let priority2=0,{to:to2}=this.animation;hasFluidValue(to2)&&(addFluidObserver(to2,this),isFrameValue(to2)&&(priority2=to2.priority+1)),this.priority=priority2}_detach(){let{to:to2}=this.animation;hasFluidValue(to2)&&removeFluidObserver(to2,this)}_set(arg,idle=!0){let value=getFluidValue(arg);if(!is.und(value)){let oldNode=getAnimated(this);if(!oldNode||!isEqual(value,oldNode.getValue())){let nodeType=getAnimatedType(value);!oldNode||oldNode.constructor!=nodeType?setAnimated(this,nodeType.create(value)):oldNode.setValue(value),oldNode&&raf.batchedUpdates(()=>{this._onChange(value,idle)})}}return getAnimated(this)}_onStart(){let anim=this.animation;anim.changed||(anim.changed=!0,sendEvent(this,"onStart",getFinishedResult(this,checkFinished(this,anim.to)),this))}_onChange(value,idle){idle||(this._onStart(),callProp(this.animation.onChange,value,this)),callProp(this.defaultProps.onChange,value,this),super._onChange(value,idle)}_start(){let anim=this.animation;getAnimated(this).reset(getFluidValue(anim.to)),anim.immediate||(anim.fromValues=anim.values.map(node=>node.lastPosition)),isAnimating(this)||(setActiveBit(this,!0),isPaused(this)||this._resume())}_resume(){globals.skipAnimation?this.finish():frameLoop.start(this)}_stop(goal,cancel){if(isAnimating(this)){setActiveBit(this,!1);let anim=this.animation;each(anim.values,node=>{node.done=!0}),anim.toValues&&(anim.onChange=anim.onPause=anim.onResume=void 0),callFluidObservers(this,{type:"idle",parent:this});let result=cancel?getCancelledResult(this.get()):getFinishedResult(this.get(),checkFinished(this,goal!=null?goal:anim.to));flushCalls(this._pendingCalls,result),anim.changed&&(anim.changed=!1,sendEvent(this,"onRest",result,this))}}};function checkFinished(target,to2){let goal=computeGoal(to2),value=computeGoal(target.get());return isEqual(value,goal)}function createLoopUpdate(props,loop2=props.loop,to2=props.to){let loopRet=callProp(loop2);if(loopRet){let overrides=loopRet!==!0&&inferTo(loopRet),reverse=(overrides||props).reverse,reset=!overrides||overrides.reset;return createUpdate(_extends3({},props,{loop:loop2,default:!1,pause:void 0,to:!reverse||isAsyncTo(to2)?to2:void 0,from:reset?props.from:void 0,reset},overrides))}}function createUpdate(props){let{to:to2,from}=props=inferTo(props),keys=new Set;return is.obj(to2)&&findDefined(to2,keys),is.obj(from)&&findDefined(from,keys),props.keys=keys.size?Array.from(keys):null,props}function declareUpdate(props){let update3=createUpdate(props);return is.und(update3.default)&&(update3.default=getDefaultProps(update3)),update3}function findDefined(values,keys){eachProp(values,(value,key)=>value!=null&&keys.add(key))}var ACTIVE_EVENTS=["onStart","onRest","onChange","onPause","onResume"];function mergeActiveFn(target,props,type){target.animation[type]=props[type]!==getDefaultProp(props,type)?resolveProp(props[type],target.key):void 0}function sendEvent(target,type,...args){var _target$animation$typ,_target$animation,_target$defaultProps$,_target$defaultProps;(_target$animation$typ=(_target$animation=target.animation)[type])==null||_target$animation$typ.call(_target$animation,...args),(_target$defaultProps$=(_target$defaultProps=target.defaultProps)[type])==null||_target$defaultProps$.call(_target$defaultProps,...args)}var BATCHED_EVENTS=["onStart","onChange","onRest"],nextId=1,Controller=class{constructor(props,flush2){this.id=nextId++,this.springs={},this.queue=[],this.ref=void 0,this._flush=void 0,this._initialProps=void 0,this._lastAsyncId=0,this._active=new Set,this._changed=new Set,this._started=!1,this._item=void 0,this._state={paused:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set},this._events={onStart:new Map,onChange:new Map,onRest:new Map},this._onFrame=this._onFrame.bind(this),flush2&&(this._flush=flush2),props&&this.start(_extends3({default:!0},props))}get idle(){return!this._state.asyncTo&&Object.values(this.springs).every(spring=>spring.idle&&!spring.isDelayed&&!spring.isPaused)}get item(){return this._item}set item(item){this._item=item}get(){let values={};return this.each((spring,key)=>values[key]=spring.get()),values}set(values){for(let key in values){let value=values[key];is.und(value)||this.springs[key].set(value)}}update(props){return props&&this.queue.push(createUpdate(props)),this}start(props){let{queue}=this;return props?queue=toArray(props).map(createUpdate):this.queue=[],this._flush?this._flush(this,queue):(prepareKeys(this,queue),flushUpdateQueue(this,queue))}stop(arg,keys){if(arg!==!!arg&&(keys=arg),keys){let springs=this.springs;each(toArray(keys),key=>springs[key].stop(!!arg))}else stopAsync(this._state,this._lastAsyncId),this.each(spring=>spring.stop(!!arg));return this}pause(keys){if(is.und(keys))this.start({pause:!0});else{let springs=this.springs;each(toArray(keys),key=>springs[key].pause())}return this}resume(keys){if(is.und(keys))this.start({pause:!1});else{let springs=this.springs;each(toArray(keys),key=>springs[key].resume())}return this}each(iterator){eachProp(this.springs,iterator)}_onFrame(){let{onStart,onChange,onRest}=this._events,active=this._active.size>0,changed=this._changed.size>0;(active&&!this._started||changed&&!this._started)&&(this._started=!0,flush(onStart,([onStart2,result])=>{result.value=this.get(),onStart2(result,this,this._item)}));let idle=!active&&this._started,values=changed||idle&&onRest.size?this.get():null;changed&&onChange.size&&flush(onChange,([onChange2,result])=>{result.value=values,onChange2(result,this,this._item)}),idle&&(this._started=!1,flush(onRest,([onRest2,result])=>{result.value=values,onRest2(result,this,this._item)}))}eventObserved(event){if(event.type=="change")this._changed.add(event.parent),event.idle||this._active.add(event.parent);else if(event.type=="idle")this._active.delete(event.parent);else return;raf.onFrame(this._onFrame)}};function flushUpdateQueue(ctrl,queue){return Promise.all(queue.map(props=>flushUpdate(ctrl,props))).then(results=>getCombinedResult(ctrl,results))}async function flushUpdate(ctrl,props,isLoop){let{keys,to:to2,from,loop:loop2,onRest,onResolve}=props,defaults2=is.obj(props.default)&&props.default;loop2&&(props.loop=!1),to2===!1&&(props.to=null),from===!1&&(props.from=null);let asyncTo=is.arr(to2)||is.fun(to2)?to2:void 0;asyncTo?(props.to=void 0,props.onRest=void 0,defaults2&&(defaults2.onRest=void 0)):each(BATCHED_EVENTS,key=>{let handler=props[key];if(is.fun(handler)){let queue=ctrl._events[key];props[key]=({finished,cancelled})=>{let result2=queue.get(handler);result2?(finished||(result2.finished=!1),cancelled&&(result2.cancelled=!0)):queue.set(handler,{value:null,finished:finished||!1,cancelled:cancelled||!1})},defaults2&&(defaults2[key]=props[key])}});let state=ctrl._state;props.pause===!state.paused?(state.paused=props.pause,flushCalls(props.pause?state.pauseQueue:state.resumeQueue)):state.paused&&(props.pause=!0);let promises=(keys||Object.keys(ctrl.springs)).map(key=>ctrl.springs[key].start(props)),cancel=props.cancel===!0||getDefaultProp(props,"cancel")===!0;(asyncTo||cancel&&state.asyncId)&&promises.push(scheduleProps(++ctrl._lastAsyncId,{props,state,actions:{pause:noop,resume:noop,start(props2,resolve){cancel?(stopAsync(state,ctrl._lastAsyncId),resolve(getCancelledResult(ctrl))):(props2.onRest=onRest,resolve(runAsync(asyncTo,props2,state,ctrl)))}}})),state.paused&&await new Promise(resume=>{state.resumeQueue.add(resume)});let result=getCombinedResult(ctrl,await Promise.all(promises));if(loop2&&result.finished&&!(isLoop&&result.noop)){let nextProps=createLoopUpdate(props,loop2,to2);if(nextProps)return prepareKeys(ctrl,[nextProps]),flushUpdate(ctrl,nextProps,!0)}return onResolve&&raf.batchedUpdates(()=>onResolve(result,ctrl,ctrl.item)),result}function getSprings(ctrl,props){let springs=_extends3({},ctrl.springs);return props&&each(toArray(props),props2=>{is.und(props2.keys)&&(props2=createUpdate(props2)),is.obj(props2.to)||(props2=_extends3({},props2,{to:void 0})),prepareSprings(springs,props2,key=>createSpring(key))}),setSprings(ctrl,springs),springs}function setSprings(ctrl,springs){eachProp(springs,(spring,key)=>{ctrl.springs[key]||(ctrl.springs[key]=spring,addFluidObserver(spring,ctrl))})}function createSpring(key,observer){let spring=new SpringValue;return spring.key=key,observer&&addFluidObserver(spring,observer),spring}function prepareSprings(springs,props,create){props.keys&&each(props.keys,key=>{(springs[key]||(springs[key]=create(key)))._prepareNode(props)})}function prepareKeys(ctrl,queue){each(queue,props=>{prepareSprings(ctrl.springs,props,key=>createSpring(key,ctrl))})}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={},sourceKeys=Object.keys(source),key,i;for(i=0;i<sourceKeys.length;i++)key=sourceKeys[i],!(excluded.indexOf(key)>=0)&&(target[key]=source[key]);return target}var _excluded$3=["children"],SpringContext=_ref=>{let{children}=_ref,props=_objectWithoutPropertiesLoose(_ref,_excluded$3),inherited=(0,import_react3.useContext)(ctx),pause=props.pause||!!inherited.pause,immediate=props.immediate||!!inherited.immediate;props=useMemoOne(()=>({pause,immediate}),[pause,immediate]);let{Provider}=ctx;return React3.createElement(Provider,{value:props},children)},ctx=makeContext(SpringContext,{});SpringContext.Provider=ctx.Provider;SpringContext.Consumer=ctx.Consumer;function makeContext(target,init){return Object.assign(target,React3.createContext(init)),target.Provider._context=target,target.Consumer._context=target,target}var SpringRef=()=>{let current=[],SpringRef2=function(props){deprecateDirectCall();let results=[];return each(current,(ctrl,i)=>{if(is.und(props))results.push(ctrl.start());else{let update3=_getProps(props,ctrl,i);update3&&results.push(ctrl.start(update3))}}),results};SpringRef2.current=current,SpringRef2.add=function(ctrl){current.includes(ctrl)||current.push(ctrl)},SpringRef2.delete=function(ctrl){let i=current.indexOf(ctrl);~i&&current.splice(i,1)},SpringRef2.pause=function(){return each(current,ctrl=>ctrl.pause(...arguments)),this},SpringRef2.resume=function(){return each(current,ctrl=>ctrl.resume(...arguments)),this},SpringRef2.set=function(values){each(current,ctrl=>ctrl.set(values))},SpringRef2.start=function(props){let results=[];return each(current,(ctrl,i)=>{if(is.und(props))results.push(ctrl.start());else{let update3=this._getProps(props,ctrl,i);update3&&results.push(ctrl.start(update3))}}),results},SpringRef2.stop=function(){return each(current,ctrl=>ctrl.stop(...arguments)),this},SpringRef2.update=function(props){return each(current,(ctrl,i)=>ctrl.update(this._getProps(props,ctrl,i))),this};let _getProps=function(arg,ctrl,index){return is.fun(arg)?arg(index,ctrl):arg};return SpringRef2._getProps=_getProps,SpringRef2};function useSprings(length,props,deps){let propsFn=is.fun(props)&&props;propsFn&&!deps&&(deps=[]);let ref=(0,import_react3.useMemo)(()=>propsFn||arguments.length==3?SpringRef():void 0,[]),layoutId=(0,import_react3.useRef)(0),forceUpdate=useForceUpdate(),state=(0,import_react3.useMemo)(()=>({ctrls:[],queue:[],flush(ctrl,updates2){let springs2=getSprings(ctrl,updates2);return layoutId.current>0&&!state.queue.length&&!Object.keys(springs2).some(key=>!ctrl.springs[key])?flushUpdateQueue(ctrl,updates2):new Promise(resolve=>{setSprings(ctrl,springs2),state.queue.push(()=>{resolve(flushUpdateQueue(ctrl,updates2))}),forceUpdate()})}}),[]),ctrls=(0,import_react3.useRef)([...state.ctrls]),updates=[],prevLength=usePrev(length)||0;(0,import_react3.useMemo)(()=>{each(ctrls.current.slice(length,prevLength),ctrl=>{detachRefs(ctrl,ref),ctrl.stop(!0)}),ctrls.current.length=length,declareUpdates(prevLength,length)},[length]),(0,import_react3.useMemo)(()=>{declareUpdates(0,Math.min(prevLength,length))},deps);function declareUpdates(startIndex,endIndex){for(let i=startIndex;i<endIndex;i++){let ctrl=ctrls.current[i]||(ctrls.current[i]=new Controller(null,state.flush)),update3=propsFn?propsFn(i,ctrl):props[i];update3&&(updates[i]=declareUpdate(update3))}}let springs=ctrls.current.map((ctrl,i)=>getSprings(ctrl,updates[i])),context=(0,import_react3.useContext)(SpringContext),prevContext=usePrev(context),hasContext=context!==prevContext&&hasProps(context);useLayoutEffect2(()=>{layoutId.current++,state.ctrls=ctrls.current;let{queue}=state;queue.length&&(state.queue=[],each(queue,cb=>cb())),each(ctrls.current,(ctrl,i)=>{ref==null||ref.add(ctrl),hasContext&&ctrl.start({default:context});let update3=updates[i];update3&&(replaceRef(ctrl,update3.ref),ctrl.ref?ctrl.queue.push(update3):ctrl.start(update3))})}),useOnce(()=>()=>{each(state.ctrls,ctrl=>ctrl.stop(!0))});let values=springs.map(x=>_extends3({},x));return ref?[values,ref]:values}function useSpring(props,deps){let isFn=is.fun(props),[[values],ref]=useSprings(1,isFn?props:[props],isFn?deps||[]:deps);return isFn||arguments.length==2?[values,ref]:values}function useTrail(length,propsArg,deps){var _passedRef;let propsFn=is.fun(propsArg)&&propsArg;propsFn&&!deps&&(deps=[]);let reverse=!0,passedRef,result=useSprings(length,(i,ctrl)=>{let props=propsFn?propsFn(i,ctrl):propsArg;return passedRef=props.ref,reverse=reverse&&props.reverse,props},deps||[{}]),ref=(_passedRef=passedRef)!=null?_passedRef:result[1];return useLayoutEffect2(()=>{each(ref.current,(ctrl,i)=>{let parent=ref.current[i+(reverse?1:-1)];parent?ctrl.start({to:parent.springs}):ctrl.start()})},deps),propsFn||arguments.length==3?(ref._getProps=(propsArg2,ctrl,i)=>{let props=is.fun(propsArg2)?propsArg2(i,ctrl):propsArg2;if(props){let parent=ref.current[i+(props.reverse?1:-1)];return parent&&(props.to=parent.springs),props}},result):(ref.start=propsArg2=>{let results=[];return each(ref.current,(ctrl,i)=>{let props=is.fun(propsArg2)?propsArg2(i,ctrl):propsArg2,parent=ref.current[i+(reverse?1:-1)];parent?results.push(ctrl.start(_extends3({},props,{to:parent.springs}))):results.push(ctrl.start(_extends3({},props)))}),results},result[0])}var TransitionPhase;(function(TransitionPhase2){TransitionPhase2.MOUNT="mount",TransitionPhase2.ENTER="enter",TransitionPhase2.UPDATE="update",TransitionPhase2.LEAVE="leave"})(TransitionPhase||(TransitionPhase={}));function useTransition(data,props,deps){let propsFn=is.fun(props)&&props,{reset,sort,trail=0,expires=!0,exitBeforeEnter=!1,onDestroyed,ref:propsRef,config:propsConfig}=propsFn?propsFn():props,ref=(0,import_react3.useMemo)(()=>propsFn||arguments.length==3?SpringRef():void 0,[]),items=toArray(data),transitions=[],usedTransitions=(0,import_react3.useRef)(null),prevTransitions=reset?null:usedTransitions.current;useLayoutEffect2(()=>{usedTransitions.current=transitions}),useOnce(()=>()=>{each(usedTransitions.current,t=>{t.expired&&clearTimeout(t.expirationId),detachRefs(t.ctrl,ref),t.ctrl.stop(!0)})});let keys=getKeys(items,propsFn?propsFn():props,prevTransitions),expired=reset&&usedTransitions.current||[];useLayoutEffect2(()=>each(expired,({ctrl,item,key})=>{detachRefs(ctrl,ref),callProp(onDestroyed,item,key)}));let reused=[];if(prevTransitions&&each(prevTransitions,(t,i)=>{t.expired?(clearTimeout(t.expirationId),expired.push(t)):(i=reused[i]=keys.indexOf(t.key),~i&&(transitions[i]=t))}),each(items,(item,i)=>{transitions[i]||(transitions[i]={key:keys[i],item,phase:TransitionPhase.MOUNT,ctrl:new Controller},transitions[i].ctrl.item=item)}),reused.length){let i=-1,{leave}=propsFn?propsFn():props;each(reused,(keyIndex,prevIndex)=>{let t=prevTransitions[prevIndex];~keyIndex?(i=transitions.indexOf(t),transitions[i]=_extends3({},t,{item:items[keyIndex]})):leave&&transitions.splice(++i,0,t)})}is.fun(sort)&&transitions.sort((a,b)=>sort(a.item,b.item));let delay=-trail,forceUpdate=useForceUpdate(),defaultProps=getDefaultProps(props),changes=new Map,exitingTransitions=(0,import_react3.useRef)(new Map),forceChange=(0,import_react3.useRef)(!1);each(transitions,(t,i)=>{let key=t.key,prevPhase=t.phase,p=propsFn?propsFn():props,to2,phase,propsDelay=callProp(p.delay||0,key);if(prevPhase==TransitionPhase.MOUNT)to2=p.enter,phase=TransitionPhase.ENTER;else{let isLeave=keys.indexOf(key)<0;if(prevPhase!=TransitionPhase.LEAVE)if(isLeave)to2=p.leave,phase=TransitionPhase.LEAVE;else if(to2=p.update)phase=TransitionPhase.UPDATE;else return;else if(!isLeave)to2=p.enter,phase=TransitionPhase.ENTER;else return}if(to2=callProp(to2,t.item,i),to2=is.obj(to2)?inferTo(to2):{to:to2},!to2.config){let config2=propsConfig||defaultProps.config;to2.config=callProp(config2,t.item,i,phase)}delay+=trail;let payload=_extends3({},defaultProps,{delay:propsDelay+delay,ref:propsRef,immediate:p.immediate,reset:!1},to2);if(phase==TransitionPhase.ENTER&&is.und(payload.from)){let _p=propsFn?propsFn():props,from=is.und(_p.initial)||prevTransitions?_p.from:_p.initial;payload.from=callProp(from,t.item,i)}let{onResolve}=payload;payload.onResolve=result=>{callProp(onResolve,result);let transitions2=usedTransitions.current,t2=transitions2.find(t3=>t3.key===key);if(!!t2&&!(result.cancelled&&t2.phase!=TransitionPhase.UPDATE)&&t2.ctrl.idle){let idle=transitions2.every(t3=>t3.ctrl.idle);if(t2.phase==TransitionPhase.LEAVE){let expiry=callProp(expires,t2.item);if(expiry!==!1){let expiryMs=expiry===!0?0:expiry;if(t2.expired=!0,!idle&&expiryMs>0){expiryMs<=2147483647&&(t2.expirationId=setTimeout(forceUpdate,expiryMs));return}}}idle&&transitions2.some(t3=>t3.expired)&&(exitingTransitions.current.delete(t2),exitBeforeEnter&&(forceChange.current=!0),forceUpdate())}};let springs=getSprings(t.ctrl,payload);phase===TransitionPhase.LEAVE&&exitBeforeEnter?exitingTransitions.current.set(t,{phase,springs,payload}):changes.set(t,{phase,springs,payload})});let context=(0,import_react3.useContext)(SpringContext),prevContext=usePrev(context),hasContext=context!==prevContext&&hasProps(context);useLayoutEffect2(()=>{hasContext&&each(transitions,t=>{t.ctrl.start({default:context})})},[context]),each(changes,(_,t)=>{if(exitingTransitions.current.size){let ind=transitions.findIndex(state=>state.key===t.key);transitions.splice(ind,1)}}),useLayoutEffect2(()=>{each(exitingTransitions.current.size?exitingTransitions.current:changes,({phase,payload},t)=>{let{ctrl}=t;t.phase=phase,ref==null||ref.add(ctrl),hasContext&&phase==TransitionPhase.ENTER&&ctrl.start({default:context}),payload&&(replaceRef(ctrl,payload.ref),ctrl.ref&&!forceChange.current?ctrl.update(payload):(ctrl.start(payload),forceChange.current&&(forceChange.current=!1)))})},reset?void 0:deps);let renderTransitions=render=>React3.createElement(React3.Fragment,null,transitions.map((t,i)=>{let{springs}=changes.get(t)||t.ctrl,elem=render(_extends3({},springs),t.item,t,i);return elem&&elem.type?React3.createElement(elem.type,_extends3({},elem.props,{key:is.str(t.key)||is.num(t.key)?t.key:t.ctrl.id,ref:elem.ref})):elem}));return ref?[renderTransitions,ref]:renderTransitions}var nextKey=1;function getKeys(items,{key,keys=key},prevTransitions){if(keys===null){let reused=new Set;return items.map(item=>{let t=prevTransitions&&prevTransitions.find(t2=>t2.item===item&&t2.phase!==TransitionPhase.LEAVE&&!reused.has(t2));return t?(reused.add(t),t.key):nextKey++})}return is.und(keys)?items:is.fun(keys)?items.map(keys):toArray(keys)}var Interpolation=class extends FrameValue{constructor(source,args){super(),this.key=void 0,this.idle=!0,this.calc=void 0,this._active=new Set,this.source=source,this.calc=createInterpolator(...args);let value=this._get(),nodeType=getAnimatedType(value);setAnimated(this,nodeType.create(value))}advance(_dt){let value=this._get(),oldValue=this.get();isEqual(value,oldValue)||(getAnimated(this).setValue(value),this._onChange(value,this.idle)),!this.idle&&checkIdle(this._active)&&becomeIdle(this)}_get(){let inputs=is.arr(this.source)?this.source.map(getFluidValue):toArray(getFluidValue(this.source));return this.calc(...inputs)}_start(){this.idle&&!checkIdle(this._active)&&(this.idle=!1,each(getPayload(this),node=>{node.done=!1}),globals.skipAnimation?(raf.batchedUpdates(()=>this.advance()),becomeIdle(this)):frameLoop.start(this))}_attach(){let priority2=1;each(toArray(this.source),source=>{hasFluidValue(source)&&addFluidObserver(source,this),isFrameValue(source)&&(source.idle||this._active.add(source),priority2=Math.max(priority2,source.priority+1))}),this.priority=priority2,this._start()}_detach(){each(toArray(this.source),source=>{hasFluidValue(source)&&removeFluidObserver(source,this)}),this._active.clear(),becomeIdle(this)}eventObserved(event){event.type=="change"?event.idle?this.advance():(this._active.add(event.parent),this._start()):event.type=="idle"?this._active.delete(event.parent):event.type=="priority"&&(this.priority=toArray(this.source).reduce((highest,parent)=>Math.max(highest,(isFrameValue(parent)?parent.priority:0)+1),0))}};function isIdle(source){return source.idle!==!1}function checkIdle(active){return!active.size||Array.from(active).every(isIdle)}function becomeIdle(self){self.idle||(self.idle=!0,each(getPayload(self),node=>{node.done=!0}),callFluidObservers(self,{type:"idle",parent:self}))}var interpolate2=(source,...args)=>(deprecateInterpolate(),new Interpolation(source,args));globals.assign({createStringInterpolator,to:(source,args)=>new Interpolation(source,args)});var update2=frameLoop.advance;var import_react_dom=require("react-dom");function _objectWithoutPropertiesLoose2(source,excluded){if(source==null)return{};var target={},sourceKeys=Object.keys(source),key,i;for(i=0;i<sourceKeys.length;i++)key=sourceKeys[i],!(excluded.indexOf(key)>=0)&&(target[key]=source[key]);return target}var _excluded$2=["style","children","scrollTop","scrollLeft"],isCustomPropRE=/^--/;function dangerousStyleValue(name,value){return value==null||typeof value=="boolean"||value===""?"":typeof value=="number"&&value!==0&&!isCustomPropRE.test(name)&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])?value+"px":(""+value).trim()}var attributeCache={};function applyAnimatedValues(instance,props){if(!instance.nodeType||!instance.setAttribute)return!1;let isFilterElement=instance.nodeName==="filter"||instance.parentNode&&instance.parentNode.nodeName==="filter",_ref=props,{style,children,scrollTop,scrollLeft}=_ref,attributes=_objectWithoutPropertiesLoose2(_ref,_excluded$2),values=Object.values(attributes),names=Object.keys(attributes).map(name=>isFilterElement||instance.hasAttribute(name)?name:attributeCache[name]||(attributeCache[name]=name.replace(/([A-Z])/g,n=>"-"+n.toLowerCase())));children!==void 0&&(instance.textContent=children);for(let name in style)if(style.hasOwnProperty(name)){let value=dangerousStyleValue(name,style[name]);isCustomPropRE.test(name)?instance.style.setProperty(name,value):instance.style[name]=value}names.forEach((name,i)=>{instance.setAttribute(name,values[i])}),scrollTop!==void 0&&(instance.scrollTop=scrollTop),scrollLeft!==void 0&&(instance.scrollLeft=scrollLeft)}var isUnitlessNumber={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},prefixKey=(prefix2,key)=>prefix2+key.charAt(0).toUpperCase()+key.substring(1),prefixes=["Webkit","Ms","Moz","O"];isUnitlessNumber=Object.keys(isUnitlessNumber).reduce((acc,prop)=>(prefixes.forEach(prefix2=>acc[prefixKey(prefix2,prop)]=acc[prop]),acc),isUnitlessNumber);var _excluded$1=["x","y","z"],domTransforms=/^(matrix|translate|scale|rotate|skew)/,pxTransforms=/^(translate)/,degTransforms=/^(rotate|skew)/,addUnit=(value,unit)=>is.num(value)&&value!==0?value+unit:value,isValueIdentity=(value,id)=>is.arr(value)?value.every(v=>isValueIdentity(v,id)):is.num(value)?value===id:parseFloat(value)===id,AnimatedStyle=class extends AnimatedObject{constructor(_ref){let{x,y,z}=_ref,style=_objectWithoutPropertiesLoose2(_ref,_excluded$1),inputs=[],transforms=[];(x||y||z)&&(inputs.push([x||0,y||0,z||0]),transforms.push(xyz=>[`translate3d(${xyz.map(v=>addUnit(v,"px")).join(",")})`,isValueIdentity(xyz,0)])),eachProp(style,(value,key)=>{if(key==="transform")inputs.push([value||""]),transforms.push(transform=>[transform,transform===""]);else if(domTransforms.test(key)){if(delete style[key],is.und(value))return;let unit=pxTransforms.test(key)?"px":degTransforms.test(key)?"deg":"";inputs.push(toArray(value)),transforms.push(key==="rotate3d"?([x2,y2,z2,deg])=>[`rotate3d(${x2},${y2},${z2},${addUnit(deg,unit)})`,isValueIdentity(deg,0)]:input=>[`${key}(${input.map(v=>addUnit(v,unit)).join(",")})`,isValueIdentity(input,key.startsWith("scale")?1:0)])}}),inputs.length&&(style.transform=new FluidTransform(inputs,transforms)),super(style)}},FluidTransform=class extends FluidValue{constructor(inputs,transforms){super(),this._value=null,this.inputs=inputs,this.transforms=transforms}get(){return this._value||(this._value=this._get())}_get(){let transform="",identity=!0;return each(this.inputs,(input,i)=>{let arg1=getFluidValue(input[0]),[t,id]=this.transforms[i](is.arr(arg1)?arg1:input.map(getFluidValue));transform+=" "+t,identity=identity&&id}),identity?"none":transform}observerAdded(count){count==1&&each(this.inputs,input=>each(input,value=>hasFluidValue(value)&&addFluidObserver(value,this)))}observerRemoved(count){count==0&&each(this.inputs,input=>each(input,value=>hasFluidValue(value)&&removeFluidObserver(value,this)))}eventObserved(event){event.type=="change"&&(this._value=null),callFluidObservers(this,event)}},primitives=["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"],_excluded=["scrollTop","scrollLeft"];globals.assign({batchedUpdates:import_react_dom.unstable_batchedUpdates,createStringInterpolator,colors});var host=createHost(primitives,{applyAnimatedValues,createAnimatedStyle:style=>new AnimatedStyle(style),getComponentProps:_ref=>_objectWithoutPropertiesLoose2(_ref,_excluded)}),animated=host.animated;var React4=__toESM(require("react")),REDUCED_MOTION_QUERY="(prefers-reduced-motion: reduce)",isRenderingOnServer=(()=>typeof window>"u"||!window.location||!window.location.href||!window.matchMedia)(),getMediaQueryList=()=>isRenderingOnServer?{matches:!0,addListener:()=>{},removeListener:()=>{}}:window.matchMedia(REDUCED_MOTION_QUERY);function useReducedMotion(){let[prefersReducedMotion,setPrefersReducedMotion]=React4.useState(getMediaQueryList().matches);return React4.useEffect(()=>{let mediaQueryList=getMediaQueryList(),handleChange=()=>{setPrefersReducedMotion(mediaQueryList.matches)};return mediaQueryList.addListener(handleChange),()=>{mediaQueryList.removeListener(handleChange)}},[]),prefersReducedMotion}0&&(module.exports={Globals,animated,interpolate,isRenderingOnServer,useChain,useReducedMotion,useSpring,useSprings,useTrail,useTransition});
