"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../../../node_modules/deepmerge/dist/cjs.js"(exports, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module2.exports = deepmerge_1;
  }
});

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  BOX_PROPS_TO_BLOCK: () => BOX_PROPS_TO_BLOCK,
  Box: () => Box,
  StyledBox: () => StyledBox,
  getCustomElementStyles: () => getCustomElementStyles,
  safelySpreadBoxProps: () => safelySpreadBoxProps
});
module.exports = __toCommonJS(src_exports);
var React = __toESM(require("react"));
var import_styling_library2 = require("@twilio-paste/styling-library");
var import_style_props2 = require("@twilio-paste/style-props");

// src/StyleFunctions.ts
var import_styling_library = require("@twilio-paste/styling-library");
var import_deepmerge = __toESM(require_cjs());

// src/PseudoPropStyles.ts
var PseudoPropStyles = {
  _hover: "&:hover",
  _active: "&:active, &[data-active=true]",
  _focus: "&:focus",
  _focus_hover: "&:focus:hover",
  _focus_placeholder: "&:focus::placeholder",
  _visited: "&:visited",
  _even: "&:nth-of-type(even)",
  _odd: "&:nth-of-type(odd)",
  _disabled: "&:disabled, &:disabled:focus, &:disabled:hover, &[aria-disabled=true], &[aria-disabled=true]:focus, &[aria-disabled=true]:hover",
  _checked: "&:checked, &[aria-checked=true]",
  _checked_hover: "&:checked:hover, &[aria-checked=true]:hover",
  _mixed: "&:indeterminate, &[aria-checked=mixed]",
  _selected: "&[aria-selected=true]",
  _selected_hover: "&[aria-selected=true]:hover",
  _selected_focus: "&[aria-selected=true]:focus",
  _selected_focusVisible: "&[aria-selected=true]:focus-visible",
  _invalid: "&:invalid, &[aria-invalid=true]",
  _pressed: "&[aria-pressed=true]",
  _pressed_focus: "&[aria-pressed=true]:focus",
  _pressed_hover: "&[aria-pressed=true]:hover",
  _readOnly: "&[aria-readonly=true], &[readonly]",
  _first: "&:first-of-type",
  _last: "&:last-of-type",
  _expanded: "&[aria-expanded=true]",
  _grabbed: "&[aria-grabbed=true]",
  _notFirst: "&:not(:first-of-type)",
  _notLast: "&:not(:last-of-type)",
  _groupHover: "[role=group]:hover &",
  _before: "&:before",
  _after: "&:after",
  _focusWithin: "&:focus-within",
  _focusVisible: "&:focus-visible",
  _placeholder: "&::placeholder",
  __moz_focus_inner: "&::-moz-focus-inner",
  __webkit_datetime_edit: "&::-webkit-datetime-edit",
  __webkit_calendar_picker_indicator_hover: "&::-webkit-calendar-picker-indicator:hover"
};

// src/CustomStyleProps.ts
var customStyleProps = {
  color: {
    property: "color",
    scale: "textColors"
  },
  backgroundColor: {
    property: "backgroundColor",
    scale: "backgroundColors"
  },
  borderColor: {
    property: "borderColor",
    scale: "borderColors"
  },
  borderBottomColor: {
    property: "borderBottomColor",
    scale: "borderColors"
  },
  borderLeftColor: {
    property: "borderLeftColor",
    scale: "borderColors"
  },
  borderRightColor: {
    property: "borderRightColor",
    scale: "borderColors"
  },
  borderTopColor: {
    property: "borderTopColor",
    scale: "borderColors"
  },
  content: true,
  cursor: true,
  appearance: true,
  transition: true,
  transform: true,
  animation: true,
  transformOrigin: true,
  visibility: true,
  userSelect: true,
  pointerEvents: true,
  boxSizing: true,
  resize: true,
  listStyleType: true,
  listStylePosition: true,
  listStyleImage: true,
  objectFit: true,
  objectPosition: true,
  outline: true,
  float: true,
  willChange: true,
  clip: true,
  backgroundAttachment: true,
  textAlign: true,
  textTransform: true,
  textDecoration: true,
  textOverflow: true,
  whiteSpace: true,
  wordBreak: true,
  wordWrap: true,
  overflowWrap: true,
  opacity: true,
  borderCollapse: true,
  borderSpacing: true,
  tableLayout: true,
  fontVariantNumeric: true,
  inset: true,
  columnGap: {
    property: "columnGap",
    scale: "space"
  },
  rowGap: {
    property: "rowGap",
    scale: "space"
  }
};

// src/StyleFunctions.ts
var PasteStyleProps = (0, import_styling_library.system)(customStyleProps);
var getPseudoStyles = (props) => {
  const pseudoProps = Object.keys(props).filter((propName) => propName.startsWith("_"));
  if (pseudoProps.length === 0) {
    return {};
  }
  const pseudoStyles = {};
  pseudoProps.forEach((pseudoProp) => {
    if (PseudoPropStyles[pseudoProp] != null) {
      pseudoStyles[PseudoPropStyles[pseudoProp]] = props[pseudoProp];
    }
  });
  return (0, import_styling_library.css)(pseudoStyles);
};
var getCustomElementStyles = (props) => {
  if (props != null && props.theme != null && props.theme.elements != null) {
    const themeElements = props.theme.elements;
    const targetElement = props["data-paste-element"];
    if (themeElements[targetElement] != null) {
      const elementOverrides = themeElements[targetElement];
      const computedStyles = (0, import_styling_library.css)(elementOverrides)(props);
      const _a = computedStyles, { variants } = _a, elementStyles = __objRest(_a, ["variants"]);
      let variantStyles = {};
      if (props.variant != null && variants != null && variants[props.variant] != null) {
        variantStyles = variants[props.variant];
      }
      return () => (0, import_deepmerge.default)(elementStyles, variantStyles);
    }
  }
  return {};
};

// src/SafelySpreadProps.ts
var import_style_props = require("@twilio-paste/style-props");
var BOX_PROPS_TO_BLOCK = [
  ...import_style_props.LAYOUT_PROPS,
  ...import_style_props.SPACE_PROPS,
  ...import_style_props.BACKGROUND_PROPS,
  ...import_style_props.BORDER_PROPS,
  ...import_style_props.SHADOW_PROPS,
  ...import_style_props.POSITION_PROPS,
  ...import_style_props.FLEXBOX_PROPS,
  ...import_style_props.GRID_PROPS,
  ...import_style_props.TYPOGRAPHY_PROPS,
  ...Object.keys(PseudoPropStyles),
  "className",
  "style"
];
var safelySpreadBoxProps = (props) => {
  return Object.keys(props).reduce((newProps, key) => {
    if (!BOX_PROPS_TO_BLOCK.includes(key)) {
      newProps[key] = props[key];
    }
    return newProps;
  }, {});
};

// src/index.tsx
var stylingPropsWithoutSize = import_styling_library2.props.filter((item) => item !== "size");
var shouldForwardProp = (0, import_styling_library2.createShouldForwardProp)([
  ...stylingPropsWithoutSize,
  ...Object.keys(__spreadValues(__spreadValues({}, customStyleProps), PseudoPropStyles))
]);
var StyledBox = (0, import_styling_library2.styled)("div", { shouldForwardProp })(
  {
    boxSizing: "border-box"
  },
  (0, import_styling_library2.compose)(import_styling_library2.space, import_styling_library2.layout, import_styling_library2.flexbox, import_styling_library2.grid, import_styling_library2.background, import_styling_library2.border, import_styling_library2.boxShadow, import_styling_library2.position, import_styling_library2.typography, PasteStyleProps),
  getPseudoStyles,
  getCustomElementStyles
);
var Box = React.forwardRef((_a, ref) => {
  var _b = _a, { children, element = "BOX" } = _b, props = __objRest(_b, ["children", "element"]);
  return /* @__PURE__ */ React.createElement(StyledBox, __spreadValues({ "data-paste-element": element, ref }, props), children);
});
Box.displayName = "Box";
Box.propTypes = {
  backgroundColor: import_style_props2.isDeprecatedBackgroundColorTokenProp,
  borderColor: import_style_props2.isDeprecatedBorderColorTokenProp,
  boxShadow: import_style_props2.isDeprecatedBoxShadowTokenProp,
  color: import_style_props2.isDeprecatedTextColorTokenProp
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BOX_PROPS_TO_BLOCK,
  Box,
  StyledBox,
  getCustomElementStyles,
  safelySpreadBoxProps
});
