var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/Callout.tsx
import * as React from "react";
import PropTypes from "prop-types";
import { Box, safelySpreadBoxProps } from "@twilio-paste/box";
import { ErrorIcon } from "@twilio-paste/icons/esm/ErrorIcon";
import { NeutralIcon } from "@twilio-paste/icons/esm/NeutralIcon";
import { NewIcon } from "@twilio-paste/icons/esm/NewIcon";
import { ScreenReaderOnly } from "@twilio-paste/screen-reader-only";
import { SuccessIcon } from "@twilio-paste/icons/esm/SuccessIcon";
import { WarningIcon } from "@twilio-paste/icons/esm/WarningIcon";
import { isMarginTokenProp } from "@twilio-paste/style-props";
var variantStyles = {
  success: {
    backgroundColor: "colorBackgroundSuccessWeakest",
    color: "colorTextSuccess"
  },
  error: {
    backgroundColor: "colorBackgroundErrorWeakest",
    color: "colorTextErrorStrong"
  },
  warning: {
    backgroundColor: "colorBackgroundWarningWeakest",
    color: "colorTextWarningStrong"
  },
  new: {
    backgroundColor: "colorBackgroundNew",
    color: "colorTextNew"
  },
  neutral: {
    backgroundColor: "colorBackgroundNeutralWeakest",
    color: "colorTextNeutral"
  }
};
var variantIcons = {
  success: SuccessIcon,
  error: ErrorIcon,
  warning: WarningIcon,
  new: NewIcon,
  neutral: NeutralIcon
};
var defaultIconLabels = {
  success: "(success)",
  error: "(error)",
  warning: "(warning)",
  new: "(new)",
  neutral: "(information)"
};
var Callout = React.forwardRef(
  (_a, ref) => {
    var _b = _a, { children, variant, element = "CALLOUT", i18nLabel, marginY } = _b, props = __objRest(_b, ["children", "variant", "element", "i18nLabel", "marginY"]);
    const IconComponent = variantIcons[variant];
    const iconLabel = i18nLabel ? i18nLabel : defaultIconLabels[variant];
    return /* @__PURE__ */ React.createElement(
      Box,
      __spreadValues(__spreadProps(__spreadValues({}, safelySpreadBoxProps(props)), {
        ref,
        element,
        display: "flex",
        marginY,
        padding: "space70",
        borderRadius: "borderRadius20",
        variant
      }), variantStyles[variant]),
      /* @__PURE__ */ React.createElement(Box, { marginRight: "space40", paddingTop: "space10", element: `${element}_ICON` }, /* @__PURE__ */ React.createElement(IconComponent, { decorative: true }), /* @__PURE__ */ React.createElement(ScreenReaderOnly, null, iconLabel)),
      /* @__PURE__ */ React.createElement(Box, { display: "flex", flexDirection: "column", rowGap: "space30", flex: "1" }, children)
    );
  }
);
Callout.displayName = "Callout";
Callout.propTypes = {
  children: PropTypes.node,
  element: PropTypes.string,
  variant: PropTypes.oneOf(["neutral", "warning", "error", "success", "new", "default"]).isRequired,
  i18nLabel: PropTypes.string,
  marginY: isMarginTokenProp
};

// src/CalloutHeading.tsx
import * as React3 from "react";
import PropTypes2 from "prop-types";

// ../../primitives/text/dist/index.es.js
import * as React2 from "react";
import { boxShadow, compose, display, overflow, position, space, styled, typography, verticalAlign, createShouldForwardProp, props as stylingProps } from "@twilio-paste/styling-library";
import { isDeprecatedBoxShadowTokenProp, isDeprecatedTextColorTokenProp } from "@twilio-paste/style-props";
import { css, system } from "@twilio-paste/styling-library";
import { SHADOW_PROPS, SPACE_PROPS, TYPOGRAPHY_PROPS, OVERFLOW_PROPS } from "@twilio-paste/style-props";
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp2.call(b, prop) && __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b))
      __propIsEnum2.call(b, prop) && __defNormalProp2(a, prop, b[prop]);
  return a;
};
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source))
      exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp2.call(to, key) && key !== except && __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
var require_cjs = __commonJS({ "../../../../node_modules/deepmerge/dist/cjs.js"(exports, module) {
  "use strict";
  var isMergeableObject = function(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value == "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge)
      return deepmerge;
    var customMerge = options.customMerge(key);
    return typeof customMerge == "function" ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return target.propertyIsEnumerable(symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    return options.isMergeableObject(target) && getKeys(target).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    }), getKeys(source).forEach(function(key) {
      propertyIsUnsafe(target, key) || (propertyIsOnObject(target, key) && options.isMergeableObject(source[key]) ? destination[key] = getMergeFunction(key, options)(target[key], source[key], options) : destination[key] = cloneUnlessOtherwiseSpecified(source[key], options));
    }), destination;
  }
  function deepmerge(target, source, options) {
    options = options || {}, options.arrayMerge = options.arrayMerge || defaultArrayMerge, options.isMergeableObject = options.isMergeableObject || isMergeableObject, options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source), targetIsArray = Array.isArray(target), sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    return sourceAndTargetTypesMatch ? sourceIsArray ? options.arrayMerge(target, source, options) : mergeObject(target, source, options) : cloneUnlessOtherwiseSpecified(source, options);
  }
  deepmerge.all = function(array, options) {
    if (!Array.isArray(array))
      throw new Error("first argument should be an array");
    return array.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  module.exports = deepmerge_1;
} });
var import_deepmerge = __toESM(require_cjs());
var PseudoPropStyles = { _hover: "&:hover", _active: "&:active, &[data-active=true]", _focus: "&:focus", _visited: "&:visited", _even: "&:nth-of-type(even)", _odd: "&:nth-of-type(odd)", _disabled: "&:disabled, &:disabled:focus, &:disabled:hover, &[aria-disabled=true], &[aria-disabled=true]:focus, &[aria-disabled=true]:hover", _checked: "&:checked, &[aria-checked=true]", _mixed: "&:indeterminate, &[aria-checked=mixed]", _selected: "&[aria-selected=true]", _selected_hover: "&[aria-selected=true]:hover", _selected_focus: "&[aria-selected=true]:focus", _selected_focusVisible: "&[aria-selected=true]:focus-visible", _invalid: "&:invalid, &[aria-invalid=true]", _pressed: "&[aria-pressed=true]", _readOnly: "&[aria-readonly=true], &[readonly]", _first: "&:first-of-type", _last: "&:last-of-type", _expanded: "&[aria-expanded=true]", _grabbed: "&[aria-grabbed=true]", _notFirst: "&:not(:first-of-type)", _notLast: "&:not(:last-of-type)", _before: "&:before", _after: "&:after", _focusWithin: "&:focus-within" };
var customStyleProps = { color: { property: "color", scale: "textColors" }, cursor: true, outline: true, transition: true, textDecoration: true, textTransform: true, whiteSpace: true, wordBreak: true, wordWrap: true, fontVariantNumeric: true };
var PasteStyleProps = system(customStyleProps);
var getPseudoStyles = (props) => {
  let pseudoProps = Object.keys(props).filter((propName) => propName.startsWith("_"));
  if (pseudoProps.length === 0)
    return {};
  let pseudoStyles = {};
  return pseudoProps.forEach((pseudoProp) => {
    PseudoPropStyles[pseudoProp] != null && (pseudoStyles[PseudoPropStyles[pseudoProp]] = props[pseudoProp]);
  }), css(pseudoStyles);
};
var getCustomElementStyles = (props) => {
  if (props != null && props.theme != null && props.theme.elements != null) {
    let themeElements = props.theme.elements, targetElement = props["data-paste-element"];
    if (themeElements[targetElement] != null) {
      let elementOverrides = themeElements[targetElement], _a = css(elementOverrides)(props), { variants } = _a, elementStyles = __objRest2(_a, ["variants"]), variantStyles2 = {};
      return props.variant != null && variants != null && variants[props.variant] != null && (variantStyles2 = variants[props.variant]), () => (0, import_deepmerge.default)(elementStyles, variantStyles2);
    }
  }
  return {};
};
var TEXT_PROPS_TO_BLOCK = [...SHADOW_PROPS, ...SPACE_PROPS, ...TYPOGRAPHY_PROPS, ...OVERFLOW_PROPS, ...Object.keys(PseudoPropStyles), "display", "verticalAlign", "className", "style"];
var safelySpreadTextProps = (props) => Object.keys(props).reduce((newProps, key) => (TEXT_PROPS_TO_BLOCK.includes(key) || (newProps[key] = props[key]), newProps), {});
var shouldForwardProp = createShouldForwardProp([...stylingProps, ...Object.keys(__spreadValues2(__spreadValues2({}, customStyleProps), PseudoPropStyles))]);
var StyledText = styled("div", { shouldForwardProp })({ margin: 0, padding: 0 }, compose(boxShadow, display, overflow, position, space, typography, verticalAlign, PasteStyleProps), getPseudoStyles, getCustomElementStyles);
var Text = React2.forwardRef((_a, ref) => {
  var _b = _a, { children, color = "colorText", fontSize = "fontSize30", lineHeight = "lineHeight30", element = "TEXT" } = _b, props = __objRest2(_b, ["children", "color", "fontSize", "lineHeight", "element"]);
  return React2.createElement(StyledText, __spreadValues2({ "data-paste-element": element, ref, color, fontSize, lineHeight }, props), children);
});
Text.displayName = "Text";
Text.propTypes = { boxShadow: isDeprecatedBoxShadowTokenProp, color: isDeprecatedTextColorTokenProp };

// src/CalloutHeading.tsx
var CalloutHeading = React3.forwardRef(
  (_a, ref) => {
    var _b = _a, { element = "CALLOUT_HEADING", children, as = "h3" } = _b, props = __objRest(_b, ["element", "children", "as"]);
    return /* @__PURE__ */ React3.createElement(
      Text,
      __spreadProps(__spreadValues({}, safelySpreadTextProps(props)), {
        as,
        ref,
        element,
        color: "currentColor",
        lineHeight: "lineHeight40"
      }),
      children
    );
  }
);
CalloutHeading.displayName = "CalloutHeading";
CalloutHeading.propTypes = {
  children: PropTypes2.node,
  element: PropTypes2.string,
  as: PropTypes2.oneOf(["h1", "h2", "h3", "h4", "h5", "h6", "div", "label", "span", "header"]).isRequired
};

// src/CalloutList.tsx
import * as React4 from "react";
import PropTypes3 from "prop-types";
import { Box as Box2, safelySpreadBoxProps as safelySpreadBoxProps2 } from "@twilio-paste/box";
var CalloutList = React4.forwardRef(
  (_a, ref) => {
    var _b = _a, { element = "CALLOUT_LIST", children, as } = _b, props = __objRest(_b, ["element", "children", "as"]);
    return /* @__PURE__ */ React4.createElement(
      Box2,
      __spreadProps(__spreadValues({}, safelySpreadBoxProps2(props)), {
        element,
        ref,
        as,
        margin: "space0",
        display: "flex",
        flexDirection: "column",
        rowGap: "space30",
        paddingLeft: "space60"
      }),
      children
    );
  }
);
CalloutList.displayName = "CalloutList";
CalloutList.propTypes = {
  children: PropTypes3.node,
  element: PropTypes3.string,
  as: PropTypes3.oneOf(["ul", "ol"]).isRequired
};
var CalloutListItem = React4.forwardRef(
  (_a, ref) => {
    var _b = _a, { element = "CALLOUT_LIST_ITEM", children } = _b, props = __objRest(_b, ["element", "children"]);
    return /* @__PURE__ */ React4.createElement(Text, __spreadProps(__spreadValues({}, safelySpreadTextProps(props)), { element, ref, as: "li", color: "currentColor" }), children);
  }
);
CalloutListItem.displayName = "CalloutListItem";
CalloutListItem.propTypes = {
  children: PropTypes3.node,
  element: PropTypes3.string
};

// src/CalloutText.tsx
import * as React5 from "react";
import PropTypes4 from "prop-types";
var CalloutText = React5.forwardRef(
  (_a, ref) => {
    var _b = _a, { element = "CALLOUT_TEXT", children } = _b, props = __objRest(_b, ["element", "children"]);
    return /* @__PURE__ */ React5.createElement(
      Text,
      __spreadProps(__spreadValues({}, safelySpreadTextProps(props)), {
        as: "p",
        ref,
        element,
        color: "currentColor",
        lineHeight: "lineHeight40"
      }),
      children
    );
  }
);
CalloutText.displayName = "CalloutText";
CalloutText.propTypes = {
  children: PropTypes4.node,
  element: PropTypes4.string
};
export {
  Callout,
  CalloutHeading,
  CalloutList,
  CalloutListItem,
  CalloutText
};
