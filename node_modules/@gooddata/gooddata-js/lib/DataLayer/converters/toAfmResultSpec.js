"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2020 GoodData Corporation
var compact_1 = __importDefault(require("lodash/compact"));
var flatMap_1 = __importDefault(require("lodash/flatMap"));
var get_1 = __importDefault(require("lodash/get"));
var typings_1 = require("@gooddata/typings");
var FilterConverter_1 = require("./FilterConverter");
var MeasureConverter_1 = __importDefault(require("./MeasureConverter"));
var buckets_1 = require("../../DataLayer/constants/buckets");
function convertAttribute(attribute, idx) {
    var alias = attribute.visualizationAttribute.alias;
    var aliasProp = alias ? { alias: alias } : {};
    return __assign({ displayForm: attribute.visualizationAttribute.displayForm, localIdentifier: attribute.visualizationAttribute.localIdentifier || "a" + (idx + 1) }, aliasProp);
}
function convertAFM(visualizationObject) {
    var textualAttributes = getAttributes(visualizationObject.buckets).map(convertAttribute);
    var geoAttribute = getGeoAttributeForTooltip(visualizationObject);
    var attributes = geoAttribute ? textualAttributes.concat([geoAttribute]) : textualAttributes;
    var attrProp = attributes.length ? { attributes: attributes } : {};
    var measures = getMeasures(visualizationObject.buckets).map(MeasureConverter_1.default.convertMeasure);
    var measuresProp = measures.length ? { measures: measures } : {};
    var filters = visualizationObject.filters
        ? compact_1.default(visualizationObject.filters.map(FilterConverter_1.convertVisualizationObjectExtendedFilter))
        : [];
    var filtersProp = filters.length ? { filters: filters } : {};
    var nativeTotals = convertNativeTotals(visualizationObject);
    var nativeTotalsProp = nativeTotals.length ? { nativeTotals: nativeTotals } : {};
    return __assign({}, measuresProp, attrProp, filtersProp, nativeTotalsProp);
}
function getMeasures(buckets) {
    return buckets.reduce(function (result, bucket) {
        var measureItems = bucket.items.filter(typings_1.VisualizationObject.isMeasure);
        return result.concat(measureItems);
    }, []);
}
function getNativeTotalAttributeIdentifiers(bucket, total) {
    var attributes = bucket.items.filter(typings_1.VisualizationObject.isAttribute);
    var totalAttributeIndex = attributes.findIndex(function (attribute) { return attribute.visualizationAttribute.localIdentifier === total.attributeIdentifier; });
    return attributes
        .slice(0, totalAttributeIndex)
        .map(function (attribute) { return attribute.visualizationAttribute.localIdentifier; });
}
function convertNativeTotals(visObj) {
    var nativeTotalsPerBucket = visObj.buckets.map(function (bucket) {
        var totals = bucket.totals || [];
        var nativeTotals = totals.filter(function (total) { return total.type === "nat"; });
        return nativeTotals.map(function (total) { return ({
            measureIdentifier: total.measureIdentifier,
            attributeIdentifiers: getNativeTotalAttributeIdentifiers(bucket, total),
        }); });
    });
    return flatMap_1.default(nativeTotalsPerBucket);
}
function getAttributes(buckets) {
    return buckets.reduce(function (result, bucket) {
        var items = bucket.items.filter(typings_1.VisualizationObject.isAttribute);
        return result.concat(items);
    }, []);
}
function parsePropertyItem(item) {
    try {
        return JSON.parse(item);
    }
    catch (e) {
        return {};
    }
}
function buildTooltipBucketItem(tooltipText, alias) {
    var tooltipAlias = alias ? { alias: alias } : {};
    return __assign({ localIdentifier: buckets_1.TOOLTIP_TEXT, displayForm: {
            uri: tooltipText,
        } }, tooltipAlias);
}
function getGeoAttributeForTooltip(visualizationObject) {
    var properties = parsePropertyItem(visualizationObject.properties || "");
    var tooltipText = get_1.default(properties, "controls.tooltipText", "");
    if (tooltipText) {
        // copy alias of Geo attribute to alias of tooltipText attribute
        var locationAlias = visualizationObject.buckets.reduce(function (locationAlias, bucket) {
            if (!locationAlias && bucket.localIdentifier === buckets_1.LOCATION) {
                return get_1.default(bucket, "items[0].visualizationAttribute.alias");
            }
            return locationAlias;
        }, "");
        return buildTooltipBucketItem(tooltipText, locationAlias);
    }
    return null;
}
function convertSorting(visObj) {
    if (visObj.properties) {
        var properties = {};
        try {
            properties = JSON.parse(visObj.properties);
        }
        catch (_a) {
            // tslint:disable-next-line:no-console
            console.error("Properties contains invalid JSON string.");
        }
        var sorts = get_1.default(properties, "sortItems", []);
        return sorts ? sorts : [];
    }
    return [];
}
function convertResultSpec(visObj) {
    var sorts = convertSorting(visObj);
    // Workaround because we can handle only 1 sort item for now
    var sortsProp = sorts.length ? { sorts: sorts.slice(0, 1) } : {};
    return __assign({}, sortsProp);
}
/**
 * Converts visualizationObject to afm and resultSpec
 *
 * @method toAfmResultSpec
 * @param {VisualizationObject.IVisualizationObjectContent} visObj
 * @returns {IConvertedAFM}
 */
function toAfmResultSpec(visObj) {
    var afm = convertAFM(visObj);
    return {
        afm: afm,
        resultSpec: convertResultSpec(visObj),
    };
}
exports.toAfmResultSpec = toAfmResultSpec;
