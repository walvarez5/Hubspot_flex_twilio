import { AFM } from "@gooddata/typings";
export declare const ALL_TIME_GRANULARITY = "ALL_TIME_GRANULARITY";
export interface INormalizedAFM {
    attributes: AFM.IAttribute[];
    measures: AFM.IMeasure[];
    filters: AFM.CompatibilityFilter[];
    nativeTotals: AFM.INativeTotalItem[];
}
/**
 * Unwraps measure object
 *
 * @method unwrapSimpleMeasure
 * @param {AFM.IMeasure} item
 * @returns {AFM.ISimpleMeasure}
 */
export declare function unwrapSimpleMeasure(item: AFM.IMeasure): AFM.ISimpleMeasure;
/**
 * Unwraps popMeasure object
 *
 * @method unwrapPoPMeasure
 * @param {AFM.IMeasure} item
 * @returns {AFM.IPopMeasure}
 */
export declare function unwrapPoPMeasure(item: AFM.IMeasure): AFM.IPopMeasure;
/**
 * Unwraps previousPeriodMeasure object
 *
 * @method unwrapPreviousPeriodMeasure
 * @param {AFM.IMeasure} item
 * @returns {AFM.IPreviousPeriodMeasure}
 */
export declare function unwrapPreviousPeriodMeasure(item: AFM.IMeasure): AFM.IPreviousPeriodMeasure;
/**
 * Unwraps arithmeticMeasure object
 *
 * @method unwrapArithmeticMeasure
 * @param {AFM.IMeasure} item
 * @returns {AFM.IArithmeticMeasure}
 */
export declare function unwrapArithmeticMeasure(item: AFM.IMeasure): AFM.IArithmeticMeasure;
/**
 * Normalize AFM
 *
 * @method normalizeAfm
 * @param {AFM.IAfm} afm
 * @returns {INormalizedAFM}
 */
export declare function normalizeAfm(afm: AFM.IAfm): INormalizedAFM;
/**
 * Returns true if measure is a simple measure
 *
 * @method isSimpleMeasure
 * @param {AFM.IMeasure} item
 * @returns {boolean}
 */
export declare function isSimpleMeasure(item: AFM.IMeasure): boolean;
/**
 * Returns true if measure is PeriodOverPeriod
 *
 * @method isPoP
 * @param {AFM.IMeasure} item
 * @returns {boolean}
 */
export declare function isPoP(item: AFM.IMeasure): boolean;
/**
 * Returns true if measure is previous period measure
 *
 * @method isPreviousPeriodMeasure
 * @param {AFM.IMeasure} item
 * @returns {boolean}
 */
export declare function isPreviousPeriodMeasure(item: AFM.IMeasure): boolean;
/**
 * Returns true if measure is arithmetic measure
 *
 * @method isArithmeticMeasure
 * @param {AFM.IMeasure} item
 * @returns {boolean}
 */
export declare function isArithmeticMeasure(item: AFM.IMeasure): boolean;
/**
 * Returns true if filter is attributeFilter
 *
 * @method isAttributeFilter
 * @param {AFM.FilterItem} filter
 * @returns {boolean}
 * @deprecated use AFM.isAttributeFilter instead
 */
export declare function isAttributeFilter(filter: AFM.FilterItem): filter is AFM.AttributeFilterItem;
/**
 * Returns true if filter is dateFilter
 *
 * @method isDateFilter
 * @param {AFM.CompatibilityFilter} filter
 * @returns {boolean}
 * @deprecated use AFM.isDateFilter instead
 */
export declare function isDateFilter(filter: AFM.CompatibilityFilter): filter is AFM.DateFilterItem;
/**
 * Returns true if filter is negative attribute filter and has no selected elements,
 * meaning that this is "Select all"
 *
 * @method isAttributeFilterSelectAll
 * @param {AFM.FilterItem} filter
 * @returns {boolean}
 */
export declare function isAttributeFilterSelectAll(filter: AFM.FilterItem): boolean;
/**
 * Returns true if measure has dateFilters
 *
 * @method hasMetricDateFilters
 * @param {INormalizedAFM} normalizedAfm
 * @returns {boolean}
 */
export declare function hasMetricDateFilters(normalizedAfm: INormalizedAFM): boolean;
/**
 * Returns global date filters
 *
 * @method getGlobalDateFilters
 * @param {INormalizedAFM} normalizedAfm
 * @returns {AFM.DateFilterItem[]}
 */
export declare function getGlobalDateFilters(normalizedAfm: INormalizedAFM): AFM.DateFilterItem[];
/**
 * Returns true if measure has filters
 *
 * @method hasFilters
 * @param {AFM.ISimpleMeasure} measure
 * @returns {boolean}
 */
export declare const hasFilters: (measure: AFM.ISimpleMeasure) => boolean;
/**
 * Return date filters from AFM
 *
 * @method getMeasureDateFilters
 * @param {AFM.IAfm} normalizedAfm
 * @returns {AFM.DateFilterItem[]}
 */
export declare function getMeasureDateFilters(normalizedAfm: AFM.IAfm): AFM.DateFilterItem[];
/**
 * Return true if AFM has global date filter
 *
 * @method hasGlobalDateFilter
 * @param {INormalizedAFM} afm
 * @returns {boolean}
 */
export declare function hasGlobalDateFilter(afm: INormalizedAFM): boolean;
/**
 * Return uri or identifier from ObjQualifier
 *
 * @method getId
 * @param {AFM.ObjQualifier} obj
 * @returns {string|null}
 */
export declare function getId(obj: AFM.ObjQualifier): string | null;
/**
 * Returns date filter date dataset
 *
 * @method getDateFilterDateDataSet
 * @param {AFM.DateFilterItem} filter
 * @returns {AFM.ObjQualifier | null }
 */
export declare function getDateFilterDateDataSet(filter: AFM.DateFilterItem): AFM.ObjQualifier;
/**
 * Returns true if dateFilters dataSets match
 *
 * @method dateFiltersDataSetsMatch
 * @param {AFM.DateFilterItem} f1
 * @param {AFM.DateFilterItem} f2
 * @returns {AFM.ObjQualifier | null | boolean}
 */
export declare function dateFiltersDataSetsMatch(f1: AFM.DateFilterItem, f2: AFM.DateFilterItem): boolean;
/**
 * Append attribute filters and date filter to afm
 *
 * Date filter handling:
 *      - Override if date filter has the same id
 *      - Add if date filter if date filter id is different
 *
 * Attribute filter handling:
 *      - Add all
 *
 * @method appendFilters
 * @param {AFM.IAfm} afm
 * @param {AFM.AttributeFilterItem[]} attributeFilters
 * @param {AFM.DateFilterItem} dateFilter
 * @param {AFM.IMeasureValueFilter[]} measureValueFilters
 * @return {AFM.IAfm}
 */
export declare function appendFilters(afm: AFM.IAfm, attributeFilters: AFM.AttributeFilterItem[], dateFilter?: AFM.DateFilterItem, measureValueFilters?: AFM.IMeasureValueFilter[]): AFM.IAfm;
/**
 * Returns true if AFM is executable
 *
 * @method isAfmExecutable
 * @param {AFM.IAfm} afm
 * @returns {boolean}
 */
export declare function isAfmExecutable(afm: AFM.IAfm): boolean;
