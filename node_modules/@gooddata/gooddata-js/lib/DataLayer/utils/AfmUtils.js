"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2018 GoodData Corporation
var flatMap_1 = __importDefault(require("lodash/flatMap"));
var compact_1 = __importDefault(require("lodash/compact"));
var typings_1 = require("@gooddata/typings");
exports.ALL_TIME_GRANULARITY = "ALL_TIME_GRANULARITY";
/**
 * Unwraps measure object
 *
 * @method unwrapSimpleMeasure
 * @param {AFM.IMeasure} item
 * @returns {AFM.ISimpleMeasure}
 */
function unwrapSimpleMeasure(item) {
    return item.definition.measure;
}
exports.unwrapSimpleMeasure = unwrapSimpleMeasure;
/**
 * Unwraps popMeasure object
 *
 * @method unwrapPoPMeasure
 * @param {AFM.IMeasure} item
 * @returns {AFM.IPopMeasure}
 */
function unwrapPoPMeasure(item) {
    return item.definition.popMeasure;
}
exports.unwrapPoPMeasure = unwrapPoPMeasure;
/**
 * Unwraps previousPeriodMeasure object
 *
 * @method unwrapPreviousPeriodMeasure
 * @param {AFM.IMeasure} item
 * @returns {AFM.IPreviousPeriodMeasure}
 */
function unwrapPreviousPeriodMeasure(item) {
    return item.definition.previousPeriodMeasure;
}
exports.unwrapPreviousPeriodMeasure = unwrapPreviousPeriodMeasure;
/**
 * Unwraps arithmeticMeasure object
 *
 * @method unwrapArithmeticMeasure
 * @param {AFM.IMeasure} item
 * @returns {AFM.IArithmeticMeasure}
 */
function unwrapArithmeticMeasure(item) {
    return item.definition.arithmeticMeasure;
}
exports.unwrapArithmeticMeasure = unwrapArithmeticMeasure;
/**
 * Normalize AFM
 *
 * @method normalizeAfm
 * @param {AFM.IAfm} afm
 * @returns {INormalizedAFM}
 */
function normalizeAfm(afm) {
    return {
        attributes: afm.attributes || [],
        measures: afm.measures || [],
        filters: afm.filters || [],
        nativeTotals: afm.nativeTotals || [],
    };
}
exports.normalizeAfm = normalizeAfm;
/**
 * Returns true if measure is a simple measure
 *
 * @method isSimpleMeasure
 * @param {AFM.IMeasure} item
 * @returns {boolean}
 */
function isSimpleMeasure(item) {
    return !!unwrapSimpleMeasure(item);
}
exports.isSimpleMeasure = isSimpleMeasure;
/**
 * Returns true if measure is PeriodOverPeriod
 *
 * @method isPoP
 * @param {AFM.IMeasure} item
 * @returns {boolean}
 */
function isPoP(item) {
    return !!unwrapPoPMeasure(item);
}
exports.isPoP = isPoP;
/**
 * Returns true if measure is previous period measure
 *
 * @method isPreviousPeriodMeasure
 * @param {AFM.IMeasure} item
 * @returns {boolean}
 */
function isPreviousPeriodMeasure(item) {
    return !!unwrapPreviousPeriodMeasure(item);
}
exports.isPreviousPeriodMeasure = isPreviousPeriodMeasure;
/**
 * Returns true if measure is arithmetic measure
 *
 * @method isArithmeticMeasure
 * @param {AFM.IMeasure} item
 * @returns {boolean}
 */
function isArithmeticMeasure(item) {
    return !!unwrapArithmeticMeasure(item);
}
exports.isArithmeticMeasure = isArithmeticMeasure;
/**
 * Returns true if filter is attributeFilter
 *
 * @method isAttributeFilter
 * @param {AFM.FilterItem} filter
 * @returns {boolean}
 * @deprecated use AFM.isAttributeFilter instead
 */
function isAttributeFilter(filter) {
    return typings_1.AFM.isAttributeFilter(filter);
}
exports.isAttributeFilter = isAttributeFilter;
/**
 * Returns true if filter is dateFilter
 *
 * @method isDateFilter
 * @param {AFM.CompatibilityFilter} filter
 * @returns {boolean}
 * @deprecated use AFM.isDateFilter instead
 */
function isDateFilter(filter) {
    return typings_1.AFM.isDateFilter(filter);
}
exports.isDateFilter = isDateFilter;
/**
 * Returns true if filter is negative attribute filter and has no selected elements,
 * meaning that this is "Select all"
 *
 * @method isAttributeFilterSelectAll
 * @param {AFM.FilterItem} filter
 * @returns {boolean}
 */
function isAttributeFilterSelectAll(filter) {
    if (typings_1.AFM.isNegativeAttributeFilter(filter)) {
        return filter.negativeAttributeFilter.notIn.length === 0;
    }
    return false;
}
exports.isAttributeFilterSelectAll = isAttributeFilterSelectAll;
/**
 * Returns true if measure has dateFilters
 *
 * @method hasMetricDateFilters
 * @param {INormalizedAFM} normalizedAfm
 * @returns {boolean}
 */
function hasMetricDateFilters(normalizedAfm) {
    return normalizedAfm.measures.some(function (measure) {
        if (isSimpleMeasure(measure)) {
            var filters = unwrapSimpleMeasure(measure).filters;
            return !!(filters && filters.some(typings_1.AFM.isDateFilter));
        }
        return false;
    });
}
exports.hasMetricDateFilters = hasMetricDateFilters;
/**
 * Returns global date filters
 *
 * @method getGlobalDateFilters
 * @param {INormalizedAFM} normalizedAfm
 * @returns {AFM.DateFilterItem[]}
 */
function getGlobalDateFilters(normalizedAfm) {
    return normalizedAfm.filters.filter(typings_1.AFM.isDateFilter);
}
exports.getGlobalDateFilters = getGlobalDateFilters;
/**
 * Returns true if measure has filters
 *
 * @method hasFilters
 * @param {AFM.ISimpleMeasure} measure
 * @returns {boolean}
 */
exports.hasFilters = function (measure) {
    return !!(measure.filters && measure.filters.length > 0);
};
/**
 * Return date filters from AFM
 *
 * @method getMeasureDateFilters
 * @param {AFM.IAfm} normalizedAfm
 * @returns {AFM.DateFilterItem[]}
 */
function getMeasureDateFilters(normalizedAfm) {
    return flatMap_1.default(normalizedAfm.measures, function (item) {
        var measure = unwrapSimpleMeasure(item);
        if (!measure || !exports.hasFilters(measure)) {
            return [];
        }
        return (measure.filters || []).filter(typings_1.AFM.isDateFilter);
    });
}
exports.getMeasureDateFilters = getMeasureDateFilters;
/**
 * Return true if AFM has global date filter
 *
 * @method hasGlobalDateFilter
 * @param {INormalizedAFM} afm
 * @returns {boolean}
 */
function hasGlobalDateFilter(afm) {
    return afm.filters.some(typings_1.AFM.isDateFilter);
}
exports.hasGlobalDateFilter = hasGlobalDateFilter;
/**
 * Return uri or identifier from ObjQualifier
 *
 * @method getId
 * @param {AFM.ObjQualifier} obj
 * @returns {string|null}
 */
function getId(obj) {
    if (obj.uri) {
        return obj.uri;
    }
    if (obj.identifier) {
        return obj.identifier;
    }
    return null;
}
exports.getId = getId;
/**
 * Returns date filter date dataset
 *
 * @method getDateFilterDateDataSet
 * @param {AFM.DateFilterItem} filter
 * @returns {AFM.ObjQualifier | null }
 */
function getDateFilterDateDataSet(filter) {
    if (typings_1.AFM.isRelativeDateFilter(filter)) {
        return filter.relativeDateFilter.dataSet;
    }
    if (typings_1.AFM.isAbsoluteDateFilter(filter)) {
        return filter.absoluteDateFilter.dataSet;
    }
    throw new Error("Unsupported type of date filter");
}
exports.getDateFilterDateDataSet = getDateFilterDateDataSet;
/**
 * Returns true if dateFilters dataSets match
 *
 * @method dateFiltersDataSetsMatch
 * @param {AFM.DateFilterItem} f1
 * @param {AFM.DateFilterItem} f2
 * @returns {AFM.ObjQualifier | null | boolean}
 */
function dateFiltersDataSetsMatch(f1, f2) {
    var d1 = getDateFilterDateDataSet(f1);
    var d2 = getDateFilterDateDataSet(f2);
    return d1 && d2 && getId(d1) === getId(d2);
}
exports.dateFiltersDataSetsMatch = dateFiltersDataSetsMatch;
function isDateFilterAllTime(dateFilter) {
    if (typings_1.AFM.isRelativeDateFilter(dateFilter)) {
        return dateFilter.relativeDateFilter.granularity === exports.ALL_TIME_GRANULARITY;
    }
    return false;
}
/**
 * Append attribute filters and date filter to afm
 *
 * Date filter handling:
 *      - Override if date filter has the same id
 *      - Add if date filter if date filter id is different
 *
 * Attribute filter handling:
 *      - Add all
 *
 * @method appendFilters
 * @param {AFM.IAfm} afm
 * @param {AFM.AttributeFilterItem[]} attributeFilters
 * @param {AFM.DateFilterItem} dateFilter
 * @param {AFM.IMeasureValueFilter[]} measureValueFilters
 * @return {AFM.IAfm}
 */
function appendFilters(afm, attributeFilters, dateFilter, measureValueFilters) {
    var dateFilters = dateFilter && !isDateFilterAllTime(dateFilter) ? [dateFilter] : [];
    var afmDateFilter = afm.filters ? afm.filters.filter(typings_1.AFM.isDateFilter)[0] : null;
    // all-time selected, need to delete date filter from filters
    var afmFilters = afm.filters || [];
    if (dateFilter && isDateFilterAllTime(dateFilter)) {
        afmFilters = afmFilters.filter(function (filter) {
            if (typings_1.AFM.isDateFilter(filter)) {
                return !dateFiltersDataSetsMatch(filter, dateFilter);
            }
            return true;
        });
    }
    if ((afmDateFilter && dateFilter && !dateFiltersDataSetsMatch(afmDateFilter, dateFilter)) ||
        (afmDateFilter && !dateFilter)) {
        dateFilters.push(afmDateFilter);
    }
    var afmNonDateFilters = afmFilters.filter(function (filter) { return !typings_1.AFM.isDateFilter(filter); });
    var filters = compact_1.default(afmNonDateFilters.concat(attributeFilters, dateFilters, (measureValueFilters || [])));
    if (filters.length || (afm.filters && afm.filters.length)) {
        return __assign({}, afm, { filters: filters });
    }
    return afm;
}
exports.appendFilters = appendFilters;
/**
 * Returns true if AFM is executable
 *
 * @method isAfmExecutable
 * @param {AFM.IAfm} afm
 * @returns {boolean}
 */
function isAfmExecutable(afm) {
    var normalizedAfm = normalizeAfm(afm);
    return normalizedAfm.measures.length > 0 || normalizedAfm.attributes.length > 0;
}
exports.isAfmExecutable = isAfmExecutable;
