"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2019 GoodData Corporation
var get_1 = __importDefault(require("lodash/get"));
var promise_1 = require("./utils/promise");
var xhr_1 = require("./xhr");
var package_json_1 = require("../package.json");
/**
 * Utility methods. Mostly private
 *
 * @module util
 * @class util
 *
 */
/**
 * Gooddata-js package signature
 * @private
 */
exports.thisPackage = { name: package_json_1.name, version: package_json_1.version };
/**
 * Create getter function for accessing nested objects
 *
 * @param {String} path Target path to nested object
 * @method getIn
 * @private
 */
exports.getIn = function (path) { return function (object) { return get_1.default(object, path); }; };
/**
 * Helper for polling
 *
 * @param xhrRequest xhr module
 * @param {String} uri
 * @param {Function} isPollingDone
 * @param {Object} options for polling (maxAttempts, pollStep)
 * @private
 */
exports.handlePolling = function (xhrRequest, uri, isPollingDone, options) {
    if (options === void 0) { options = {}; }
    // TODO
    var _a = options.attempts, attempts = _a === void 0 ? 0 : _a, _b = options.maxAttempts, maxAttempts = _b === void 0 ? 50 : _b, _c = options.pollStep, pollStep = _c === void 0 ? 5000 : _c;
    return xhrRequest(uri)
        .then(function (r) { return r.getData(); })
        .then(function (response) {
        if (attempts > maxAttempts) {
            return Promise.reject(new Error(response));
        }
        return isPollingDone(response)
            ? Promise.resolve(response)
            : promise_1.delay(pollStep).then(function () {
                return exports.handlePolling(xhrRequest, uri, isPollingDone, __assign({}, options, { attempts: attempts + 1 }));
            });
    });
};
/**
 * Helper for polling with header status
 *
 * @param xhrRequest xhr module
 * @param {String} uri
 * @param {Function} isPollingDone
 * @param {Object} options for polling (maxAttempts, pollStep)
 * @private
 */
exports.handleHeadPolling = function (xhrRequest, uri, isPollingDone, options) {
    if (options === void 0) { options = {}; }
    var _a = options.attempts, attempts = _a === void 0 ? 0 : _a, _b = options.maxAttempts, maxAttempts = _b === void 0 ? 50 : _b, _c = options.pollStep, pollStep = _c === void 0 ? 5000 : _c;
    return xhrRequest(uri).then(function (response) {
        if (attempts > maxAttempts) {
            return Promise.reject(new Error("Export timeout!!!"));
        }
        var responseHeaders = response.getHeaders();
        if (isPollingDone(responseHeaders, response)) {
            if (responseHeaders.status === 200) {
                return Promise.resolve({ uri: uri });
            }
            return Promise.reject(new xhr_1.ApiResponseError(response.statusText, response, response.getData()));
        }
        else {
            return promise_1.delay(pollStep).then(function () {
                return exports.handleHeadPolling(xhrRequest, uri, isPollingDone, __assign({}, options, { attempts: attempts + 1 }));
            });
        }
    });
};
/**
 * Builds query string from plain object
 * (Refactored from admin/routes.js)
 *
 * @param {Object} query parameters possibly including arrays inside
 * @returns {string} querystring
 */
function queryString(query) {
    function getSingleParam(key, value) {
        return Array.isArray(value)
            ? value.map(function (item) { return encodeURIComponent(key) + "=" + encodeURIComponent(item); }).join("&")
            : encodeURIComponent(key) + "=" + encodeURIComponent(value);
    }
    return query
        ? "?" + Object.keys(query)
            .map(function (k) { return getSingleParam(k, query[k]); })
            .join("&")
        : "";
}
exports.queryString = queryString;
/**
 * Get all results from paged api by traversing all resulting pages
 * This is usable for apis which support offset and limit (i.e. not those with next paging links)
 *
 * @param xhrGet xhr module
 * @param {string} uri uri to be fetched, will append offset and limit for next pages
 * @param {string} itemKey key under which to look for results (differs for different apis)
 * @param {number} optional offset starting offset, default 0
 * @param pagesData optional data to be pre-filled
 */
function getAllPagesByOffsetLimit(xhr, uri, itemKey, offset, pagesData) {
    if (offset === void 0) { offset = 0; }
    if (pagesData === void 0) { pagesData = []; }
    var PAGE_LIMIT = 100;
    return new Promise(function (resolve, reject) {
        xhr.get(uri + "?offset=" + offset + "&limit=" + PAGE_LIMIT)
            .then(function (r) { return r.getData(); })
            .then(function (dataObjects) {
            var projects = get_1.default(dataObjects, itemKey);
            var data = pagesData.concat(projects.items);
            var totalCount = get_1.default(projects, "paging.totalCount", 0);
            var nextPage = offset + PAGE_LIMIT;
            if (nextPage > totalCount) {
                resolve(data);
            }
            else {
                resolve(getAllPagesByOffsetLimit(xhr, uri, itemKey, nextPage, data));
            }
        }, reject);
    });
}
exports.getAllPagesByOffsetLimit = getAllPagesByOffsetLimit;
