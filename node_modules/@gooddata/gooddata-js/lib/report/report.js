"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2007-2019 GoodData Corporation
var typings_1 = require("@gooddata/typings");
var compact_1 = __importDefault(require("lodash/compact"));
var isEmpty_1 = __importDefault(require("lodash/isEmpty"));
var errors_1 = require("../constants/errors");
var FilterConverter_1 = require("../DataLayer/converters/FilterConverter");
var execute_afm_convert_1 = require("../execution/execute-afm.convert");
var util_1 = require("../util");
var export_1 = require("../utils/export");
/**
 * Functions for working with reports
 *
 * @Class report
 * @module report
 */
var ReportModule = /** @class */ (function () {
    function ReportModule(xhr) {
        var _this = this;
        this.xhr = xhr;
        this.handleExportResultError = function (error) {
            if (_this.isApiResponseError(error) &&
                error.response.status === 400 &&
                error.responseBody.indexOf(errors_1.ERROR_RESTRICTED_CODE) !== -1) {
                return Promise.reject(__assign({}, error, { message: errors_1.ERROR_RESTRICTED_MESSAGE }));
            }
            return Promise.reject(error);
        };
    }
    /**
     * exportResult
     * request new result export
     * request new export of existing AFM execution
     *
     * @experimental
     * @method exportResult
     * @param {String} projectId GoodData projectId
     * @param {String} executionResult report which should be exported
     * @param {IExportConfig} exportConfig requested export options
     * @param {Object} pollingOptions for polling (maxAttempts, pollStep)
     * @return {Promise} Resolves if export successfully,
     *                   Reject if export has error (network error, api error)
     */
    ReportModule.prototype.exportResult = function (projectId, executionResult, exportConfig, pollingOptions) {
        var _this = this;
        if (exportConfig === void 0) { exportConfig = {}; }
        if (pollingOptions === void 0) { pollingOptions = {}; }
        var requestPayload = {
            resultExport: {
                executionResult: executionResult,
                exportConfig: __assign({}, exportConfig, this.sanitizeExportConfig(exportConfig)),
            },
        };
        return this.xhr
            .post("/gdc/internal/projects/" + projectId + "/exportResult", { body: requestPayload })
            .then(function (response) { return response.getData(); })
            .then(function (data) {
            return util_1.handleHeadPolling(_this.xhr.get.bind(_this.xhr), data.uri, export_1.isExportFinished, pollingOptions);
        })
            .catch(this.handleExportResultError);
    };
    ReportModule.prototype.sanitizeExportConfig = function (exportConfig) {
        var afm = exportConfig.afm;
        if (afm && !isEmpty_1.default(afm.filters)) {
            var sanitizedAfm = __assign({}, afm, { filters: this.sanitizeFilters(afm.filters) });
            return __assign({}, exportConfig, { afm: sanitizedAfm });
        }
        return exportConfig;
    };
    ReportModule.prototype.isApiResponseError = function (error) {
        return error.response !== undefined;
    };
    ReportModule.prototype.sanitizeFilters = function (filters) {
        return filters ? compact_1.default(filters.map(this.sanitizeFilter)) : [];
    };
    ReportModule.prototype.sanitizeFilter = function (filter) {
        if (typings_1.AFM.isAttributeFilter(filter)) {
            return execute_afm_convert_1.convertFilter(filter);
        }
        else if (typings_1.AFM.isAbsoluteDateFilter(filter)) {
            return FilterConverter_1.convertAbsoluteDateFilter(filter);
        }
        else if (typings_1.AFM.isRelativeDateFilter(filter)) {
            return FilterConverter_1.convertRelativeDateFilter(filter);
        }
        return filter;
    };
    return ReportModule;
}());
exports.ReportModule = ReportModule;
