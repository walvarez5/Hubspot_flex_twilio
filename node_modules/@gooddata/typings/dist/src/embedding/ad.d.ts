import { CommandFailed, IObjectMeta, IGdcMessageEvent, IGdcMessageEnvelope, CommandFailedData, GdcProductName, IDrillableItemsCommandBody, EmbeddedGdc } from './common';
import { IBaseExportConfig } from '../Export';
import { VisualizationObject } from '../VisualizationObject';
/**
 * All interface, types, type-guard related to embedded analyticalDesigner
 */
export declare namespace EmbeddedAnalyticalDesigner {
    /**
     * Insight Export configuration
     *
     * Note: AFM is omitted on purpose; it should be added by AD itself; create new type using Omit<>
     */
    interface IInsightExportConfig extends IBaseExportConfig {
        /**
         * Include applied filters
         */
        includeFilterContext?: boolean;
    }
    /**
     * Base type for AD events
     */
    type IGdcAdMessageEvent<T, TBody> = IGdcMessageEvent<GdcProductName.ANALYTICAL_DESIGNER, T, TBody>;
    /**
     * Base type for AD event data
     */
    type IGdcAdMessageEnvelope<T, TBody> = IGdcMessageEnvelope<GdcProductName.ANALYTICAL_DESIGNER, T, TBody>;
    /**
     * All AD command Types
     */
    enum GdcAdCommandType {
        /**
         * The command set drillable items
         */
        DrillableItems = "drillableItems",
        /**
         * The command open an insight
         */
        OpenInsight = "openInsight",
        /**
         * The command save an insight
         */
        Save = "saveInsight",
        /**
         * The command save the insight as a new one
         */
        SaveAs = "saveAsInsight",
        /**
         * The command export an insight
         */
        Export = "exportInsight",
        /**
         * The command reset the insight editor to empty state
         */
        Clear = "clear",
        /**
         * The command undo to previous state
         */
        Undo = "undo",
        /**
         * The command redo to next state
         */
        Redo = "redo",
        /**
         * The command to add or update filter context
         */
        SetFilterContext = "setFilterContext",
        /**
         * The command to remove filter item from current filter context
         */
        RemoveFilterContext = "removeFilterContext"
    }
    /**
     * All event types on AD
     */
    enum GdcAdEventType {
        /**
         * Type represent that Insight is saved
         */
        ListeningForDrillableItems = "listeningForDrillableItems",
        /**
         * Type represent that a new insight is initialized
         */
        NewInsightInitialized = "newInsightInitialized",
        /**
         * Type represent that the insight is opened
         */
        InsightOpened = "insightOpened",
        /**
         * Type represent that the insight editor is cleared
         */
        ClearFinished = "clearFinished",
        /**
         * Type represent that the insight is saved
         *
         * Note: use `visualizationSaved` because of backward compatibility
         * @see visualizationSaved event on https://help.gooddata.com
         */
        InsightSaved = "visualizationSaved",
        /**
         * Type represent that the undo action is finished
         */
        UndoFinished = "undoFinished",
        /**
         * Type represent that the redo action is finished
         */
        RedoFinished = "redoFinished",
        /**
         * Type represent that the export action is finished
         */
        ExportFinished = "exportInsightFinished",
        /**
         * Type that drill performed
         */
        Drill = "drill",
        /**
         * Type represent that the filter context is changed
         */
        FilterContextChanged = "filterContextChanged",
        /**
         * Type represent that the set filter context action is finished
         */
        SetFilterContextFinished = "setFilterContextFinished",
        /**
         * Type represent that the remove filter context action is finished
         */
        RemoveFilterContextFinished = "removeFilterContextFinished"
    }
    /**
     * This event will be emitted if AD runs into errors while processing the posted command.
     *
     * @remarks see {@link GdcErrorType} for types of errors that may fly
     */
    type AdCommandFailed = CommandFailed<GdcProductName.ANALYTICAL_DESIGNER>;
    /**
     * Base type for the data of error events sent by AD
     * in case command processing comes to an expected or unexpected halt.
     */
    type AdCommandFailedData = CommandFailedData<GdcProductName.ANALYTICAL_DESIGNER>;
    /**
     * Type-guard checking whether an object is an instance of {@link AdCommandFailedData}
     *
     * @param obj - object to test
     */
    function isAdCommandFailedData(obj: any): obj is AdCommandFailedData;
    /**
     * Set drillable items.
     *
     * Contract:
     *
     * - Drillable items can be set by uris or identifiers of insight's measures/attributes
     */
    type DrillableItemsCommand = IGdcAdMessageEvent<GdcAdCommandType.DrillableItems, IDrillableItemsCommandBody>;
    /**
     * Data type of drillable items command
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see IDrillableItemsCommandBody
     */
    type DrillableItemsCommandData = IGdcAdMessageEnvelope<GdcAdCommandType.DrillableItems, IDrillableItemsCommandBody>;
    /**
     * Type-guard checking whether an object is an instance of {@link DrillableItemsCommandData}
     *
     * @param obj - object to test
     */
    function isDrillableItemsCommandData(obj: any): obj is DrillableItemsCommandData;
    /**
     * Contain the information to contruct the AD url to open an insight editor
     */
    interface IOpenInsightCommandBody {
        /**
         * Dataset identifier - A dataset consists of attributes and facts,
         * which correspond to data you want to measure and the data
         * that you want to use to segment or filter those measurements.
         */
        dataset?: string;
        /**
         * Project id
         */
        projectId?: string;
        /**
         * Client id - Each client has an identifier unique within the domain
         *
         * Note: use the combination of the data product ID and client ID instead of the project ID
         */
        clientId?: string;
        /**
         * Product id - A data product contains multiple segments. And a segment has clients assigned to it
         *
         * Note: use the combination of the data product ID and client ID instead of the project ID
         */
        productId?: string;
        /**
         * Insight id - leave it empty to reset the insight editor to empty state
         */
        insightId?: string;
        /**
         * Insight id - leave it empty to reset the insight editor to empty state
         *
         * Note: if both insightId and reportId are provided. the insightId will be use higher
         * with higher priority.
         */
        reportId?: string;
        /**
         * Show only the attributes, measures, facts, and dates with the specified tag
         */
        includeObjectsWithTags?: string;
        /**
         * Hide the attributes, measures, facts, and dates with the specified tag
         */
        excludeObjectsWithTags?: string;
    }
    /**
     * Open an insight.
     *
     * Contract:
     *
     * - if the insight could not found, then CommandFailed event will be posted
     * - after the insight is opened, then InsightOpened event will be posted
     *
     * Note: if insightId isn't provided, the empty insight editor will be opened
     */
    type OpenInsightCommand = IGdcAdMessageEvent<GdcAdCommandType.OpenInsight, IOpenInsightCommandBody>;
    /**
     * Data type of open insight command
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see IOpenInsightCommandBody
     */
    type OpenInsightCommandData = IGdcAdMessageEnvelope<GdcAdCommandType.OpenInsight, IOpenInsightCommandBody>;
    /**
     * Type-guard checking whether an object is an instance of {@link OpenInsightCommandData}
     *
     * @param obj - object to test
     */
    function isOpenInsightCommandData(obj: any): obj is OpenInsightCommandData;
    /**
     * Triggers the clear action to reset the insight editor to empty state
     */
    type ClearCommand = IGdcAdMessageEvent<GdcAdCommandType.Clear, undefined>;
    /**
     * Data type of clear command
     *
     * Note: it has empty content and just wrapped to application and product data structure
     */
    type ClearCommandData = IGdcAdMessageEnvelope<GdcAdCommandType.Clear, undefined>;
    /**
     * Type-guard checking whether an object is an instance of {@link ClearCommandData}
     *
     * @param obj - object to test
     */
    function isClearCommandData(obj: any): obj is ClearCommandData;
    /**
     * Save command body sent by outer application
     */
    interface ISaveCommandBody {
        /**
         * Insight title - use as title of new insight or rename of saved insight
         */
        title: string;
    }
    /**
     * Saves current insight.
     *
     * Contract:
     *
     * -  if currently edited insight IS NOT eligible for save (empty, in-error), then CommandFailed event
     *    will be posted
     * -  if the specified title is invalid / does not match title validation rules, then CommandFailed event
     *    will be posted
     * -  otherwise insight WILL be saved with the title as specified in the body and the InsightSaved event
     *    will be posted
     * -  the InsightSaved event will be posted even when saving insights that have not changed but are eligible
     *    for saving (not empty, not in-error)
     *
     * Note: sending SaveInsightCommand with different title means insight will be saved with that new title.
     */
    type SaveInsightCommand = IGdcAdMessageEvent<GdcAdCommandType.Save, ISaveCommandBody>;
    /**
     * Data type of save insight command
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see ISaveCommandBody
     */
    type SaveInsightCommandData = IGdcAdMessageEnvelope<GdcAdCommandType.Save, ISaveCommandBody>;
    /**
     * Type-guard checking whether an object is an instance of {@link SaveInsightCommandData}
     *
     * @param obj - object to test
     */
    function isSaveInsightCommandData(obj: any): obj is SaveInsightCommandData;
    /**
     * Save As command body sent by outer application
     */
    interface ISaveAsInsightCommandBody {
        /**
         * Insight title - use as title of new insight
         */
        readonly title: string;
    }
    /**
     * Saves current insight as a new object, with a different title. The title is specified
     *
     * Contract is same as {@link SaveInsightCommand}.
     */
    type SaveAsInsightCommand = IGdcAdMessageEvent<GdcAdCommandType.SaveAs, ISaveAsInsightCommandBody>;
    /**
     * Data type of save as insight command
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see ISaveAsInsightCommandBody
     */
    type SaveAsInsightCommandData = IGdcAdMessageEnvelope<GdcAdCommandType.SaveAs, ISaveAsInsightCommandBody>;
    /**
     * Type-guard checking whether an object is an instance of {@link SaveAsInsightCommandData}
     *
     * @param obj - object to test
     */
    function isSaveAsInsightCommandData(obj: any): obj is SaveAsInsightCommandData;
    /**
     * Export command body sent by outer application
     */
    interface IExportInsightCommandBody {
        /**
         * Configuration for exported file.
         *
         * @see IInsightExportConfig for more details about possible configuration options
         */
        readonly config: IInsightExportConfig;
    }
    /**
     * Exports current insight into CSV or XLSX. The export configuration matches that of the exportResult
     * function already available in gooddata-js. Please consult {@link IExportConfig} for more detail about
     * possible configuration options.
     *
     * Contract:
     *
     * -  if the currently edited insight IS eligible for export then it is done and the ExportFinished event will be
     *    posted with `link` to the result.
     * -  if the currently edited insight IS NOT eligible for export (empty, in-error), then CommandFailed event
     *    will be posted.
     * -  if the specified export config is invalid / does not match validation rules, then CommandFailed event
     *    will be posted
     */
    type ExportInsightCommand = IGdcAdMessageEvent<GdcAdCommandType.Export, IExportInsightCommandBody>;
    /**
     * Data type of export insight command
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see IExportInsightCommandBody
     */
    type ExportInsightCommandData = IGdcAdMessageEnvelope<GdcAdCommandType.Export, IExportInsightCommandBody>;
    /**
     * Type-guard checking whether an object is an instance of {@link ExportInsightCommandData}
     *
     * @param obj - object to test
     */
    function isExportInsightCommandData(obj: any): obj is ExportInsightCommandData;
    /**
     * Triggers the undo action.
     *
     * Contract:
     *
     * -  if it is valid to perform Undo operation, AD will do it and the UndoFinished will be posted once the
     *    undo completes
     *
     * -  if the Undo operation is not available in current state of AD, then CommandFailed will be posted
     */
    type UndoCommand = IGdcAdMessageEvent<GdcAdCommandType.Undo, undefined>;
    /**
     * Data type of undo command
     *
     * Note: it has empty content and just wrapped to application and product data structure
     */
    type UndoCommandData = IGdcAdMessageEnvelope<GdcAdCommandType.Undo, undefined>;
    /**
     * Type-guard checking whether an object is an instance of {@link UndoCommandData}
     *
     * @param obj - object to test
     */
    function isUndoCommandData(obj: any): obj is UndoCommandData;
    /**
     * Triggers the redo action.
     *
     * Contract:
     *
     * -  if it is valid to perform Redo operation, AD will do it and the RedoFinished will be posted once the
     *    redo completes
     *
     * -  if the Redo operation is not available in current state of AD, then CommandFailed will be posted
     */
    type RedoCommand = IGdcAdMessageEvent<GdcAdCommandType.Redo, undefined>;
    /**
     * Data type of redo command
     *
     * Note: it has empty content and just wrapped to application and product data structure
     */
    type RedoCommandData = IGdcAdMessageEnvelope<GdcAdCommandType.Redo, undefined>;
    /**
     * Type-guard checking whether an object is an instance of {@link RedoCommandData}
     *
     * @param obj - object to test
     */
    function isRedoCommandData(obj: any): obj is RedoCommandData;
    /**
     * Data type of SetFilterContext command
     */
    type SetFilterContextCommandData = IGdcAdMessageEnvelope<GdcAdCommandType.SetFilterContext, EmbeddedGdc.IFilterContextContent>;
    /**
     * Add or update the filter context
     *
     * Contract:
     * - if filters are same with filters on the AD filter bar, then update the filters on the filter bar
     *   and apply the filters to insight
     * - if filters are new, then add them to the AD filter bar and apply to insight
     * - in-case the AD can not apply the filters, a CommandFailed will be posted. The reason could be
     *   - Filter is not existed in the dataset
     *   - Filter is existed but wrong elements input data
     *   - Exceed the limit number of filter items
     */
    type SetFilterContextCommand = IGdcAdMessageEvent<GdcAdCommandType.SetFilterContext, EmbeddedGdc.IFilterContextContent>;
    /**
     * Type-guard checking whether an object is an instance of {@link SetFilterContextCommand}
     *
     * @param obj - object to test
     */
    function isSetFilterContextCommandData(obj: any): obj is SetFilterContextCommandData;
    /**
     * Data type of removeFilterContext command
     */
    type RemoveFilterContextCommandData = IGdcAdMessageEnvelope<GdcAdCommandType.RemoveFilterContext, EmbeddedGdc.IRemoveFilterContextContent>;
    /**
     * Remove the filter context
     * Contract:
     * - if filters are in the filter bar, then remove the filters on the filter bar and update insight
     * - if filters are not in the filter bar, then a CommandFailed will be posted.
     */
    type RemoveFilterContextCommand = IGdcAdMessageEvent<GdcAdCommandType.RemoveFilterContext, EmbeddedGdc.IRemoveFilterContextContent>;
    /**
     * Type-guard checking whether an object is an instance of {@link RemoveFilterContextCommand}
     *
     * @param obj - object to test
     */
    function isRemoveFilterContextCommandData(obj: any): obj is RemoveFilterContextCommandData;
    /**
     * List of available commands; this is included in each event sent by AD.
     */
    interface IAvailableCommands {
        /**
         * Array of available commands types
         */
        availableCommands: GdcAdCommandType[];
    }
    /**
     * It's main content is empty.
     */
    type NewInsightInitializedBody = IAvailableCommands;
    /**
     * This event is emitted when AD initializes edit session for a new insight.
     */
    type NewInsightInitialized = IGdcAdMessageEvent<GdcAdEventType.NewInsightInitialized, NewInsightInitializedBody>;
    /**
     * Data type of event that was emitted when the new insight initialized
     *
     * Note: it has empty content and just wrapped to application and product data structure
     */
    type NewInsightInitializedData = IGdcAdMessageEnvelope<GdcAdEventType.NewInsightInitialized, undefined>;
    /**
     * Type-guard checking whether an object is an instance of {@link NewInsightInitializedData}
     *
     * @param obj - object to test
     */
    function isNewInsightInitializedData(obj: any): obj is NewInsightInitializedData;
    /**
     * Main data of InsightOpened event
     */
    type InsightOpenedBody = IAvailableCommands & {
        /**
         * The minimal opened insight information
         */
        insight: IObjectMeta;
    };
    /**
     * This event is emitted when AD initializes edit session for an existing insight. Essential detail about
     * the insight is included in the body.
     */
    type InsightOpened = IGdcAdMessageEvent<GdcAdEventType.InsightOpened, InsightOpenedBody>;
    /**
     * Data type of event that was emitted when an insight is opened
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see InsightOpenedBody
     */
    type InsightOpenedData = IGdcAdMessageEnvelope<GdcAdEventType.InsightOpened, InsightOpenedBody>;
    /**
     * Type-guard checking whether an object is an instance of {@link InsightOpenedData}
     *
     * @param obj - object to test
     */
    function isInsightOpenedData(obj: any): obj is InsightOpenedData;
    /**
     * This event is emitted when AD successfully performs clear operation.
     */
    type ClearFinished = IGdcAdMessageEvent<GdcAdEventType.ClearFinished, IAvailableCommands>;
    /**
     * Data type of event that was emitted after finish clear action
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see UndoFinishedBody
     */
    type ClearFinishedData = IGdcAdMessageEnvelope<GdcAdEventType.ClearFinished, IAvailableCommands>;
    /**
     * Type-guard checking whether an object is an instance of {@link ClearFinishedData}
     *
     * @param obj - object to test
     */
    function isClearFinishedData(obj: any): obj is ClearFinishedData;
    /**
     * Main data of InsightSaved event
     *
     * Note: `visualizationObject` is keeped because of backward compatibility
     */
    type InsightSavedBody = IAvailableCommands & VisualizationObject.IVisualization & {
        /**
         * The minimal saved insight information
         */
        insight: IObjectMeta;
    };
    /**
     * This event is emitted when AD saves the currently edited insight.
     */
    type InsightSaved = IGdcAdMessageEvent<GdcAdEventType.InsightSaved, InsightSavedBody>;
    /**
     * Data type of event that was emitted when an insight is saved
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see InsightSavedBody
     */
    type InsightSavedData = IGdcAdMessageEnvelope<GdcAdEventType.InsightSaved, InsightSavedBody>;
    /**
     * Type-guard checking whether an object is an instance of {@link InsightSavedData}
     *
     * @param obj - object to test
     */
    function isInsightSavedData(obj: any): obj is InsightSavedData;
    /**
     * Main data of ExportFinished event
     */
    type ExportFinishedBody = IAvailableCommands & {
        /**
         * Link to the file containing exported data.
         */
        link: string;
    };
    /**
     * This event is emitted when AD successfully exports data visualized by the currently edited insight.
     */
    type ExportFinished = IGdcAdMessageEvent<GdcAdEventType.ExportFinished, ExportFinishedBody>;
    /**
     * Data type of event that was emitted after an insight was exported
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see ExportFinishedBody
     */
    type ExportFinishedData = IGdcAdMessageEnvelope<GdcAdEventType.ExportFinished, ExportFinishedBody>;
    /**
     * Type-guard checking whether an object is an instance of {@link ExportFinishedData}
     *
     * @param obj - object to test
     */
    function isExportFinishedData(obj: any): obj is ExportFinishedData;
    /**
     * It's main content is empty.
     */
    type UndoFinishedBody = IAvailableCommands;
    /**
     * This event is emitted when AD successfully performs Undo operation.
     */
    type UndoFinished = IGdcAdMessageEvent<GdcAdEventType.UndoFinished, UndoFinishedBody>;
    /**
     * Data type of event that was emitted after finish undo action
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see UndoFinishedBody
     */
    type UndoFinishedData = IGdcAdMessageEnvelope<GdcAdEventType.UndoFinished, UndoFinishedBody>;
    /**
     * Type-guard checking whether an object is an instance of {@link UndoFinishedData}
     *
     * @param obj - object to test
     */
    function isUndoFinishedData(obj: any): obj is UndoFinishedData;
    /**
     * It's main content is empty.
     */
    type RedoFinishedBody = IAvailableCommands;
    /**
     * This event is emitted when AD successfully performs Undo operation.
     */
    type RedoFinished = IGdcAdMessageEvent<GdcAdEventType.RedoFinished, RedoFinishedBody>;
    /**
     * Data type of event that was emitted after finish redo action
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see RedoFinishedBody
     */
    type RedoFinishedData = IGdcAdMessageEnvelope<GdcAdEventType.RedoFinished, RedoFinishedBody>;
    /**
     * Type-guard checking whether an object is an instance of {@link RedoFinishedData}
     *
     * @param obj - object to test
     */
    function isRedoFinishedData(obj: any): obj is RedoFinishedData;
    /**
     * Data type of event that was emitted after finishing set filter context
     *
     * Note: The main event data was wrapped to application and product data structure
     */
    type SetFilterContextFinishedData = IGdcAdMessageEnvelope<GdcAdEventType.SetFilterContextFinished, IAvailableCommands>;
    /**
     * Data type of event that was emitted after finishing remove filter context
     *
     * Note: The main event data was wrapped to application and product data structure
     */
    type RemoveFilterContextFinishedData = IGdcAdMessageEnvelope<GdcAdEventType.RemoveFilterContextFinished, IAvailableCommands>;
    /**
     * Main data of Filter context changed event
     */
    type FilterContextChangedBody = IAvailableCommands & EmbeddedGdc.IFilterContextContent;
    /**
     * Data type of event that was emitted after finishing change filter context
     *
     * Note: The main event data was wrapped to application and product data structure
     */
    type FilterContextChangedData = IGdcAdMessageEnvelope<GdcAdEventType.FilterContextChanged, FilterContextChangedBody>;
}
