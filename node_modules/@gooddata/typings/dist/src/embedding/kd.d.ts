import { IGdcMessageEvent, GdcProductName, IGdcMessageEnvelope, IDrillableItemsCommandBody, EmbeddedGdc } from './common';
export declare namespace EmbeddedKpiDashboard {
    /**
     * Base type for KD events.
     */
    type IGdcKdMessageEvent<T, TBody> = IGdcMessageEvent<GdcProductName.KPI_DASHBOARD, T, TBody>;
    /**
     * Base type for KD event data.
     */
    type IGdcKdMessageEnvelope<T, TBody> = IGdcMessageEnvelope<GdcProductName.KPI_DASHBOARD, T, TBody>;
    /**
     * All KD command Types.
     */
    enum GdcKdCommandType {
        /**
         * The command save a dashboard.
         */
        Save = "saveDashboard",
        /**
         * The command cancel editing dashboard.
         */
        CancelEdit = "cancelEdit",
        /**
         * The command delete existed dashboard.
         */
        Delete = "deleteDashboard",
        /**
         * The command edit a dashboard.
         */
        SwitchToEdit = "switchToEdit",
        /**
         * The command set drillable items.
         */
        DrillableItems = "drillableItems",
        /**
         * The command set size of dashboard.
         */
        SetSize = "setSize",
        /**
         * The command add widget to dashboard.
         */
        AddWidget = "addWidget",
        /**
         * The command add filter to dashboard.
         */
        AddFilter = "addFilter",
        /**
         * The command export a dashboard.
         */
        ExportToPdf = "exportToPdf",
        /**
         * The command to add or update filter context
         */
        SetFilterContext = "setFilterContext",
        /**
         * The command to remove filter item from current filter context
         */
        RemoveFilterContext = "removeFilterContext",
        /**
         * The command to duplicate a KPI Dashboard
         */
        SaveAsDashboard = "saveAsDashboard"
    }
    /**
     * All KD event types.
     */
    enum GdcKdEventType {
        /**
         * Type represent that the dashboard listening for drilling event.
         */
        ListeningForDrillableItems = "listeningForDrillableItems",
        /**
         * Type represent that the embedded content starts loading.
         */
        LoadingStarted = "loadingStarted",
        /**
         * Type represent that The user does not have permissions to view or edit the content.
         */
        NoPermissions = "noPermissions",
        /**
         * Type represent that an operation increasing the height of the hosting iframe is performed.
         */
        Resized = "resized",
        /**
         * Type represent that the dashboard has been created and saved.
         */
        DashboardCreated = "dashboardCreated",
        /**
         * Type represent that the content is fully loaded,
         * and the user has permissions to access the dashboard.
         */
        DashboardLoaded = "loaded",
        /**
         * Type represent that the existing dashboard has been updated.
         */
        DashboardUpdated = "dashboardUpdated",
        /**
         * Type represent that the dashboard is saved.
         *
         */
        DashboardSaved = "dashboardSaved",
        /**
         * Type represent that the dashboard is deleted.
         *
         */
        DashboardDeleted = "dashboardDeleted",
        /**
         * Type represent that the user cancels the creation of the dashboard.
         */
        DashboardCreationCanceled = "dashboardCreationCanceled",
        /**
         * Type represent that the dashboard is switched to edit mode.
         */
        SwitchedToEdit = "switchedToEdit",
        /**
         * Type represent that the dashboard is switched to view mode.
         */
        SwitchedToView = "switchedToView",
        /**
         * Type represent that the platform is down.
         */
        Platform = "platform",
        /**
         * Type represent that the widget is added to dashboard.
         *
         */
        WidgetAdded = "widgetAdded",
        /**
         * Type represent that the filter is added to dashboard.
         *
         */
        FilterAdded = "filterAdded",
        /**
         * Type represent that the export action is finished.
         */
        ExportedToPdf = "exportedToPdf",
        /**
         * Type represent that the drill performed
         */
        Drill = "drill",
        /**
         * Type represent that the filter context is changed
         */
        FilterContextChanged = "filterContextChanged",
        /**
         * Type represent that the set filter context action is finished
         */
        SetFilterContextFinished = "setFilterContextFinished",
        /**
         * Type represent that the remove filter context action is finished
         */
        RemoveFilterContextFinished = "removeFilterContextFinished",
        /**
         * Type that represents started drill to URL. The event does not contain an URL. The event can be used as
         * notification to display a loading indicator as the URL resolving takes some time. The URL is sent in
         * DrillToUrlResolved event which is posted after the URL is resolved. The event also contains an ID that can
         * be matched with ID in subsequently posted DrillToUrlResolved event.
         */
        DrillToUrlStarted = "drillToUrlStarted",
        /**
         * Type that represents resolved drill to URL. The event is sent after DrillToUrlStarted event was posted and
         * it contains the resolved URL. The event also contains an ID which can be matched with ID from
         * DrillToUrlStarted event.
         */
        DrillToUrlResolved = "drillToUrlResolved"
    }
    /**
     * List of available commands. This is included in each event sent by KD.
     */
    interface IKdAvailableCommands {
        /**
         * Array of available commands types.
         */
        availableCommands: GdcKdCommandType[];
    }
    /**
     * Save command body sent by outer application
     */
    interface IKdSaveCommandBody {
        /**
         * Dashboard title - use as title of new dashboard or rename of saved dashboard
         */
        title: string;
    }
    /**
     * Saves current dashboard.
     *
     * Contract:
     *
     * -  if currently edited dashboard IS NOT eligible for save (empty, in-error), then CommandFailed event
     *    will be posted
     * -  if the specified title is invalid / does not match title validation rules, then CommandFailed event
     *    will be posted
     * -  otherwise dashboard WILL be saved with the title as specified in the body and the DashboardSaved event
     *    will be posted
     * -  the DashboardSaved event will be posted even when saving dashboard that has not changed but would
     *    otherwise be eligible for saving (not empty, not in-error)
     *
     * Note: sending Save command with different title means dashboard will be saved with that new title.
     */
    type SaveDashboardCommand = IGdcKdMessageEvent<GdcKdCommandType.Save, IKdSaveCommandBody>;
    type SaveDashboardCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.Save, IKdSaveCommandBody>;
    /**
     * Type-guard checking whether object is an instance of {@link SaveDashboardCommandData}.
     *
     * @param obj - object to test
     */
    function isSaveDashboardCommandData(obj: any): obj is SaveDashboardCommandData;
    /**
     * Creates a new dashboard from an existing dashboard
     *
     * Contract:
     *
     * -  if KD saves as new an existing dashboard in view mode, the DashboardSaved event will be posted,
     * the new duplicated dashboard doesn't apply changes from the filter bar.
     *
     * -  if KD saves as new an existing dashboard in edit mode, the DashboardSaved event will be posted,
     * the new duplicated dashboard applies all changes from the existing dashboard like
     * title, filter context, insight widgets, layout...
     *
     * -  if KD saves as new an existing dashboard in the locked dashboard but the user can create new dashboard,
     * the DashboardSaved event will be posted, the new duplicated dashboard won't be locked.
     *
     * -  if KD doesn't have an existing dashboard, no permission to create dashboard or the title is empty,
     * CommandFailed is posted
     */
    type SaveAsDashboardCommand = IGdcKdMessageEvent<GdcKdCommandType.SaveAsDashboard, IKdSaveCommandBody>;
    type SaveAsDashboardCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.SaveAsDashboard, IKdSaveCommandBody>;
    /**
     * Type-guard checking whether object is an instance of {@link SaveAsDashboardCommandData}.
     *
     * @param obj - object to test
     */
    function isSaveAsDashboardCommandData(obj: any): obj is SaveAsDashboardCommandData;
    /**
     * Cancels editing and switches dashboard to view mode.
     *
     * Contract:
     *
     * -  if KD is currently editing dashboard, this will trigger switch to view mode, without popping up the
     *    dialog asking to discard unsaved changes. On success SwitchedToView will be posted
     * -  if KD is currently viewing dashboard, SwitchedToView will be posted back immediately
     * -  if KD is not currently showing any dashboard, CommandFailed is posted
     */
    type CancelEditCommand = IGdcKdMessageEvent<GdcKdCommandType.CancelEdit, null>;
    type CancelEditCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.CancelEdit, null>;
    /**
     * Type-guard checking whether object is an instance of {@link CancelEditData}.
     *
     * @param obj - object to test
     */
    function isCancelEditCommandData(obj: any): obj is CancelEditCommandData;
    /**
     * Deleted currently edited dashboard.
     *
     * Contract:
     *
     * -  if KD is currently editing dashboard, this will trigger delete without popping up the dialog
     *    asking for permission. On success DashboardDeleted will be posted
     *
     * -  if KD is currently viewing dashboard or not not showing any dashboard, CommandFailed will
     *    be posted
     */
    type DeleteDashboardCommand = IGdcKdMessageEvent<GdcKdCommandType.Delete, null>;
    type DeleteDashboardCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.Delete, null>;
    /**
     * Switches current dashboard to edit mode.
     *
     * Contract:
     *
     * -  if KD shows dashboard in view mode, will switch to edit mode and post SwitchedToEdit once ready for
     *    editing
     * -  if KD shows dashboard in edit mode, will keep edit mode and post SwitchedToEdit as if just switched
     *    from view mode
     * -  if no dashboard currently displayed, posts CommandFailed
     */
    type SwitchToEditCommand = IGdcKdMessageEvent<GdcKdCommandType.SwitchToEdit, null>;
    type SwitchToEditCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.SwitchToEdit, null>;
    /**
     * Type-guard checking whether object is an instance of {@link SwitchToEditCommandData}.
     *
     * @param obj - object to test
     */
    function isSwitchToEditCommandData(obj: any): obj is SwitchToEditCommandData;
    /**
     * Set drillable items.
     *
     * Contract:
     *
     * - Drillable items can be set by uris or identifiers of dashboard's measures/attributes
     */
    type DrillableItemsCommand = IGdcKdMessageEvent<GdcKdCommandType.DrillableItems, IDrillableItemsCommandBody>;
    /**
     * Data type of drillable items command
     *
     * Note: The main event data was wrapped to application and product data structure
     * @see IDrillableItemsCommandBody
     */
    type DrillableItemsCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.DrillableItems, IDrillableItemsCommandBody>;
    /**
     * Type-guard checking whether object is an instance of {@link DrillableItemsCommandData}.
     *
     * @param obj - object to test
     */
    function isDrillableItemsCommandData(obj: any): obj is DrillableItemsCommandData;
    interface ISetSizeCommandBody {
        /**
         * the height of the hosting iframe
         */
        height: number;
    }
    type SetSizeCommand = IGdcKdMessageEvent<GdcKdCommandType.SetSize, ISetSizeCommandBody>;
    type SetSizeCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.SetSize, ISetSizeCommandBody>;
    /**
     * Type-guard checking whether object is an instance of {@link SetSizeCommandData}.
     *
     * @param obj - object to test
     */
    function isSetSizeCommandData(obj: any): obj is SetSizeCommandData;
    /**
     * Data type of SetFilterContext command
     */
    type SetFilterContextCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.SetFilterContext, EmbeddedGdc.IFilterContextContent>;
    /**
     * Add or update the filter context
     *
     * Contract:
     * - If filters are same with filters on the KD filter bar, then update the filters on the filter bar
     *   and apply the filters to dashboard
     * - In edit mode, if filters are new and then add them to the KD filter bar and apply to dashboard
     * - In-case the KD can not apply the filters, a CommandFailed will be posted. The reason could be:
     *   - Add new filter in view mode
     *   - Filter is not existed in the dataset
     *   - Filter is existed but wrong elements input data
     *   - Exceed the limit number of filter items
     */
    type SetFilterContextCommand = IGdcKdMessageEvent<GdcKdCommandType.SetFilterContext, EmbeddedGdc.IFilterContextContent>;
    /**
     * Type-guard checking whether an object is an instance of {@link SetFilterContextCommand}
     *
     * @param obj - object to test
     */
    function isSetFilterContextCommandData(obj: any): obj is SetFilterContextCommandData;
    /**
     * Data type of removeFilterContext command
     */
    type RemoveFilterContextCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.RemoveFilterContext, EmbeddedGdc.IRemoveFilterContextContent>;
    /**
     * Remove the filter context
     * Contract:
     * - if filters are in the filter bar, then remove the filters on the filter bar and update insight
     * - if filters are not in the filter bar and then a CommandFailed will be posted.
     */
    type RemoveFilterContextCommand = IGdcKdMessageEvent<GdcKdCommandType.RemoveFilterContext, EmbeddedGdc.IRemoveFilterContextContent>;
    /**
     * Type-guard checking whether an object is an instance of {@link RemoveFilterContextCommand}
     *
     * @param obj - object to test
     */
    function isRemoveFilterContextCommandData(obj: any): obj is RemoveFilterContextCommandData;
    interface IKpiWidget {
        type: 'kpi';
    }
    interface IIdentifierInsightRef {
        identifier: string;
    }
    interface IUriInsightRef {
        uri: string;
    }
    interface IInsightWidget {
        type: 'insight';
        ref: IIdentifierInsightRef | IUriInsightRef;
    }
    interface IAddWidgetBody {
        widget: IKpiWidget | IInsightWidget;
    }
    /**
     * Type-guard checking whether object is an instance of {@link IdentifierInsightRef}.
     *
     * @param obj - object to test
     */
    function isIdentifierInsight(obj: any): obj is IIdentifierInsightRef;
    /**
     * Type-guard checking whether object is an instance of {@link UriInsightRef}.
     *
     * @param obj - object to test
     */
    function isUriInsight(obj: any): obj is IUriInsightRef;
    /**
     * Adds new widget onto dashboard. New row will be created on top of the dashboard, the widget
     * will be placed into its first column.
     *
     * It is currently possible to add either a KPI or an Insight. When adding either of these, KD will
     * scroll to top so that the newly added widget is visible.
     *
     * For KPI, the KD will start the KPI customization flow right after the KPI is placed.
     * Insights are placed without need for further customization
     *
     * Contract:
     *
     * -  if KD is currently editing a dashboard, then depending on widget type:
     *    -  KPI is added to dashboard, customization flow is started, WidgetAdded will be posted
     *    -  Insight is added to dashboard, WidgetAdded will be posted
     *
     * -  if insight reference included in command payload does not refer to a valid insight, CommandFailed
     *    will be posted
     *
     * -  if KD is in view mode or not showing any dashboard, then CommandFailed will be posted
     */
    type AddWidgetCommand = IGdcKdMessageEvent<GdcKdCommandType.AddWidget, IAddWidgetBody>;
    type AddWidgetCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.AddWidget, IAddWidgetBody>;
    /**
     * Type-guard checking whether object is an instance of {@link AddWidgetCommandData}.
     *
     * @param obj - object to test
     */
    function isAddWidgetCommandData(obj: any): obj is AddWidgetCommandData;
    /**
     * Adds new attribute filter to filter bar and starts the filter customization flow.
     *
     * Contract:
     *
     * -  if KD is currently editing a dashboard, adds new attribute filter, starts customization flow; FilterAdded
     *    will be posted right after customization starts
     *
     * -  if KD is currently in view mode or does not show any dashboard, will post CommandFailed
     */
    type AddFilterCommand = IGdcKdMessageEvent<GdcKdCommandType.AddFilter, null>;
    type AddFilterCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.AddFilter, null>;
    /**
     * Type-guard checking whether object is an instance of {@link AddFilterCommandData}.
     *
     * @param obj - object to test
     */
    function isAddFilterCommandData(obj: any): obj is AddFilterCommandData;
    /**
     * Exports dashboard to PDF.
     *
     * Contract:
     *
     * -  if KD shows dashboard in view mode, will export dashboard to PDF and post ExportFinished once ready for
     *    exporting
     * -  if KD shows dashboard in edit mode or not not showing any dashboard, CommandFailed will
     *    be posted
     */
    type ExportToPdfCommand = IGdcKdMessageEvent<GdcKdCommandType.ExportToPdf, null>;
    type ExportToPdfCommandData = IGdcKdMessageEnvelope<GdcKdCommandType.ExportToPdf, null>;
    /**
     * Type-guard checking whether object is an instance of {@link ExportToPdfCommandData}.
     *
     * @param obj - object to test
     */
    function isExportToPdfCommandData(obj: any): obj is ExportToPdfCommandData;
    interface INoPermissionsBody {
        /**
         * the 'data' section contains information about whether view or edit permissions are missing
         */
        reason: string;
    }
    /**
     * This event is emitted When User does not have permissions to view or edit the content
     */
    type NoPermissionsEventData = IGdcKdMessageEnvelope<GdcKdEventType.NoPermissions, INoPermissionsBody>;
    interface IResizedBody {
        height: number;
    }
    /**
     * This event is emitted when the content is fully loaded
     */
    type ResizedEventData = IGdcKdMessageEnvelope<GdcKdEventType.Resized, IResizedBody>;
    interface IDashboardObjectMeta {
        /**
         * Client id - Each client has an identifier unique within the domain
         *
         * Note: use the combination of the data product ID and client ID instead of the project ID
         */
        client?: string;
        /**
         * object id
         */
        dashboardId: string;
        /**
         * Project id
         */
        project: string;
        /**
         * dashboard identifier
         */
        dashboard: string;
        /**
         * dashboard title - this is what users see in KD top bar (if visible)
         */
        title: string;
    }
    type IDashboardBody = IKdAvailableCommands & IDashboardObjectMeta;
    /**
     * Data type of event that was emitted when a dashboard has been created and saved.
     */
    type IDashboardCreatedData = IGdcKdMessageEnvelope<GdcKdEventType.DashboardCreated, IDashboardBody>;
    /**
     * Data type of event that was emitted when the content is fully loaded,
     * and the user has permissions to access the dashboard.
     */
    type IDashboardLoadedData = IGdcKdMessageEnvelope<GdcKdEventType.DashboardLoaded, IDashboardBody>;
    /**
     * Data type of event that was emitted when the existing dashboard has been updated.
     */
    type IDashboardUpdatedData = IGdcKdMessageEnvelope<GdcKdEventType.DashboardUpdated, IDashboardBody>;
    /**
     * Data type of event that was emitted when the dashboard has been saved.
     */
    type IDashboardSavedData = IGdcKdMessageEnvelope<GdcKdEventType.DashboardSaved, IDashboardBody>;
    /**
     * Data type of event that was emitted when the dashboard has been deleted.
     */
    type IDashboardDeletedData = IGdcKdMessageEnvelope<GdcKdEventType.DashboardDeleted, IDashboardBody>;
    /**
     * This event is emitted after KD switched a dashboard from view mode to edit mode.
     */
    type SwitchedToEditData = IGdcKdMessageEnvelope<GdcKdEventType.SwitchedToEdit, IDashboardBody>;
    /**
     * This event is emitted after KD switched a dashboard from edit mode to view mode.
     */
    type SwitchedToViewData = IGdcKdMessageEnvelope<GdcKdEventType.SwitchedToView, IDashboardBody>;
    interface IPlaformBody {
        status?: string;
        errorCode?: number;
        description?: string;
    }
    type PlaformData = IGdcKdMessageEnvelope<GdcKdEventType.Platform, IPlaformBody>;
    interface IInsightWidgetBody {
        widgetCategory: 'kpi' | 'visualization';
        identifier?: string;
        uri?: string;
        title?: string;
    }
    interface IAddedWidgetBody {
        insight?: IInsightWidgetBody;
    }
    /**
     * This event is emitted after KD added a new widget to a dashboard. If the widget is
     * an insight, then meta information about the insight will be returned.
     *
     * Note: when this event is added for a KPI widget, it means the customization flow for the KPI has
     * started. The user may still 'just' click somewhere outside of the KPI configuration and the KPI will
     * be discarded.
     */
    type WidgetAddedData = IGdcKdMessageEnvelope<GdcKdEventType.WidgetAdded, IAddedWidgetBody>;
    type FilterAddedBody = IKdAvailableCommands;
    /**
     * This event is emitted after KD added a new filter to dashboard's filter bar and started its
     * customization flow.
     *
     * Note: users can still cancel the filter customization flow meaning no new attribute filter
     * will end on the filter bar.
     */
    type FilterAddedData = IGdcKdMessageEnvelope<GdcKdEventType.FilterAdded, FilterAddedBody>;
    type ExportToPdfFinishedBody = IKdAvailableCommands & {
        /**
         * Link to the file containing exported data.
         */
        link: string;
    };
    /**
     * This event is emitted after dashboard has been exported to PDF
     */
    type ExportToPdfFinishedData = IGdcKdMessageEnvelope<GdcKdEventType.ExportedToPdf, ExportToPdfFinishedBody>;
    /**
     * Data type of event that was emitted after finishing set filter context
     *
     * Note: The main event data was wrapped to application and product data structure
     */
    type SetFilterContextFinishedData = IGdcKdMessageEnvelope<GdcKdEventType.SetFilterContextFinished, IKdAvailableCommands>;
    /**
     * Data type of event that was emitted after finishing remove filter context
     *
     * Note: The main event data was wrapped to application and product data structure
     */
    type RemoveFilterContextFinishedData = IGdcKdMessageEnvelope<GdcKdEventType.RemoveFilterContextFinished, IKdAvailableCommands>;
    /**
     * Main data of Filter context changed event
     */
    type FilterContextChangedBody = IKdAvailableCommands & EmbeddedGdc.IFilterContextContent;
    /**
     * Data type of event that was emitted after finishing change filter context
     *
     * Note: The main event data was wrapped to application and product data structure
     */
    type FilterContextChangedData = IGdcKdMessageEnvelope<GdcKdEventType.FilterContextChanged, FilterContextChangedBody>;
    interface IDrillToUrlStartedDataBody {
        id: string;
    }
    interface IDrillToUrlResolvedDataBody {
        id: string;
        url: string;
    }
    type DrillToUrlStartedData = IGdcKdMessageEnvelope<GdcKdEventType.DrillToUrlStarted, IDrillToUrlStartedDataBody>;
    type DrillToUrlResolvedData = IGdcKdMessageEnvelope<GdcKdEventType.DrillToUrlResolved, IDrillToUrlResolvedDataBody>;
}
