import { IObjectMeta } from './Meta';
export declare namespace VisualizationObject {
    type SortDirection = 'asc' | 'desc';
    type Identifier = string;
    type MeasureAggregation = 'sum' | 'count' | 'avg' | 'min' | 'max' | 'median' | 'runsum';
    type TotalType = 'sum' | 'avg' | 'max' | 'min' | 'nat' | 'med';
    type VisualizationType = 'table' | 'line' | 'column' | 'bar' | 'pie' | 'doughnut' | 'combo' | 'area';
    type ArithmeticMeasureOperator = 'sum' | 'difference' | 'multiplication' | 'ratio' | 'change';
    type BucketItem = IMeasure | IVisualizationAttribute;
    type VisualizationObjectExtendedFilter = VisualizationObjectFilter | IMeasureValueFilter | IRankingFilter;
    type VisualizationObjectFilter = VisualizationObjectDateFilter | VisualizationObjectAttributeFilter;
    type VisualizationObjectDateFilter = IVisualizationObjectRelativeDateFilter | IVisualizationObjectAbsoluteDateFilter;
    type VisualizationObjectAttributeFilter = IVisualizationObjectPositiveAttributeFilter | IVisualizationObjectNegativeAttributeFilter;
    interface IObjUriQualifier {
        uri: string;
    }
    interface IObjIdentifierQualifier {
        identifier: string;
    }
    type ObjQualifier = IObjUriQualifier | IObjIdentifierQualifier;
    interface IVisualizationObjectPositiveAttributeFilter {
        positiveAttributeFilter: {
            displayForm: ObjQualifier;
            in: string[];
        };
    }
    interface IVisualizationObjectNegativeAttributeFilter {
        negativeAttributeFilter: {
            displayForm: ObjQualifier;
            notIn: string[];
        };
    }
    interface IVisualizationObjectAbsoluteDateFilter {
        absoluteDateFilter: {
            dataSet: ObjQualifier;
            from?: string;
            to?: string;
        };
    }
    interface IVisualizationObjectRelativeDateFilter {
        relativeDateFilter: {
            dataSet: ObjQualifier;
            granularity: string;
            from?: number;
            to?: number;
        };
    }
    type ComparisonConditionOperator = 'GREATER_THAN' | 'GREATER_THAN_OR_EQUAL_TO' | 'LESS_THAN' | 'LESS_THAN_OR_EQUAL_TO' | 'EQUAL_TO' | 'NOT_EQUAL_TO';
    interface IComparisonCondition {
        comparison: {
            operator: ComparisonConditionOperator;
            value: number;
            treatNullValuesAs?: number;
        };
    }
    type RangeConditionOperator = 'BETWEEN' | 'NOT_BETWEEN';
    interface IRangeCondition {
        range: {
            operator: RangeConditionOperator;
            from: number;
            to: number;
            treatNullValuesAs?: number;
        };
    }
    type MeasureValueFilterCondition = IComparisonCondition | IRangeCondition;
    interface ILocalIdentifierQualifier {
        localIdentifier: string;
    }
    interface IMeasureValueFilter {
        measureValueFilter: {
            measure: IObjUriQualifier | ILocalIdentifierQualifier;
            condition?: MeasureValueFilterCondition;
        };
    }
    type RankingFilterOperator = 'TOP' | 'BOTTOM';
    interface IRankingFilter {
        rankingFilter: {
            measures: Array<IObjUriQualifier | ILocalIdentifierQualifier>;
            attributes?: Array<IObjUriQualifier | ILocalIdentifierQualifier>;
            operator: RankingFilterOperator;
            value: number;
        };
    }
    interface IVisualizationObjectContent {
        visualizationClass: IObjUriQualifier;
        buckets: IBucket[];
        filters?: VisualizationObjectExtendedFilter[];
        properties?: string;
        references?: IReferenceItems;
    }
    interface IReferenceItems {
        [identifier: string]: string;
    }
    interface IBucket {
        localIdentifier?: Identifier;
        items: BucketItem[];
        totals?: IVisualizationTotal[];
    }
    interface IVisualizationTotal {
        type: TotalType;
        measureIdentifier: string;
        attributeIdentifier: string;
        alias?: string;
    }
    type IMeasureDefinitionType = IMeasureDefinition | IArithmeticMeasureDefinition | IPoPMeasureDefinition | IPreviousPeriodMeasureDefinition;
    interface IMeasure {
        measure: {
            localIdentifier: Identifier;
            definition: IMeasureDefinitionType;
            alias?: string;
            title?: string;
            format?: string;
        };
    }
    interface IVisualizationAttribute {
        visualizationAttribute: {
            localIdentifier: Identifier;
            displayForm: ObjQualifier;
            alias?: string;
        };
    }
    interface IMeasureDefinition {
        measureDefinition: {
            item: ObjQualifier;
            aggregation?: MeasureAggregation;
            filters?: VisualizationObjectFilter[];
            computeRatio?: boolean;
        };
    }
    interface IArithmeticMeasureDefinition {
        arithmeticMeasure: {
            measureIdentifiers: Identifier[];
            operator: ArithmeticMeasureOperator;
        };
    }
    interface IPoPMeasureDefinition {
        popMeasureDefinition: {
            measureIdentifier: Identifier;
            popAttribute: ObjQualifier;
        };
    }
    interface IPreviousPeriodMeasureDefinition {
        previousPeriodMeasure: {
            measureIdentifier: Identifier;
            dateDataSets: IPreviousPeriodDateDataSet[];
        };
    }
    interface IPreviousPeriodDateDataSet {
        dataSet: ObjQualifier;
        periodsAgo: number;
    }
    interface IVisualizationObject {
        meta: IObjectMeta;
        content: IVisualizationObjectContent;
    }
    interface IVisualization {
        visualizationObject: IVisualizationObject;
    }
    interface IVisualizationObjectResponse {
        visualizationObject: IVisualizationObject;
    }
    function isMeasure(bucketItem: IMeasure | IVisualizationAttribute): bucketItem is IMeasure;
    function isVisualizationAttribute(bucketItem: IMeasure | IVisualizationAttribute): bucketItem is IVisualizationAttribute;
    function isMeasureDefinition(definition: IMeasureDefinitionType): definition is IMeasureDefinition;
    function isArithmeticMeasureDefinition(definition: IMeasureDefinitionType): definition is IArithmeticMeasureDefinition;
    function isPopMeasureDefinition(definition: IMeasureDefinitionType): definition is IPoPMeasureDefinition;
    function isPreviousPeriodMeasureDefinition(definition: IMeasureDefinitionType): definition is IPreviousPeriodMeasureDefinition;
    function isAttributeFilter(filter: VisualizationObjectFilter): filter is VisualizationObjectAttributeFilter;
    function isDateFilter(filter: VisualizationObjectFilter): filter is VisualizationObjectDateFilter;
    function isPositiveAttributeFilter(filter: VisualizationObjectAttributeFilter): filter is IVisualizationObjectPositiveAttributeFilter;
    function isMeasureValueFilter(filter: VisualizationObjectExtendedFilter): filter is IMeasureValueFilter;
    function isRankingFilter(filter: VisualizationObjectExtendedFilter): filter is IRankingFilter;
    function isAbsoluteDateFilter(filter: VisualizationObjectDateFilter): filter is IVisualizationObjectAbsoluteDateFilter;
    function isRelativeDateFilter(filter: VisualizationObjectDateFilter): filter is IVisualizationObjectRelativeDateFilter;
    function isAttribute(bucketItem: BucketItem): bucketItem is IVisualizationAttribute;
    function isLocalIdentifierQualifier(objectQualifier: IObjUriQualifier | ILocalIdentifierQualifier): objectQualifier is ILocalIdentifierQualifier;
    function isComparisonCondition(condition: MeasureValueFilterCondition): condition is IComparisonCondition;
    function isRangeCondition(condition: MeasureValueFilterCondition): condition is IRangeCondition;
}
