/**
 * Types defined here are client-side representation of the AFM. This representation MAY differ from the
 * physical representation of the AFM accepted by the REST API.
 *
 * The intended use is that client code uses exclusively types defined in this namespace. Functions or methods
 * that communicate with executeAfm REST API endpoint MUST transform this AFM to a structure acceptable by
 * the backend.
 *
 * >>> Note for developers: when you modify these structures, be sure to update gooddata-js execute-afm.convert.ts
 * with conversion of the new/updated construct to ExecuteAFM types accepted by backend.
 *
 * @see ./ExecuteAFM
 */
export declare namespace AFM {
    interface IExecution {
        execution: {
            afm: IAfm;
            resultSpec?: IResultSpec;
        };
    }
    interface IAfm {
        attributes?: IAttribute[];
        measures?: IMeasure[];
        filters?: CompatibilityFilter[];
        nativeTotals?: INativeTotalItem[];
    }
    interface IResultSpec {
        dimensions?: IDimension[];
        sorts?: SortItem[];
    }
    interface IAttribute {
        localIdentifier: Identifier;
        displayForm: ObjQualifier;
        alias?: string;
    }
    interface IMeasure {
        localIdentifier: Identifier;
        definition: MeasureDefinition;
        alias?: string;
        format?: string;
    }
    type MeasureDefinition = ISimpleMeasureDefinition | IArithmeticMeasureDefinition | IPopMeasureDefinition | IPreviousPeriodMeasureDefinition;
    interface ISimpleMeasureDefinition {
        measure: ISimpleMeasure;
    }
    interface IArithmeticMeasureDefinition {
        arithmeticMeasure: IArithmeticMeasure;
    }
    interface IPopMeasureDefinition {
        popMeasure: IPopMeasure;
    }
    interface IPreviousPeriodMeasureDefinition {
        previousPeriodMeasure: IPreviousPeriodMeasure;
    }
    type SimpleMeasureAggregation = 'sum' | 'count' | 'avg' | 'min' | 'max' | 'median' | 'runsum';
    interface ISimpleMeasure {
        item: ObjQualifier;
        aggregation?: SimpleMeasureAggregation;
        filters?: FilterItem[];
        computeRatio?: boolean;
    }
    type ArithmeticMeasureOperator = 'sum' | 'difference' | 'multiplication' | 'ratio' | 'change';
    interface IArithmeticMeasure {
        measureIdentifiers: Identifier[];
        operator: ArithmeticMeasureOperator;
    }
    interface IPopMeasure {
        measureIdentifier: Identifier;
        popAttribute: ObjQualifier;
    }
    interface IPreviousPeriodMeasure {
        measureIdentifier: Identifier;
        dateDataSets: IPreviousPeriodDateDataSet[];
    }
    interface IPreviousPeriodDateDataSet {
        dataSet: ObjQualifier;
        periodsAgo: number;
    }
    type Identifier = string;
    type ObjQualifier = IObjUriQualifier | IObjIdentifierQualifier;
    interface IObjIdentifierQualifier {
        identifier: string;
    }
    interface IObjUriQualifier {
        uri: string;
    }
    type ExtendedFilter = FilterItem | IMeasureValueFilter | IRankingFilter;
    type CompatibilityFilter = IExpressionFilter | ExtendedFilter;
    type FilterItem = DateFilterItem | AttributeFilterItem;
    type AttributeFilterItem = IPositiveAttributeFilter | INegativeAttributeFilter;
    type DateFilterItem = IAbsoluteDateFilter | IRelativeDateFilter;
    interface IPositiveAttributeFilter {
        positiveAttributeFilter: {
            displayForm: ObjQualifier;
            in: string[];
            textFilter?: boolean;
        };
    }
    interface INegativeAttributeFilter {
        negativeAttributeFilter: {
            displayForm: ObjQualifier;
            notIn: string[];
            textFilter?: boolean;
        };
    }
    interface IAbsoluteDateFilter {
        absoluteDateFilter: {
            dataSet: ObjQualifier;
            from: string;
            to: string;
        };
    }
    interface IRelativeDateFilter {
        relativeDateFilter: {
            dataSet: ObjQualifier;
            granularity: string;
            from: number;
            to: number;
        };
    }
    type ComparisonConditionOperator = 'GREATER_THAN' | 'GREATER_THAN_OR_EQUAL_TO' | 'LESS_THAN' | 'LESS_THAN_OR_EQUAL_TO' | 'EQUAL_TO' | 'NOT_EQUAL_TO';
    interface IComparisonCondition {
        comparison: {
            operator: ComparisonConditionOperator;
            value: number;
            treatNullValuesAs?: number;
        };
    }
    type RangeConditionOperator = 'BETWEEN' | 'NOT_BETWEEN';
    interface IRangeCondition {
        range: {
            operator: RangeConditionOperator;
            from: number;
            to: number;
            treatNullValuesAs?: number;
        };
    }
    type MeasureValueFilterCondition = IComparisonCondition | IRangeCondition;
    interface ILocalIdentifierQualifier {
        localIdentifier: string;
    }
    type Qualifier = ObjQualifier | ILocalIdentifierQualifier;
    interface IMeasureValueFilter {
        measureValueFilter: {
            measure: Qualifier;
            condition?: MeasureValueFilterCondition;
        };
    }
    type RankingFilterOperator = 'TOP' | 'BOTTOM';
    interface IRankingFilter {
        rankingFilter: {
            measures: Qualifier[];
            attributes?: Qualifier[];
            operator: RankingFilterOperator;
            value: number;
        };
    }
    interface IExpressionFilter {
        value: string;
    }
    interface ITotalItem {
        measureIdentifier: Identifier;
        type: TotalType;
        attributeIdentifier: Identifier;
    }
    type TotalType = 'sum' | 'avg' | 'max' | 'min' | 'nat' | 'med';
    interface INativeTotalItem {
        measureIdentifier: Identifier;
        attributeIdentifiers: Identifier[];
    }
    interface IDimension {
        itemIdentifiers: Identifier[];
        totals?: ITotalItem[];
    }
    type SortItem = IAttributeSortItem | IMeasureSortItem;
    type SortDirection = 'asc' | 'desc';
    interface IAttributeSortItem {
        attributeSortItem: {
            direction: SortDirection;
            attributeIdentifier: Identifier;
            aggregation?: 'sum';
        };
    }
    type VisualizationStyleType = 'common' | 'table' | 'line' | 'column' | 'bar' | 'area';
    interface IVisualizationStyle {
        visualizationStyle: {
            type: VisualizationStyleType;
            colorPalette: {
                measure?: {
                    color: string;
                    periodOverPeriod: string;
                };
                stack?: any;
            };
        };
    }
    interface IMeasureSortItem {
        measureSortItem: {
            direction: SortDirection;
            locators: LocatorItem[];
        };
    }
    type LocatorItem = IAttributeLocatorItem | IMeasureLocatorItem;
    interface IAttributeLocatorItem {
        attributeLocatorItem: {
            attributeIdentifier: Identifier;
            element: string;
        };
    }
    interface IMeasureLocatorItem {
        measureLocatorItem: {
            measureIdentifier: Identifier;
        };
    }
    function isObjectUriQualifier(qualifier: AFM.ObjQualifier): qualifier is AFM.IObjUriQualifier;
    function isObjIdentifierQualifier(qualifier: AFM.ObjQualifier): qualifier is AFM.IObjIdentifierQualifier;
    function isSimpleMeasureDefinition(definition: AFM.MeasureDefinition): definition is AFM.ISimpleMeasureDefinition;
    function isArithmeticMeasureDefinition(definition: AFM.MeasureDefinition): definition is AFM.IArithmeticMeasureDefinition;
    function isPopMeasureDefinition(definition: AFM.MeasureDefinition): definition is AFM.IPopMeasureDefinition;
    function isPreviousPeriodMeasureDefinition(definition: AFM.MeasureDefinition): definition is AFM.IPreviousPeriodMeasureDefinition;
    function isAttributeSortItem(sortItem: AFM.SortItem): sortItem is AFM.IAttributeSortItem;
    function isMeasureSortItem(sortItem: AFM.SortItem): sortItem is AFM.IMeasureSortItem;
    function isMeasureLocatorItem(locator: AFM.LocatorItem): locator is AFM.IMeasureLocatorItem;
    function isDateFilter(filter: AFM.CompatibilityFilter): filter is AFM.DateFilterItem;
    function isRelativeDateFilter(filter: AFM.CompatibilityFilter): filter is AFM.IRelativeDateFilter;
    function isAbsoluteDateFilter(filter: AFM.CompatibilityFilter): filter is AFM.IAbsoluteDateFilter;
    function isAttributeFilter(filter: AFM.CompatibilityFilter): filter is AFM.AttributeFilterItem;
    function isPositiveAttributeFilter(filter: AFM.CompatibilityFilter): filter is AFM.IPositiveAttributeFilter;
    function isNegativeAttributeFilter(filter: AFM.CompatibilityFilter): filter is AFM.INegativeAttributeFilter;
    function isMeasureValueFilter(filter: AFM.CompatibilityFilter): filter is AFM.IMeasureValueFilter;
    function isRankingFilter(filter: AFM.CompatibilityFilter): filter is AFM.IRankingFilter;
    function isExpressionFilter(filter: AFM.CompatibilityFilter): filter is AFM.IExpressionFilter;
}
