import { AFM } from './AFM';
import { VisualizationObject } from './VisualizationObject';
/**
 * This namespace implements types that are used as inputs to various visualization components.
 *
 * At the moment these most of the types are mere aliases to types in VisualizationObject, AFM, or unions
 * to different types. There is one notable exception: the measure & (simple) measure definition, this type
 * is redefined here to allow simple measure filters be defined as text filters; this is not possible with the
 * standard visualization object.
 */
export declare namespace VisualizationInput {
    type ObjQualifier = VisualizationObject.ObjQualifier;
    type IAttribute = VisualizationObject.IVisualizationAttribute;
    type IPreviousPeriodDateDataSet = VisualizationObject.IPreviousPeriodDateDataSet;
    type ArithmeticMeasureOperator = VisualizationObject.ArithmeticMeasureOperator;
    type IArithmeticMeasureDefinition = VisualizationObject.IArithmeticMeasureDefinition;
    type IPoPMeasureDefinition = VisualizationObject.IPoPMeasureDefinition;
    type IPreviousPeriodMeasureDefinition = VisualizationObject.IPreviousPeriodMeasureDefinition;
    type MeasureAggregation = VisualizationObject.MeasureAggregation;
    type IMeasureDefinitionType = IMeasureDefinition | IArithmeticMeasureDefinition | IPoPMeasureDefinition | IPreviousPeriodMeasureDefinition;
    interface IMeasureDefinition {
        measureDefinition: {
            item: ObjQualifier;
            aggregation?: MeasureAggregation;
            filters?: IMeasureFilter[];
            computeRatio?: boolean;
        };
    }
    interface IMeasure {
        measure: {
            localIdentifier: VisualizationObject.Identifier;
            definition: IMeasureDefinitionType;
            alias?: string;
            title?: string;
            format?: string;
        };
    }
    type AttributeOrMeasure = IAttribute | IMeasure;
    type IPositiveAttributeFilter = AFM.IPositiveAttributeFilter;
    type INegativeAttributeFilter = AFM.INegativeAttributeFilter;
    type IAbsoluteDateFilter = VisualizationObject.IVisualizationObjectAbsoluteDateFilter;
    type IRelativeDateFilter = VisualizationObject.IVisualizationObjectRelativeDateFilter;
    type IMeasureValueFilter = VisualizationObject.IMeasureValueFilter;
    type IRankingFilter = VisualizationObject.IRankingFilter;
    type IMeasureFilter = IAbsoluteDateFilter | IRelativeDateFilter | IPositiveAttributeFilter | INegativeAttributeFilter;
    type IFilter = IAbsoluteDateFilter | IRelativeDateFilter | IPositiveAttributeFilter | INegativeAttributeFilter | IMeasureValueFilter | IRankingFilter;
    type ISort = AFM.IAttributeSortItem | AFM.IMeasureSortItem;
    type ITotal = VisualizationObject.IVisualizationTotal;
    function isMeasure(obj: any): obj is IMeasure;
    function isMeasureDefinition(obj: IMeasureDefinitionType): obj is IMeasureDefinition;
    function isArithmeticMeasureDefinition(obj: IMeasureDefinitionType): obj is IArithmeticMeasureDefinition;
    function isPopMeasureDefinition(obj: IMeasureDefinitionType): obj is IPoPMeasureDefinition;
    function isPreviousPeriodMeasureDefinition(obj: any): obj is any;
    function isAttribute(obj: any): obj is IAttribute;
    function isPositiveAttributeFilter(obj: any): obj is IPositiveAttributeFilter;
    function isNegativeAttributeFilter(obj: any): obj is INegativeAttributeFilter;
    function isAbsoluteDateFilter(obj: any): obj is IAbsoluteDateFilter;
    function isRelativeDateFilter(obj: any): obj is IRelativeDateFilter;
    function isMeasureValueFilter(obj: any): obj is IMeasureValueFilter;
    function isRankingFilter(obj: any): obj is IRankingFilter;
    function isSort(obj: any): obj is ISort;
}
