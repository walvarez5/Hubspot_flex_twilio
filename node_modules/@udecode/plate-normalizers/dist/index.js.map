{"version":3,"file":"index.js","sources":["../src/createNormalizeTypesPlugin.ts","../../../node_modules/lodash/isArray.js","../../../node_modules/lodash/castArray.js","../src/createRemoveEmptyNodesPlugin.ts"],"sourcesContent":["import {\n  ErrorHandler,\n  getNode,\n  insertNodes,\n  setNodes,\n} from '@udecode/plate-common';\nimport {\n  getPlatePluginWithOverrides,\n  isElement,\n  TElement,\n  WithOverride,\n} from '@udecode/plate-core';\nimport { Path } from 'slate';\n\ninterface Rule {\n  /**\n   * Force the type of the node at the given path\n   */\n  strictType?: string;\n  /**\n   * Type of the inserted node at the given path if `strictType` is not provided\n   */\n  type?: string;\n  /**\n   * Path where the rule applies\n   */\n  path: Path;\n}\n\nexport interface WithNormalizeTypes extends ErrorHandler {\n  /**\n   * Set of rules for the types.\n   * For each rule, provide a `path` and either `strictType` or `type`.\n   * If there is no node existing at `path`:\n   * insert a node with `strictType`.\n   * If there is a node existing at `path` but its type is not `strictType` or `type`:\n   * set the node type to `strictType` or `type`.\n   */\n  rules: Rule[];\n}\n\nexport const withNormalizeTypes = ({\n  rules,\n  onError,\n}: WithNormalizeTypes): WithOverride => (editor) => {\n  const { normalizeNode } = editor;\n\n  editor.normalizeNode = ([currentNode, currentPath]) => {\n    if (!currentPath.length) {\n      const endCurrentNormalizationPass = rules.some(\n        ({ strictType, type, path }) => {\n          const node = getNode(editor, path);\n\n          if (node) {\n            if (strictType && isElement(node) && node.type !== strictType) {\n              setNodes<TElement>(\n                editor,\n                { type: strictType },\n                {\n                  at: path,\n                }\n              );\n              return true;\n            }\n          } else {\n            try {\n              insertNodes<TElement>(\n                editor,\n                {\n                  type: strictType ?? type!,\n                  children: [{ text: '' }],\n                },\n                { at: path }\n              );\n              return true;\n            } catch (err) {\n              onError?.(err);\n            }\n          }\n\n          return false;\n        }\n      );\n\n      if (endCurrentNormalizationPass) {\n        return;\n      }\n    }\n\n    return normalizeNode([currentNode, currentPath]);\n  };\n\n  return editor;\n};\n\n/**\n * @see {@link withNormalizeTypes}\n */\nexport const createNormalizeTypesPlugin = getPlatePluginWithOverrides(\n  withNormalizeTypes\n);\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isArray = require('./isArray');\n\n/**\n * Casts `value` as an array if it's not one.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Lang\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast array.\n * @example\n *\n * _.castArray(1);\n * // => [1]\n *\n * _.castArray({ 'a': 1 });\n * // => [{ 'a': 1 }]\n *\n * _.castArray('abc');\n * // => ['abc']\n *\n * _.castArray(null);\n * // => [null]\n *\n * _.castArray(undefined);\n * // => [undefined]\n *\n * _.castArray();\n * // => []\n *\n * var array = [1, 2, 3];\n * console.log(_.castArray(array) === array);\n * // => true\n */\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray(value) ? value : [value];\n}\n\nmodule.exports = castArray;\n","import {\n  getPlatePluginWithOverrides,\n  isElement,\n  WithOverride,\n} from '@udecode/plate-core';\nimport castArray from 'lodash/castArray';\nimport { Node, NodeEntry, Transforms } from 'slate';\n\n/**\n * Remove nodes with empty text.\n */\nexport const withRemoveEmptyNodes = (options: {\n  type: string | string[];\n}): WithOverride => (editor) => {\n  const types = castArray(options.type);\n\n  const { normalizeNode } = editor;\n\n  editor.normalizeNode = ([node, path]: NodeEntry) => {\n    if (\n      isElement(node) &&\n      node.type &&\n      types.includes(node.type) &&\n      Node.string(node) === ''\n    ) {\n      Transforms.removeNodes(editor, { at: path });\n      return;\n    }\n\n    normalizeNode([node, path]);\n  };\n\n  return editor;\n};\n\n/**\n * @see {@link withRemoveEmptyNodes}\n */\nexport const createRemoveEmptyNodesPlugin = getPlatePluginWithOverrides(\n  withRemoveEmptyNodes\n);\n"],"names":["withNormalizeTypes","rules","onError","editor","normalizeNode","currentNode","currentPath","length","endCurrentNormalizationPass","some","strictType","type","path","node","getNode","isElement","setNodes","at","insertNodes","children","text","err","createNormalizeTypesPlugin","getPlatePluginWithOverrides","isArray","withRemoveEmptyNodes","options","types","castArray","includes","Node","string","Transforms","removeNodes","createRemoveEmptyNodesPlugin"],"mappings":"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"}