{"version":3,"file":"livequery.js","sources":["../src/livequery.ts"],"sourcesContent":["import { UriBuilder } from './utils/uri';\nimport { SyncError } from './utils/syncerror';\nimport log from './utils/logger';\n\nimport { EventEmitter } from 'events';\nimport { SyncEntity, EntityServices, RemovalHandler } from './entity';\nimport { Network } from './interfaces/services';\nimport { Closeable } from './closeable';\nimport { Cache } from './cache';\nimport { nonEmptyString, validateTypes, validateTypesAsync } from '@twilio/declarative-type-validator';\n\nexport interface InsightsServices extends EntityServices {\n}\n\n/**\n * An individual result from a LiveQuery or InstantQuery result set.\n */\nexport class InsightsItem {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * The identifier that maps to this item within the search result.\n   */\n  key: string;\n\n  /**\n   * The contents of the item.\n   */\n  value: object;\n}\n\n/**\n * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression.\n * Each result is a key-value pair, where each key identifies its object uniquely. These\n * results are equivalent to a set of InsightsItem-s.\n */\nexport interface ItemsSnapshot {\n  [key: string]: object;\n}\n\nexport interface InsightsQueryResponse {\n  query_id: string;\n  last_event_id: number;\n  items?: [{\n    key: string;\n    data: object;\n    revision: number;\n  }];\n}\n\nexport interface LiveQueryDescriptor {\n  indexName: string;\n  sid: string;\n  queryExpression: string;\n  queryUri: string;\n  last_event_id: number;\n}\n\nexport type LiveQueryCreator = (indexName: string, queryExpression: string) => Promise<LiveQuery>;\n\nexport class LiveQueryImpl extends SyncEntity {\n\n  private readonly descriptor: LiveQueryDescriptor;\n  private readonly cache: Cache<string, InsightsItem>;\n\n  constructor(descriptor: LiveQueryDescriptor, services: InsightsServices, removalHandler: RemovalHandler, items?: any) {\n    super(services, removalHandler);\n    this.descriptor = descriptor;\n    this.cache = new Cache<string, InsightsItem>();\n\n    if (items) {\n      items.forEach(item => {\n        this.cache.store(item.key, { key: item.key, value: item.data} as InsightsItem, item.revision);\n      });\n    }\n  }\n\n  // public\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  // private extension of SyncEntity\n  get uniqueName() {\n    return null;\n  }\n\n  get type() {\n    return LiveQueryImpl.type;\n  }\n\n  static get type() {\n    return 'live_query';\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get indexName() {\n    return this.descriptor.indexName;\n  }\n\n  get queryString() {\n    return this.descriptor.queryExpression;\n  }\n\n  // custom private props\n  get queryUri() {\n    return this.descriptor.queryUri;\n  }\n\n  get liveQueryDescriptor() {\n    return this.descriptor;\n  }\n\n  // dummy stub from iface\n  protected onRemoved() {\n  }\n\n  public getItems(): ItemsSnapshot {\n    const dataByKey = {};\n    this.cache.forEach((key, item) => {\n      dataByKey[key] = item.value;\n    });\n    return dataByKey;\n  }\n\n  /**\n   * @internal\n   */\n  _update(message: any, isStrictlyOrdered: boolean): void {\n    switch (message.type) {\n      case 'live_query_item_updated':\n        this.handleItemMutated(message.item_key, message.item_data, message.item_revision);\n        break;\n      case 'live_query_item_removed':\n        this.handleItemRemoved(message.item_key, message.item_revision);\n        break;\n      case 'live_query_updated':\n        this.handleBatchUpdate(message.items);\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(message.last_event_id);\n    }\n  }\n\n  private handleItemMutated(key: string, value: object, revision: number) {\n    if (this.shouldIgnoreEvent(key, revision)) {\n      log.trace(`Item ${key} update skipped, revision: ${revision}`);\n    } else {\n      const newItem: InsightsItem = {key, value};\n      this.cache.store(key, newItem, revision);\n      this.broadcastEventToListeners('itemUpdated', newItem);\n    }\n  }\n\n  private handleItemRemoved(key: string, revision: number) {\n    const force = (revision === null);\n    if (this.shouldIgnoreEvent(key, revision)) {\n      log.trace(`Item ${key} delete skipped, revision: ${revision}`);\n    } else {\n      this.cache.delete(key, revision, force);\n      this.broadcastEventToListeners('itemRemoved', {key});\n    }\n  }\n\n  private handleBatchUpdate(items) {\n    // preprocess item set for easy key-based access (it's a one-time constant time operation)\n    let newItems = {};\n    if (items != null) {\n      items.forEach(item => {\n        newItems[item.key] = {\n          data: item.data,\n          revision: item.revision\n        };\n      });\n    }\n\n    // go through existing items and generate update/remove events for them\n    this.cache.forEach((key, item) => {\n      const newItem = newItems[key];\n      if (newItem != null) {\n        this.handleItemMutated(key, newItem.data, newItem.revision);\n      } else {\n        this.handleItemRemoved(key, null); // force deletion w/o revision\n      }\n      // once item is handled, remove it from incoming array\n      delete newItems[key];\n    });\n\n    // once we handled all the known items, handle remaining pack\n    for (let key in newItems) {\n      this.handleItemMutated(key, newItems[key].data, newItems[key].revision);\n    }\n  }\n\n  private shouldIgnoreEvent(key: string, eventId: number) {\n    return key != null && eventId != null && this.cache.isKnown(key, eventId);\n  }\n\n  /**\n   * @internal\n   */\n  _advanceLastEventId(eventId: number, revision?: string): void {\n    // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n    }\n  }\n}\n\nexport async function queryItems(params: any): Promise<InsightsQueryResponse>  {\n  let { network, queryString, uri, type } = params;\n  if (queryString == null) { // should not be null or undefined\n    throw new SyncError(`Invalid query`, 400, 54507);\n  }\n  const liveQueryRequestBody: any = {\n    query_string: queryString // raw query string (like `key == \"value\" AND key2 != \"value2\"`)\n  };\n\n  if (type === LiveQuery.type) {\n    liveQueryRequestBody.type = type;\n  }\n\n  let response = await network.post(uri, liveQueryRequestBody, undefined, true);\n  return response.body;\n}\n\n/**\n * Represents a long-running query against Flex data wherein the returned result set\n * subsequently receives pushed updates whenever new (or updated) records would match the\n * given expression. Updated results are presented row-by-row until this query is explicitly\n * closed.\n *\n * Use the {@link SyncClient.liveQuery} method to create a live query.\n */\nexport class LiveQuery extends Closeable {\n  private readonly liveQueryImpl: LiveQueryImpl;\n\n  // private props\n  static get type() {\n    return LiveQueryImpl.type;\n  }\n\n  get type() {\n    return LiveQueryImpl.type;\n  }\n\n  get lastEventId(): number {\n    return this.liveQueryImpl.lastEventId;\n  }\n\n  /**\n   * The immutable identifier of this query object, assigned by the system.\n   */\n  get sid(): string {\n    return this.liveQueryImpl.sid;\n  }\n\n  /**\n   * @internal\n   */\n  constructor(liveQueryImpl: LiveQueryImpl) {\n    super();\n    this.liveQueryImpl = liveQueryImpl;\n    this.liveQueryImpl.attach(this);\n  }\n\n  /**\n   * Fired when an item has been added or updated.\n   *\n   * Parameters:\n   * 1. {@link InsightsItem} `item` - updated item\n   * @example\n   * ```typescript\n   * liveQuery.on('itemUpdated', (item) => {\n   *   console.log(`Item ${item.key} was updated`'`);\n   *   console.log('Item value:', item.value);\n   * });\n   * ```\n   * @event\n   */\n  static readonly itemUpdated = 'itemUpdated';\n\n  /**\n   * Fired when an existing item has been removed.\n   *\n   * Parameters:\n   * 1. object `args` - info object provided with the event. It has the following properties:\n   *     * object `key` - the key of the removed item\n   * @example\n   * ```typescript\n   * liveQuery.on('itemRemoved', (args) => {\n   *   console.log(`Item ${args.key} was removed`);\n   * });\n   * ```\n   * @event\n   */\n  static readonly itemRemoved = 'itemRemoved';\n\n  /**\n   * Closes this query instance and unsubscribes from further service events.\n   * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.\n   */\n  public close(): void {\n    super.close();\n    this.liveQueryImpl.detach(this.listenerUuid);\n  }\n\n  /**\n   * @return A snapshot of items matching the current query expression.\n   */\n  public getItems(): ItemsSnapshot {\n    this.ensureNotClosed();\n    return this.liveQueryImpl.getItems();\n  }\n}\n\n/**\n * Allows repetitive quick searches against a specific Flex data. Unlike a\n * LiveQuery, this result set does not subscribe to any updates and therefore receives no events\n * beyond the initial result set.\n *\n * Use the {@link SyncClient.instantQuery} method to create an Instant Query.\n */\nexport class InstantQuery extends EventEmitter {\n  private indexName: string;\n  private queryUri: string;\n  private readonly insightsUri: string;\n  private readonly liveQueryCreator: LiveQueryCreator;\n  private readonly network: Network;\n  private queryExpression: string = null;\n  private items = {};\n\n  // private props\n  static get type() {\n    return 'instant_query';\n  }\n\n  get type() {\n    return InstantQuery.type;\n  }\n\n  /**\n   * @internal\n   */\n  constructor(params: any) {\n    super();\n    Object.assign(this, params);\n    this.updateIndexName(params.indexName);\n  }\n\n  /**\n   * Fired when a search result is ready.\n   *\n   * Parameters:\n   * 1. {@link ItemsSnapshot} `items` - a snapshot of items matching current query expression.\n   * @example\n   * ```typescript\n   * instantQuery.on('searchResult', (items) => {\n   *    Object.entries(items).forEach(([key, value]) => {\n   *      console.log('Search result item key:', key);\n   *      console.log('Search result item value:', value);\n   *    });\n   * });\n   * ```\n   * @event\n   */\n  static readonly searchResult = 'searchResult';\n\n  /**\n   * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery.searchResult}\n   * event.\n   * @param queryExpression A query expression to be executed against the given data index. For more information\n   * on the syntax read {@link SyncClient.liveQuery}.\n   * @return A promise that resolves when query result has been received.\n   */\n  @validateTypesAsync('string')\n  public async search(queryExpression: string): Promise<void> {\n    this.items = {};\n    return queryItems({\n      network: this.network,\n      uri: this.queryUri,\n      queryString: queryExpression,\n    })\n      .then((response) => {\n        this.queryExpression = queryExpression;\n        if (response.items) {\n          response.items.forEach((item) => {\n            this.items[item.key] = item.data;\n          });\n        }\n        this.emit('searchResult', this.getItems());\n      })\n      .catch((err) => {\n        log.error(\n            `Error '${err.message}' while executing query '${queryExpression}'`\n        );\n        this.queryExpression = null;\n        throw err;\n      });\n  }\n\n  /**\n   * Instantiates a LiveQuery object based on the last known query expression that was passed to the\n   * {@link InstantQuery.search} method. This LiveQuery will start receiving updates with new results,\n   * while current object can be still used to execute repetitive searches.\n   * @return A promise which resolves when the LiveQuery object is ready.\n   */\n  public async subscribe(): Promise<LiveQuery> {\n    if (this.queryExpression == null) { // should not be null or undefined\n      return Promise.reject(new SyncError(`Invalid query`, 400, 54507));\n    }\n\n    return this.liveQueryCreator(this.indexName, this.queryExpression);\n  }\n\n  /**\n   * @return A snapshot of items matching current query expression.\n   */\n  public getItems(): ItemsSnapshot {\n    return this.items;\n  }\n\n  /**\n   * Set new index name\n   * @param indexName New index name to set\n   */\n  @validateTypes(nonEmptyString)\n  public updateIndexName(indexName: string): void {\n    this.indexName = indexName;\n    this.queryUri = this.generateQueryUri(this.indexName);\n  }\n\n  private generateQueryUri(indexName: string) {\n    return new UriBuilder(this.insightsUri)\n      .pathSegment(indexName)\n      .pathSegment('Items')\n      .build();\n  }\n}\n\nexport default LiveQuery;\n"],"names":["SyncEntity","Cache","log","SyncError","Closeable","EventEmitter","UriBuilder","__decorate","validateTypesAsync","validateTypes","nonEmptyString"],"mappings":"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"}