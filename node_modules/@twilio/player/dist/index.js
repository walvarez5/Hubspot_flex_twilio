'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var WS = require('wavesurfer.js');
var WS__default = _interopDefault(WS);
var eventemitter3 = require('eventemitter3');
require('debounce');
var reactDom = require('react-dom');

class TimelinePlugin {
    constructor(params, ws) {
        this._onScroll = () => {
            if (this.wrapper && this.drawer.wrapper) {
                this.wrapper.scrollLeft = this.drawer.wrapper.scrollLeft;
            }
        };
        this._onRedraw = () => this.render();
        this._onReady = () => {
            const ws = this.wavesurfer;
            this.drawer = ws.drawer;
            this.pixelRatio = ws.drawer.params.pixelRatio;
            this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;
            this.maxCanvasElementWidth =
                ws.drawer.maxCanvasElementWidth ||
                    Math.round(this.maxCanvasWidth / this.pixelRatio);
            ws.drawer.wrapper.addEventListener('scroll', this._onScroll);
            ws.on('redraw', this._onRedraw);
            ws.on('zoom', this._onZoom);
            this.render();
        };
        this._onWrapperClick = e => {
            e.preventDefault();
            const relX = 'offsetX' in e ? e.offsetX : e.layerX;
            this.fireEvent('click', relX / this.wrapper.scrollWidth || 0);
        };
        this.container =
            'string' == typeof params.container
                ? document.querySelector(params.container)
                : params.container;
        if (!this.container) {
            throw new Error('No container for wavesurfer timeline');
        }
        this.wavesurfer = ws;
        this.util = ws.util;
        this.params = Object.assign({}, {
            height: 20,
            notchPercentHeight: 90,
            labelPadding: 5,
            unlabeledNotchColor: '#c0c0c0',
            primaryColor: '#000',
            secondaryColor: '#c0c0c0',
            primaryFontColor: '#000',
            secondaryFontColor: '#000',
            fontFamily: 'Arial',
            fontSize: 10,
            duration: null,
            zoomDebounce: false,
            formatTimeCallback: this.defaultFormatTimeCallback,
            timeInterval: this.defaultTimeInterval,
            primaryLabelInterval: this.defaultPrimaryLabelInterval,
            secondaryLabelInterval: this.defaultSecondaryLabelInterval,
            offset: 0
        }, params);
        this.canvases = [];
        this.wrapper = null;
        this.drawer = null;
        this.pixelRatio = null;
        this.maxCanvasWidth = null;
        this.maxCanvasElementWidth = null;
        this._onZoom = this.params.zoomDebounce
            ? this.wavesurfer.util.debounce(() => this.render(), this.params.zoomDebounce)
            : () => this.render();
    }
    static create(params) {
        return {
            name: 'timeline',
            deferInit: params && params.deferInit ? params.deferInit : false,
            params: params,
            instance: TimelinePlugin
        };
    }
    init() {
        if (this.wavesurfer.isReady) {
            this._onReady();
        }
        else {
            this.wavesurfer.once('ready', this._onReady);
        }
    }
    destroy() {
        this.unAll();
        this.wavesurfer.un('redraw', this._onRedraw);
        this.wavesurfer.un('zoom', this._onZoom);
        this.wavesurfer.un('ready', this._onReady);
        this.wavesurfer.drawer.wrapper.removeEventListener('scroll', this._onScroll);
        if (this.wrapper && this.wrapper.parentNode) {
            this.wrapper.removeEventListener('click', this._onWrapperClick);
            this.wrapper.parentNode.removeChild(this.wrapper);
            this.wrapper = null;
        }
    }
    createWrapper() {
        const wsParams = this.wavesurfer.params;
        this.container.innerHTML = '';
        this.wrapper = this.container.appendChild(document.createElement('timeline'));
        this.util.style(this.wrapper, {
            display: 'block',
            position: 'relative',
            userSelect: 'none',
            webkitUserSelect: 'none',
            height: `${this.params.height}px`
        });
        if (wsParams.fillParent || wsParams.scrollParent) {
            this.util.style(this.wrapper, {
                width: '100%',
                overflowX: 'hidden',
                overflowY: 'hidden'
            });
        }
        this.wrapper.addEventListener('click', this._onWrapperClick);
    }
    render() {
        if (!this.wrapper) {
            this.createWrapper();
        }
        this.updateCanvases();
        this.updateCanvasesPositioning();
        this.renderCanvases();
    }
    addCanvas() {
        const canvas = this.wrapper.appendChild(document.createElement('canvas'));
        this.canvases.push(canvas);
        this.util.style(canvas, {
            position: 'absolute',
            zIndex: 4
        });
    }
    removeCanvas() {
        const canvas = this.canvases.pop();
        canvas.parentElement.removeChild(canvas);
    }
    updateCanvases() {
        const totalWidth = Math.round(this.drawer.wrapper.scrollWidth);
        const requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);
        while (this.canvases.length < requiredCanvases) {
            this.addCanvas();
        }
        while (this.canvases.length > requiredCanvases) {
            this.removeCanvas();
        }
    }
    updateCanvasesPositioning() {
        const canvasesLength = this.canvases.length;
        this.canvases.forEach((canvas, i) => {
            const canvasWidth = i === canvasesLength - 1
                ? this.drawer.wrapper.scrollWidth -
                    this.maxCanvasElementWidth * (canvasesLength - 1)
                : this.maxCanvasElementWidth;
            canvas.width = canvasWidth * this.pixelRatio;
            canvas.height = (this.params.height + 1) * this.pixelRatio;
            this.util.style(canvas, {
                width: `${canvasWidth}px`,
                height: `${this.params.height}px`,
                left: `${i * this.maxCanvasElementWidth}px`
            });
        });
    }
    renderCanvases() {
        const duration = this.params.duration ||
            this.wavesurfer.backend.getDuration();
        if (duration <= 0) {
            return;
        }
        const wsParams = this.wavesurfer.params;
        const fontSize = this.params.fontSize * wsParams.pixelRatio;
        const totalSeconds = parseInt(duration, 10) + 1;
        const width = wsParams.fillParent && !wsParams.scrollParent
            ? this.drawer.getWidth()
            : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;
        const height1 = this.params.height * this.pixelRatio;
        const height2 = this.params.height *
            (this.params.notchPercentHeight / 100) *
            this.pixelRatio;
        const pixelsPerSecond = width / duration;
        const formatTime = this.params.formatTimeCallback;
        const intervalFnOrVal = option => typeof option === 'function' ? option(pixelsPerSecond) : option;
        const timeInterval = intervalFnOrVal(this.params.timeInterval);
        const primaryLabelInterval = intervalFnOrVal(this.params.primaryLabelInterval);
        const secondaryLabelInterval = intervalFnOrVal(this.params.secondaryLabelInterval);
        let curPixel = pixelsPerSecond * this.params.offset;
        let curSeconds = 0;
        let i;
        const positioning = [];
        for (i = 0; i < totalSeconds / timeInterval; i++) {
            positioning.push([i, curSeconds, curPixel]);
            curSeconds += timeInterval;
            curPixel += pixelsPerSecond * timeInterval;
        }
        const renderPositions = cb => {
            positioning.forEach(pos => {
                cb(pos[0], pos[1], pos[2]);
            });
        };
        this.setFillStyles(this.params.primaryColor);
        this.setFonts(`${fontSize}px ${this.params.fontFamily}`);
        this.setFillStyles(this.params.primaryFontColor);
        renderPositions((i, curSeconds, curPixel) => {
            if (i % primaryLabelInterval === 0) {
                this.fillRect(curPixel, 0, 1, height1);
                this.fillText(formatTime(curSeconds, pixelsPerSecond), curPixel + this.params.labelPadding * this.pixelRatio, height1);
            }
        });
        this.setFillStyles(this.params.secondaryColor);
        this.setFonts(`${fontSize}px ${this.params.fontFamily}`);
        this.setFillStyles(this.params.secondaryFontColor);
        renderPositions((i, curSeconds, curPixel) => {
            if (i % secondaryLabelInterval === 0) {
                this.fillRect(curPixel, 0, 1, height1);
                this.fillText(formatTime(curSeconds, pixelsPerSecond), curPixel + this.params.labelPadding * this.pixelRatio, height1);
            }
        });
        this.setFillStyles(this.params.unlabeledNotchColor);
        renderPositions((i, curSeconds, curPixel) => {
            if (i % secondaryLabelInterval !== 0 &&
                i % primaryLabelInterval !== 0) {
                this.fillRect(curPixel, 0, 1, height2);
            }
        });
    }
    setFillStyles(fillStyle) {
        this.canvases.forEach(canvas => {
            canvas.getContext('2d').fillStyle = fillStyle;
        });
    }
    setFonts(font) {
        this.canvases.forEach(canvas => {
            canvas.getContext('2d').font = font;
        });
    }
    fillRect(x, y, width, height) {
        this.canvases.forEach((canvas, i) => {
            const leftOffset = i * this.maxCanvasWidth;
            const intersection = {
                x1: Math.max(x, i * this.maxCanvasWidth),
                y1: y,
                x2: Math.min(x + width, i * this.maxCanvasWidth + canvas.width),
                y2: y + height
            };
            if (intersection.x1 < intersection.x2) {
                canvas
                    .getContext('2d')
                    .fillRect(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1);
            }
        });
    }
    fillText(text, x, y) {
        let textWidth;
        let xOffset = 0;
        this.canvases.forEach(canvas => {
            const context = canvas.getContext('2d');
            const canvasWidth = context.canvas.width;
            if (xOffset > x + textWidth) {
                return;
            }
            if (xOffset + canvasWidth > x) {
                textWidth = context.measureText(text).width;
                context.fillText(text, x - xOffset, y);
            }
            xOffset += canvasWidth;
        });
    }
    defaultFormatTimeCallback(seconds, pxPerSec) {
        if (seconds / 60 > 1) {
            const minutes = parseInt(seconds / 60, 10);
            seconds = parseInt(seconds % 60, 10);
            seconds = seconds < 10 ? '0' + seconds : seconds;
            return `${minutes}:${seconds}`;
        }
        return Math.round(seconds * 1000) / 1000;
    }
    defaultTimeInterval(pxPerSec) {
        if (pxPerSec >= 25) {
            return 1;
        }
        else if (pxPerSec * 5 >= 25) {
            return 5;
        }
        else if (pxPerSec * 15 >= 25) {
            return 15;
        }
        return Math.ceil(0.5 / pxPerSec) * 60;
    }
    defaultPrimaryLabelInterval(pxPerSec) {
        if (pxPerSec >= 25) {
            return 10;
        }
        else if (pxPerSec * 5 >= 25) {
            return 6;
        }
        else if (pxPerSec * 15 >= 25) {
            return 4;
        }
        return 4;
    }
    defaultSecondaryLabelInterval(pxPerSec) {
        if (pxPerSec >= 25) {
            return 5;
        }
        else if (pxPerSec * 5 >= 25) {
            return 2;
        }
        else if (pxPerSec * 15 >= 25) {
            return 2;
        }
        return 2;
    }
}

function defaultTimeFormatter(seconds) {
    const secondsAbs = Math.abs(seconds);
    const h = Math.floor(secondsAbs / 3600);
    const m = Math.floor((secondsAbs % 3600) / 60);
    const s = Math.floor(secondsAbs % 60);
    let formattedTime = h > 0 ? (h < 10 ? `0${h}:` : `${h}:`) : "";
    formattedTime += m < 10 ? `0${m}:` : `${m}:`;
    formattedTime += s < 10 ? `0${s}` : `${s}`;
    return seconds >= 0 ? formattedTime : "-" + formattedTime;
}
const defaultTimelineOptions = {
    notchPercentHeight: 60,
    height: 12,
    fontSize: 10,
    primaryLabelInterval: 10,
    secondaryLabelInterval: 0,
    formatTimeCallback: defaultTimeFormatter,
};
const TimelinePlugin$1 = TimelinePlugin;

function getId(prefix) {
    if (prefix === undefined) {
        prefix = 'wavesurfer_';
    }
    return (prefix +
        Math.random()
            .toString(32)
            .substring(2));
}

function max(values) {
    let largest = -Infinity;
    Object.keys(values).forEach(i => {
        if (values[i] > largest) {
            largest = values[i];
        }
    });
    return largest;
}

function min(values) {
    let smallest = Number(Infinity);
    Object.keys(values).forEach(i => {
        if (values[i] < smallest) {
            smallest = values[i];
        }
    });
    return smallest;
}

function absMax(values) {
    const max$1 = max(values);
    const min$1 = min(values);
    return -min$1 > max$1 ? -min$1 : max$1;
}

class Observer {
    constructor() {
        this._disabledEventEmissions = [];
        this.handlers = null;
    }
    on(event, fn) {
        if (!this.handlers) {
            this.handlers = {};
        }
        let handlers = this.handlers[event];
        if (!handlers) {
            handlers = this.handlers[event] = [];
        }
        handlers.push(fn);
        return {
            name: event,
            callback: fn,
            un: (e, fn) => this.un(e, fn)
        };
    }
    un(event, fn) {
        if (!this.handlers) {
            return;
        }
        const handlers = this.handlers[event];
        let i;
        if (handlers) {
            if (fn) {
                for (i = handlers.length - 1; i >= 0; i--) {
                    if (handlers[i] == fn) {
                        handlers.splice(i, 1);
                    }
                }
            }
            else {
                handlers.length = 0;
            }
        }
    }
    unAll() {
        this.handlers = null;
    }
    once(event, handler) {
        const fn = (...args) => {
            handler.apply(this, args);
            setTimeout(() => {
                this.un(event, fn);
            }, 0);
        };
        return this.on(event, fn);
    }
    setDisabledEventEmissions(eventNames) {
        this._disabledEventEmissions = eventNames;
    }
    _isDisabledEventEmission(event) {
        return this._disabledEventEmissions && this._disabledEventEmissions.includes(event);
    }
    fireEvent(event, ...args) {
        if (!this.handlers || this._isDisabledEventEmission(event)) {
            return;
        }
        const handlers = this.handlers[event];
        handlers &&
            handlers.forEach(fn => {
                fn(...args);
            });
    }
}

function style(el, styles) {
    Object.keys(styles).forEach(prop => {
        if (el.style[prop] !== styles[prop]) {
            el.style[prop] = styles[prop];
        }
    });
    return el;
}

var reqAnimationFrame = (window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    ((callback, element) => setTimeout(callback, 1000 / 60))).bind(window);

function frame(func) {
    return (...args) => reqAnimationFrame(() => func(...args));
}

function clamp(val, min, max) {
    return Math.min(Math.max(min, val), max);
}

class Drawer extends Observer {
    constructor(container, params) {
        super();
        this.container = container;
        this.params = params;
        this.width = 0;
        this.height = params.height * this.params.pixelRatio;
        this.lastPos = 0;
        this.wrapper = null;
    }
    style(el, styles) {
        return style(el, styles);
    }
    createWrapper() {
        this.wrapper = this.container.appendChild(document.createElement('wave'));
        this.style(this.wrapper, {
            display: 'block',
            position: 'relative',
            userSelect: 'none',
            webkitUserSelect: 'none',
            height: this.params.height + 'px'
        });
        if (this.params.fillParent || this.params.scrollParent) {
            this.style(this.wrapper, {
                width: '100%',
                overflowX: this.params.hideScrollbar ? 'hidden' : 'auto',
                overflowY: 'hidden'
            });
        }
        this.setupWrapperEvents();
    }
    handleEvent(e, noPrevent) {
        !noPrevent && e.preventDefault();
        const clientX = e.targetTouches
            ? e.targetTouches[0].clientX
            : e.clientX;
        const bbox = this.wrapper.getBoundingClientRect();
        const nominalWidth = this.width;
        const parentWidth = this.getWidth();
        let progress;
        if (!this.params.fillParent && nominalWidth < parentWidth) {
            progress =
                (this.params.rtl ? bbox.right - clientX : clientX - bbox.left) *
                    (this.params.pixelRatio / nominalWidth) || 0;
        }
        else {
            progress =
                ((this.params.rtl
                    ? bbox.right - clientX
                    : clientX - bbox.left) +
                    this.wrapper.scrollLeft) /
                    this.wrapper.scrollWidth || 0;
        }
        return clamp(progress, 0, 1);
    }
    setupWrapperEvents() {
        this.wrapper.addEventListener('click', e => {
            const scrollbarHeight = this.wrapper.offsetHeight - this.wrapper.clientHeight;
            if (scrollbarHeight !== 0) {
                const bbox = this.wrapper.getBoundingClientRect();
                if (e.clientY >= bbox.bottom - scrollbarHeight) {
                    return;
                }
            }
            if (this.params.interact) {
                this.fireEvent('click', e, this.handleEvent(e));
            }
        });
        this.wrapper.addEventListener('dblclick', e => {
            if (this.params.interact) {
                this.fireEvent('dblclick', e, this.handleEvent(e));
            }
        });
        this.wrapper.addEventListener('scroll', e => this.fireEvent('scroll', e));
    }
    drawPeaks(peaks, length, start, end) {
        if (!this.setWidth(length)) {
            this.clearWave();
        }
        this.params.barWidth
            ? this.drawBars(peaks, 0, start, end)
            : this.drawWave(peaks, 0, start, end);
    }
    resetScroll() {
        if (this.wrapper !== null) {
            this.wrapper.scrollLeft = 0;
        }
    }
    recenter(percent) {
        const position = this.wrapper.scrollWidth * percent;
        this.recenterOnPosition(position, true);
    }
    recenterOnPosition(position, immediate) {
        const scrollLeft = this.wrapper.scrollLeft;
        const half = ~~(this.wrapper.clientWidth / 2);
        const maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;
        let target = position - half;
        let offset = target - scrollLeft;
        if (maxScroll == 0) {
            return;
        }
        if (!immediate && -half <= offset && offset < half) {
            let rate = this.params.autoCenterRate;
            rate /= half;
            rate *= maxScroll;
            offset = Math.max(-rate, Math.min(rate, offset));
            target = scrollLeft + offset;
        }
        target = Math.max(0, Math.min(maxScroll, target));
        if (target != scrollLeft) {
            this.wrapper.scrollLeft = target;
        }
    }
    getScrollX() {
        let x = 0;
        if (this.wrapper) {
            const pixelRatio = this.params.pixelRatio;
            x = Math.round(this.wrapper.scrollLeft * pixelRatio);
            if (this.params.scrollParent) {
                const maxScroll = ~~(this.wrapper.scrollWidth * pixelRatio -
                    this.getWidth());
                x = Math.min(maxScroll, Math.max(0, x));
            }
        }
        return x;
    }
    getWidth() {
        return Math.round(this.container.clientWidth * this.params.pixelRatio);
    }
    setWidth(width) {
        if (this.width == width) {
            return false;
        }
        this.width = width;
        if (this.params.fillParent || this.params.scrollParent) {
            this.style(this.wrapper, {
                width: ''
            });
        }
        else {
            this.style(this.wrapper, {
                width: ~~(this.width / this.params.pixelRatio) + 'px'
            });
        }
        this.updateSize();
        return true;
    }
    setHeight(height) {
        if (height == this.height) {
            return false;
        }
        this.height = height;
        this.style(this.wrapper, {
            height: ~~(this.height / this.params.pixelRatio) + 'px'
        });
        this.updateSize();
        return true;
    }
    progress(progress) {
        const minPxDelta = 1 / this.params.pixelRatio;
        const pos = Math.round(progress * this.width) * minPxDelta;
        if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {
            this.lastPos = pos;
            if (this.params.scrollParent && this.params.autoCenter) {
                const newPos = ~~(this.wrapper.scrollWidth * progress);
                this.recenterOnPosition(newPos, this.params.autoCenterImmediately);
            }
            this.updateProgress(pos);
        }
    }
    destroy() {
        this.unAll();
        if (this.wrapper) {
            if (this.wrapper.parentNode == this.container) {
                this.container.removeChild(this.wrapper);
            }
            this.wrapper = null;
        }
    }
    updateCursor() { }
    updateSize() { }
    drawBars(peaks, channelIndex, start, end) { }
    drawWave(peaks, channelIndex, start, end) { }
    clearWave() { }
    updateProgress(position) { }
}

class CanvasEntry {
    constructor() {
        this.wave = null;
        this.waveCtx = null;
        this.progress = null;
        this.progressCtx = null;
        this.start = 0;
        this.end = 1;
        this.id = getId(typeof this.constructor.name !== 'undefined'
            ? this.constructor.name.toLowerCase() + '_'
            : 'canvasentry_');
        this.canvasContextAttributes = {};
    }
    initWave(element) {
        this.wave = element;
        this.waveCtx = this.wave.getContext('2d', this.canvasContextAttributes);
    }
    initProgress(element) {
        this.progress = element;
        this.progressCtx = this.progress.getContext('2d', this.canvasContextAttributes);
    }
    updateDimensions(elementWidth, totalWidth, width, height) {
        this.start = this.wave.offsetLeft / totalWidth || 0;
        this.end = this.start + elementWidth / totalWidth;
        this.wave.width = width;
        this.wave.height = height;
        let elementSize = { width: elementWidth + 'px' };
        style(this.wave, elementSize);
        if (this.hasProgressCanvas) {
            this.progress.width = width;
            this.progress.height = height;
            style(this.progress, elementSize);
        }
    }
    clearWave() {
        this.waveCtx.clearRect(0, 0, this.waveCtx.canvas.width, this.waveCtx.canvas.height);
        if (this.hasProgressCanvas) {
            this.progressCtx.clearRect(0, 0, this.progressCtx.canvas.width, this.progressCtx.canvas.height);
        }
    }
    setFillStyles(waveColor, progressColor) {
        this.waveCtx.fillStyle = waveColor;
        if (this.hasProgressCanvas) {
            this.progressCtx.fillStyle = progressColor;
        }
    }
    fillRects(x, y, width, height, radius) {
        this.fillRectToContext(this.waveCtx, x, y, width, height, radius);
        if (this.hasProgressCanvas) {
            this.fillRectToContext(this.progressCtx, x, y, width, height, radius);
        }
    }
    fillRectToContext(ctx, x, y, width, height, radius) {
        if (!ctx) {
            return;
        }
        if (radius) {
            this.drawRoundedRect(ctx, x, y, width, height, radius);
        }
        else {
            ctx.fillRect(x, y, width, height);
        }
    }
    drawRoundedRect(ctx, x, y, width, height, radius) {
        if (height === 0) {
            return;
        }
        if (height < 0) {
            height *= -1;
            y -= height;
        }
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
    }
    drawLines(peaks, absmax, halfH, offsetY, start, end) {
        this.drawLineToContext(this.waveCtx, peaks, absmax, halfH, offsetY, start, end);
        if (this.hasProgressCanvas) {
            this.drawLineToContext(this.progressCtx, peaks, absmax, halfH, offsetY, start, end);
        }
    }
    drawLineToContext(ctx, peaks, absmax, halfH, offsetY, start, end) {
        if (!ctx) {
            return;
        }
        const length = peaks.length / 2;
        const first = Math.round(length * this.start);
        const last = Math.round(length * this.end) + 1;
        const canvasStart = first;
        const canvasEnd = last;
        const scale = this.wave.width / (canvasEnd - canvasStart - 1);
        const halfOffset = halfH + offsetY;
        const absmaxHalf = absmax / halfH;
        ctx.beginPath();
        ctx.moveTo((canvasStart - first) * scale, halfOffset);
        ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart] || 0) / absmaxHalf));
        let i, peak, h;
        for (i = canvasStart; i < canvasEnd; i++) {
            peak = peaks[2 * i] || 0;
            h = Math.round(peak / absmaxHalf);
            ctx.lineTo((i - first) * scale + this.halfPixel, halfOffset - h);
        }
        let j = canvasEnd - 1;
        for (j; j >= canvasStart; j--) {
            peak = peaks[2 * j + 1] || 0;
            h = Math.round(peak / absmaxHalf);
            ctx.lineTo((j - first) * scale + this.halfPixel, halfOffset - h);
        }
        ctx.lineTo((canvasStart - first) * scale, halfOffset -
            Math.round((peaks[2 * canvasStart + 1] || 0) / absmaxHalf));
        ctx.closePath();
        ctx.fill();
    }
    destroy() {
        this.waveCtx = null;
        this.wave = null;
        this.progressCtx = null;
        this.progress = null;
    }
    getImage(format, quality, type) {
        if (type === 'blob') {
            return new Promise(resolve => {
                this.wave.toBlob(resolve, format, quality);
            });
        }
        else if (type === 'dataURL') {
            return this.wave.toDataURL(format, quality);
        }
    }
}

class MultiCanvas extends Drawer {
    constructor(container, params) {
        super(container, params);
        this.maxCanvasWidth = params.maxCanvasWidth;
        this.maxCanvasElementWidth = Math.round(params.maxCanvasWidth / params.pixelRatio);
        this.hasProgressCanvas = params.waveColor != params.progressColor;
        this.halfPixel = 0.5 / params.pixelRatio;
        this.canvases = [];
        this.progressWave = null;
        this.EntryClass = CanvasEntry;
        this.canvasContextAttributes = params.drawingContextAttributes;
        this.overlap = 2 * Math.ceil(params.pixelRatio / 2);
        this.barRadius = params.barRadius || 0;
    }
    init() {
        this.createWrapper();
        this.createElements();
    }
    createElements() {
        this.progressWave = this.wrapper.appendChild(this.style(document.createElement('wave'), {
            position: 'absolute',
            zIndex: 3,
            left: 0,
            top: 0,
            bottom: 0,
            overflow: 'hidden',
            width: '0',
            display: 'none',
            boxSizing: 'border-box',
            borderRightStyle: 'solid',
            pointerEvents: 'none'
        }));
        this.addCanvas();
        this.updateCursor();
    }
    updateCursor() {
        this.style(this.progressWave, {
            borderRightWidth: this.params.cursorWidth + 'px',
            borderRightColor: this.params.cursorColor
        });
    }
    updateSize() {
        const totalWidth = Math.round(this.width / this.params.pixelRatio);
        const requiredCanvases = Math.ceil(totalWidth / (this.maxCanvasElementWidth + this.overlap));
        while (this.canvases.length < requiredCanvases) {
            this.addCanvas();
        }
        while (this.canvases.length > requiredCanvases) {
            this.removeCanvas();
        }
        let canvasWidth = this.maxCanvasWidth + this.overlap;
        const lastCanvas = this.canvases.length - 1;
        this.canvases.forEach((entry, i) => {
            if (i == lastCanvas) {
                canvasWidth = this.width - this.maxCanvasWidth * lastCanvas;
            }
            this.updateDimensions(entry, canvasWidth, this.height);
            entry.clearWave();
        });
    }
    addCanvas() {
        const entry = new this.EntryClass();
        entry.canvasContextAttributes = this.canvasContextAttributes;
        entry.hasProgressCanvas = this.hasProgressCanvas;
        entry.halfPixel = this.halfPixel;
        const leftOffset = this.maxCanvasElementWidth * this.canvases.length;
        entry.initWave(this.wrapper.appendChild(this.style(document.createElement('canvas'), {
            position: 'absolute',
            zIndex: 2,
            left: leftOffset + 'px',
            top: 0,
            bottom: 0,
            height: '100%',
            pointerEvents: 'none'
        })));
        if (this.hasProgressCanvas) {
            entry.initProgress(this.progressWave.appendChild(this.style(document.createElement('canvas'), {
                position: 'absolute',
                left: leftOffset + 'px',
                top: 0,
                bottom: 0,
                height: '100%'
            })));
        }
        this.canvases.push(entry);
    }
    removeCanvas() {
        let lastEntry = this.canvases[this.canvases.length - 1];
        lastEntry.wave.parentElement.removeChild(lastEntry.wave);
        if (this.hasProgressCanvas) {
            lastEntry.progress.parentElement.removeChild(lastEntry.progress);
        }
        if (lastEntry) {
            lastEntry.destroy();
            lastEntry = null;
        }
        this.canvases.pop();
    }
    updateDimensions(entry, width, height) {
        const elementWidth = Math.round(width / this.params.pixelRatio);
        const totalWidth = Math.round(this.width / this.params.pixelRatio);
        entry.updateDimensions(elementWidth, totalWidth, width, height);
        this.style(this.progressWave, { display: 'block' });
    }
    clearWave() {
        frame(() => {
            this.canvases.forEach(entry => entry.clearWave());
        })();
    }
    drawBars(peaks, channelIndex, start, end) {
        return this.prepareDraw(peaks, channelIndex, start, end, ({ absmax, hasMinVals, height, offsetY, halfH, peaks, channelIndex: ch }) => {
            if (start === undefined) {
                return;
            }
            const peakIndexScale = hasMinVals ? 2 : 1;
            const length = peaks.length / peakIndexScale;
            const bar = this.params.barWidth * this.params.pixelRatio;
            const gap = this.params.barGap === null
                ? Math.max(this.params.pixelRatio, ~~(bar / 2))
                : Math.max(this.params.pixelRatio, this.params.barGap * this.params.pixelRatio);
            const step = bar + gap;
            const scale = length / this.width;
            const first = start;
            const last = end;
            let i = first;
            for (i; i < last; i += step) {
                const peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
                let h = Math.round((peak / absmax) * halfH);
                if (h == 0 && this.params.barMinHeight)
                    h = this.params.barMinHeight;
                this.fillRect(i + this.halfPixel, halfH - h + offsetY, bar + this.halfPixel, h * 2, this.barRadius, ch);
            }
        });
    }
    drawWave(peaks, channelIndex, start, end) {
        return this.prepareDraw(peaks, channelIndex, start, end, ({ absmax, hasMinVals, height, offsetY, halfH, peaks, channelIndex }) => {
            if (!hasMinVals) {
                const reflectedPeaks = [];
                const len = peaks.length;
                let i = 0;
                for (i; i < len; i++) {
                    reflectedPeaks[2 * i] = peaks[i];
                    reflectedPeaks[2 * i + 1] = -peaks[i];
                }
                peaks = reflectedPeaks;
            }
            if (start !== undefined) {
                this.drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex);
            }
            this.fillRect(0, halfH + offsetY - this.halfPixel, this.width, this.halfPixel, this.barRadius, channelIndex);
        });
    }
    drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex) {
        const { waveColor, progressColor } = this.params.splitChannelsOptions.channelColors[channelIndex] || {};
        this.canvases.forEach((entry, i) => {
            this.setFillStyles(entry, waveColor, progressColor);
            entry.drawLines(peaks, absmax, halfH, offsetY, start, end);
        });
    }
    fillRect(x, y, width, height, radius, channelIndex) {
        const startCanvas = Math.floor(x / this.maxCanvasWidth);
        const endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1, this.canvases.length);
        let i = startCanvas;
        for (i; i < endCanvas; i++) {
            const entry = this.canvases[i];
            const leftOffset = i * this.maxCanvasWidth;
            const intersection = {
                x1: Math.max(x, i * this.maxCanvasWidth),
                y1: y,
                x2: Math.min(x + width, i * this.maxCanvasWidth + entry.wave.width),
                y2: y + height
            };
            if (intersection.x1 < intersection.x2) {
                const { waveColor, progressColor } = this.params.splitChannelsOptions.channelColors[channelIndex] || {};
                this.setFillStyles(entry, waveColor, progressColor);
                entry.fillRects(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1, radius);
            }
        }
    }
    hideChannel(channelIndex) {
        return this.params.splitChannels && this.params.splitChannelsOptions.filterChannels.includes(channelIndex);
    }
    prepareDraw(peaks, channelIndex, start, end, fn, drawIndex, normalizedMax) {
        return frame(() => {
            if (peaks[0] instanceof Array) {
                const channels = peaks;
                if (this.params.splitChannels) {
                    const filteredChannels = channels.filter((c, i) => !this.hideChannel(i));
                    if (!this.params.splitChannelsOptions.overlay) {
                        this.setHeight(Math.max(filteredChannels.length, 1) *
                            this.params.height *
                            this.params.pixelRatio);
                    }
                    let overallAbsMax;
                    if (this.params.splitChannelsOptions && this.params.splitChannelsOptions.relativeNormalization) {
                        overallAbsMax = max(channels.map((channelPeaks => absMax(channelPeaks))));
                    }
                    return channels.forEach((channelPeaks, i) => this.prepareDraw(channelPeaks, i, start, end, fn, filteredChannels.indexOf(channelPeaks), overallAbsMax));
                }
                peaks = channels[0];
            }
            if (this.hideChannel(channelIndex)) {
                return;
            }
            let absmax = 1 / this.params.barHeight;
            if (this.params.normalize) {
                absmax = normalizedMax === undefined ? absMax(peaks) : normalizedMax;
            }
            const hasMinVals = [].some.call(peaks, val => val < 0);
            const height = this.params.height * this.params.pixelRatio;
            const halfH = height / 2;
            let offsetY = height * drawIndex || 0;
            if (this.params.splitChannelsOptions && this.params.splitChannelsOptions.overlay) {
                offsetY = 0;
            }
            return fn({
                absmax: absmax,
                hasMinVals: hasMinVals,
                height: height,
                offsetY: offsetY,
                halfH: halfH,
                peaks: peaks,
                channelIndex: channelIndex
            });
        })();
    }
    setFillStyles(entry, waveColor = this.params.waveColor, progressColor = this.params.progressColor) {
        entry.setFillStyles(waveColor, progressColor);
    }
    getImage(format, quality, type) {
        if (type === 'blob') {
            return Promise.all(this.canvases.map(entry => {
                return entry.getImage(format, quality, type);
            }));
        }
        else if (type === 'dataURL') {
            let images = this.canvases.map(entry => entry.getImage(format, quality, type));
            return images.length > 1 ? images : images[0];
        }
    }
    updateProgress(position) {
        this.style(this.progressWave, { width: position + 'px' });
    }
}

const regionsContainerStyles = {
    position: "absolute",
    top: "0",
    left: "0",
    zIndex: "2",
    width: "100%",
    height: "100%",
};
const segmentHighlighterContainerStyles = {
    backgroundColor: "transparent",
    width: "100%",
    height: "100%",
    position: "absolute",
    top: "0",
    left: "0",
    zIndex: "4",
    display: "flex",
    pointerEvents: "none",
};
const opacity = "0.25";
const segmentHighlighterLeftStyles = {
    width: "0",
    height: "100%",
    backgroundColor: "black",
    opacity,
    transition: "width .25s linear",
};
const segmentHighlighterCenterStyles = {
    width: "0",
    height: "100%",
    backgroundColor: "transparent",
    transition: "width .25s linear",
};
const segmentHighlighterRightStyles = {
    flex: "0",
    height: "100%",
    backgroundColor: "black",
    opacity,
};
const waveStyles = {
    position: "absolute",
    zIndex: "3",
    left: "0",
    top: "0",
    bottom: "0",
    width: "0",
    display: "none",
    boxSizing: "border-box",
    pointerEvents: "none",
};

const util = WS__default.util;
class Drawer$1 extends MultiCanvas {
    constructor(container, params) {
        super(container, params);
        this.channels = [];
        this.currentPosition = 0;
        this.handleWindowResize = () => {
            this.fireEvent("redraw");
        };
        this.destroy = () => {
            window.removeEventListener("resize", this.handleWindowResize);
            this.destroyCursor();
        };
        this.container = container;
        this.params = params;
        window.addEventListener("resize", this.handleWindowResize);
        this.hasProgressCanvas = true;
    }
    init() {
        super.createWrapper();
        this.createElements();
    }
    createElements() {
        this.progressWave = this.wrapper.appendChild(this.style(document.createElement("wave"), waveStyles));
        this.addCanvas();
        this.createCursor();
        this.wrapper.style.backgroundColor = this.params.backgroundColor;
        this.container.style.position = "relative";
        this.container.style.backgroundColor = "transparent";
    }
    drawBars(peaks, channelIndex, start, end) {
        if (start === undefined || end === undefined) {
            return;
        }
        return util.frame(this.prepareForDraw.bind(this))(peaks, start, end);
    }
    preparePeaks(peaks) {
        const hasMinVals = peaks.some((channelPeaks) => channelPeaks.some(val => val < 0));
        if (hasMinVals) {
            return peaks.map(peaks => peaks.filter((_, i) => !(i % 2)));
        }
        return peaks;
    }
    prepareBars({ start, end, step, peaks, }) {
        const scale = peaks[0].length / this.width;
        const bars = [...new Array(peaks.length)].map(() => []);
        let i = start;
        for (i; i < end; i += step) {
            const peakIndex = Math.floor(i * scale);
            const heights = peaks.map(p => this.getPeakAverageValue(p, peakIndex, step));
            heights.forEach((h, i) => bars[i].push(h));
        }
        if (this.params.normalize) {
            return this.normalizeBars(bars);
        }
        return bars;
    }
    prepareProgressBars({ start, end, step, }) {
        let i = start;
        const heights = [];
        for (i; i < end; i += step) {
            heights.push(0.5);
        }
        return [heights];
    }
    normalizeBars(bars) {
        return bars.map(barsForChannel => {
            const max = util.max(barsForChannel);
            return barsForChannel.map(val => (this.params.barHeight * val) / max);
        });
    }
    renderBars({ bars, start, step, }) {
        const height = this.params.height * this.params.pixelRatio;
        const halfH = height / 2;
        const barWidth = Math.floor(this.params.barWidth * this.params.pixelRatio);
        let channels = Array.from(bars.keys());
        bars[0].forEach((_, index) => {
            const i = start + index * step;
            channels = channels.sort((a, b) => bars[b][index] - bars[a][index]);
            channels.forEach(channelIndex => {
                let h = Math.round(bars[channelIndex][index] * halfH);
                if (h === 0 && this.params.barMinHeight) {
                    h = this.params.barMinHeight;
                }
                this.fillRect(channelIndex, i + this.halfPixel, this.height - h * 2, barWidth + this.halfPixel, h * 2, 0);
            });
        });
    }
    prepareForDraw(peaks, start, end) {
        const bar = this.params.barWidth * this.params.pixelRatio;
        const gap = this.params.barGap === null || this.params.barGap === undefined
            ? Math.max(this.params.pixelRatio, Math.floor(bar / 2))
            : Math.max(this.params.pixelRatio, this.params.barGap * this.params.pixelRatio);
        const step = Math.floor(bar + gap);
        if (!peaks || !peaks.length) {
            const bars = this.prepareProgressBars({
                start,
                end,
                step,
            });
            this.renderBars({ bars, start, step });
        }
        else {
            const processedPeaks = this.preparePeaks(peaks);
            const bars = this.prepareBars({
                start,
                end,
                step,
                peaks: processedPeaks,
            });
            this.renderBars({ bars, start, step });
        }
    }
    fillRect(channelIndex, x, y, width, height, radius) {
        const startCanvas = Math.floor(x / this.maxCanvasWidth);
        const endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1, this.canvases.length);
        let i = startCanvas;
        for (i; i < endCanvas; i++) {
            const entry = this.canvases[i];
            const leftOffset = i * this.maxCanvasWidth;
            const intersection = {
                x1: Math.max(x, i * this.maxCanvasWidth),
                y1: y,
                x2: Math.min(x + width, i * this.maxCanvasWidth + entry.wave.width),
                y2: y + height,
            };
            if (intersection.x1 < intersection.x2) {
                this.setFillStyles(entry, channelIndex);
                entry.fillRects(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1, radius);
            }
        }
    }
    setFillStyles(entry, channelIndex) {
        const channel = this.channels[channelIndex];
        const color = (channel && channel.color) || this.params.waveColor;
        const progressColor = (channel && channel.progressColor) ||
            (channel && channel.color) ||
            this.params.progressColor;
        entry.setFillStyles(color, progressColor);
    }
    getPeakAverageValue(peaks, index, radius) {
        if (index < 0) {
            return 0;
        }
        let sum = 0;
        let weightSum = 0;
        for (let i = Math.max(0, index - radius); i <= Math.min(peaks.length - 1, index + radius); i++) {
            const w = this.weightDistributionFunction(i - index, radius / 2);
            sum += w * peaks[i];
            weightSum += w;
        }
        if (weightSum === 0) {
            return 0;
        }
        const average = sum / weightSum;
        return average;
    }
    weightDistributionFunction(x, deviation) {
        if (!deviation) {
            return 1;
        }
        return Math.exp(-1 * Math.pow(x / deviation, 2));
    }
    createCursor() {
        if (this.progressWave) {
            if (this.params.progressBackgroundColor) {
                this.style(this.progressWave, {
                    backgroundColor: this.params.progressBackgroundColor,
                });
            }
            this.cursorCanvas = this.style(document.createElement("canvas"), {
                position: "absolute",
                top: "0",
                left: "0",
                height: "100%",
                width: "100%",
                zIndex: "5",
                pointerEvents: "none",
            });
            this.cursorCanvas.classList.add("twilio-player-cursor");
            this.container.appendChild(this.cursorCanvas);
            const ctx = this.cursorCanvas.getContext("2d");
            if (ctx) {
                ctx.imageSmoothingEnabled = false;
                this.drawCursor(0);
            }
        }
    }
    destroyCursor() {
        var _a;
        if (this.cursorCanvas) {
            (_a = this.cursorCanvas.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.cursorCanvas);
            this.cursorCanvas = undefined;
        }
    }
    updateProgress(position) {
        position = Math.floor(position);
        if (this.progressWave) {
            this.style(this.progressWave, { width: position + "px" });
        }
        this.drawCursor(position);
    }
    drawCursor(position) {
        if (this.cursorCanvas) {
            const ctx = this.cursorCanvas.getContext("2d");
            if (ctx && this.cursorCanvas) {
                ctx.imageSmoothingEnabled = false;
                this.cursorCanvas.width = this.container.clientWidth;
                this.cursorCanvas.height = this.container.clientHeight;
                ctx.clearRect(0, 0, this.cursorCanvas.width, this.cursorCanvas.height);
                ctx.fillStyle = this.params.cursorColor;
                ctx.beginPath();
                ctx.moveTo(position - 3 * this.params.cursorWidth + 0.5, -0.5);
                ctx.lineTo(position + 0.5, 8.5);
                ctx.lineTo(position + 0.5, this.cursorCanvas.height + 0.5);
                ctx.lineTo(position + this.params.cursorWidth + 0.5, this.cursorCanvas.height + 0.5);
                ctx.lineTo(position + this.params.cursorWidth + 0.5, 8.5);
                ctx.lineTo(position + 4 * this.params.cursorWidth + 0.5, -0.5);
                ctx.fill();
            }
        }
    }
}

function playbackRateToNumeral(rate) {
    if (rate >= 5) {
        return 5;
    }
    if (rate <= 0.25) {
        return 0.25;
    }
    if (rate > 0.25 && rate < 5) {
        return rate;
    }
    switch (rate) {
        case "very_fast":
            return 1.5;
        case "fast":
            return 1.25;
        case "slow":
            return 0.75;
        case "very_slow":
            return 0.5;
        default:
            return 1.0;
    }
}

const WaveSurfer = WS__default;
const style$1 = WS__default.util.style;
const defaultPlayerOptions = {
    backgroundColor: "#FFFFFF",
    progressBackgroundColor: "rgba(184, 216, 190, 0.5)",
    barWidth: 4,
    barHeight: 0.8,
    barGap: 2,
    cursorWidth: 2,
    cursorColor: "#000",
    height: 56,
    hideScrollbar: true,
    progressColor: "#14972e",
    waveColor: "#14972e",
    regionColor: "#FEE1CC",
};
class PlayerCore extends eventemitter3.EventEmitter {
    constructor(container, opt = {}) {
        super();
        this.isHotLoading = false;
        this.mediaElement = null;
        this.wsHandleAudioProcess = (currentTime) => {
            this.emit("process", currentTime);
        };
        this.wsHandleError = (error) => {
            this.emit("error", error);
        };
        this.wsHandleFinish = () => {
            this.emit("finish");
        };
        this.wsHandlePlay = () => {
            this.emit("play");
        };
        this.wsHandlePause = () => {
            this.emit("pause");
        };
        this.wsHandleReady = () => {
            var _a;
            this.isHotLoading = false;
            const duration = (_a = this.ws) === null || _a === void 0 ? void 0 : _a.getDuration();
            if (duration && this.ws && this.ws.timeline && this.ws.timeline.params) {
                this.ws.timeline.params.timeInterval =
                    Math.floor(duration / 60) + (duration % 60) / 60;
            }
            this.waveform = this.waveformContainer.querySelector("wave");
            this.waveform.appendChild(this.regionsContainer);
            this.emit("ready");
            this.renderSegmentHighlight();
        };
        this.wsHandleRedraw = () => {
            this.emit("redraw");
        };
        this.wsHandleSeek = (progress) => {
            this.emit("seek", progress);
        };
        this.renderSegmentHighlight = () => {
            if (this.currentSegmentOffset === undefined ||
                this.currentSegmentDuration === undefined ||
                !this.ws) {
                this.segmentHighlighterLeft.style.width = "0";
                this.segmentHighlighterCenter.style.width = "0";
                this.segmentHighlighterRight.style.flex = "0";
                return;
            }
            const duration = this.ws.getDuration();
            const pxPerSec = this.container.clientWidth / duration;
            const width = Math.min(this.currentSegmentDuration, duration - this.currentSegmentOffset) * pxPerSec;
            const offset = this.currentSegmentOffset * pxPerSec;
            this.segmentHighlighterLeft.style.width = `${offset}px`;
            this.segmentHighlighterCenter.style.width = `${width}px`;
            this.segmentHighlighterRight.style.flex = "1";
        };
        this.timelineFormatter = (seconds) => {
            return defaultTimeFormatter(seconds - (this.currentSegmentOffset || 0));
        };
        this.destroy = () => {
            if (this.ws) {
                this.ws.drawer.destroy();
                this.ws.destroy();
                while (this.timelineContainer.lastChild) {
                    this.timelineContainer.removeChild(this.timelineContainer.lastChild);
                }
                Array.from(this.waveformContainer.childNodes).forEach(el => {
                    if (el.nodeName === "WAVE") {
                        this.waveformContainer.removeChild(el);
                    }
                });
                this.ws = undefined;
            }
        };
        this.load = (url, channels = [], ops) => {
            this.destroy();
            this.isHotLoading = false;
            if (!(ops === null || ops === void 0 ? void 0 : ops.isAuthenticatedEndpoint)) {
                this.mediaElement = document.createElement("audio");
                this.mediaElement.setAttribute("preload", "metadata");
                this.mediaElement.src = url;
                this.container.prepend(this.mediaElement);
            }
            const ws = this.initWS();
            ws.drawer.channels = channels;
            const peaks = ws.drawer.channels.map(c => c.peaks || []);
            const playerUrlTarget = this.mediaElement || url;
            if (!peaks.length || peaks.some(p => !p.length)) {
                ws.load(playerUrlTarget);
            }
            else {
                ws.load(playerUrlTarget, peaks);
            }
        };
        this.hotLoad = (url) => {
            return new Promise((resolve, reject) => {
                if (!this.ws) {
                    reject(new Error("Unable to hotload, because player is either loading or not initialized"));
                    return;
                }
                if (!this.mediaElement) {
                    reject(new Error("Unable to hotload, because media element does not exist"));
                    return;
                }
                const time = this.ws.getCurrentTime();
                const isPlaying = this.isPlaying();
                const rate = this.ws.getPlaybackRate();
                this.isHotLoading = true;
                const onCanPlay = () => {
                    if (this.ws && this.mediaElement) {
                        this.ws.backend.seekTo(time);
                        this.ws.setPlaybackRate(rate);
                        if (isPlaying) {
                            this.ws.backend.play();
                        }
                        this.mediaElement.removeEventListener("canplay", onCanPlay);
                        this.isHotLoading = false;
                        this.emit("hot-load");
                        resolve(undefined);
                    }
                };
                this.mediaElement.addEventListener("canplay", onCanPlay);
                this.mediaElement.src = url;
            });
        };
        this.play = (start, end) => {
            if (!this.ws || this.isHotLoading) {
                return Promise.reject(new Error("Unable to play, because player is either loading or not initialized"));
            }
            return this.ws.play(start !== undefined
                ? start + (this.currentSegmentOffset || 0)
                : undefined, end !== undefined ? end + (this.currentSegmentOffset || 0) : undefined);
        };
        this.pause = () => {
            if (!this.ws || this.isHotLoading) {
                return Promise.reject(new Error("Unable to pause, because player is either loading or not initialized"));
            }
            return this.ws.pause() || Promise.resolve();
        };
        this.getCurrentTime = () => {
            if (this.ws) {
                return this.ws.getCurrentTime() - (this.currentSegmentOffset || 0);
            }
            return 0;
        };
        this.isPlaying = () => {
            if (this.ws) {
                return this.ws.isPlaying();
            }
            return false;
        };
        this.isReady = () => {
            if (this.ws) {
                return this.ws.isReady;
            }
            return false;
        };
        this.seekToSecond = (seconds, offsetFromSegment = true, recordingDuration) => {
            if (!this.ws || !this.isReady() || this.isHotLoading) {
                throw new Error("Unable to seek, because player is either loading or not initialized");
            }
            const offset = ((offsetFromSegment && this.currentSegmentOffset) || 0) + seconds;
            const totalDuration = recordingDuration || this.ws.getDuration();
            let seekAt = offset / totalDuration;
            if (isNaN(seekAt) || !(seekAt >= 0 && seekAt <= 1)) {
                console.warn(`seekAt value not in range [0,1]. Setting it to 0,Total Recording duration:recordingDuration: ${recordingDuration}, this.ws.getDuration():${this.ws.getDuration()},offset:${offset}, seekAt: ${seekAt}`);
                seekAt = 0;
            }
            return this.ws.seekTo(seekAt);
        };
        this.setCurrentSegment = (duration, offset) => {
            if (!this.ws) {
                throw new Error("Unable to set current segment, because player is either loading or not initialized");
            }
            const recordingDuration = this.ws.getDuration();
            if (!Number.isFinite(recordingDuration) ||
                (offset && offset > recordingDuration)) {
                console.warn("The offset of the current segment is longer than recording duration", offset, recordingDuration);
                offset = undefined;
                duration = undefined;
            }
            this.currentSegmentDuration = duration;
            this.currentSegmentOffset = offset;
            this.renderSegmentHighlight();
            this.seekToSecond(0, true, recordingDuration);
            if (this.ws.timeline) {
                this.ws.timeline.render();
            }
        };
        this.setPlaybackRate = (rate = 1.0) => {
            if (!this.ws) {
                throw new Error("Unable to seek, because player is either loading or not initialized");
            }
            this.ws.setPlaybackRate(playbackRateToNumeral(rate));
        };
        this.container = container;
        this.timelineContainer = document.createElement("div");
        this.waveformContainer = document.createElement("div");
        this.regionsContainer = style$1(document.createElement("div"), regionsContainerStyles);
        this.segmentHighlighterContainer = style$1(document.createElement("div"), segmentHighlighterContainerStyles);
        this.segmentHighlighterLeft = style$1(document.createElement("div"), segmentHighlighterLeftStyles);
        this.segmentHighlighterCenter = style$1(document.createElement("div"), segmentHighlighterCenterStyles);
        this.segmentHighlighterRight = style$1(document.createElement("div"), segmentHighlighterRightStyles);
        this.timelineContainer.setAttribute("class", "twilio-player-timeline");
        this.waveformContainer.setAttribute("class", "twilio-player-waveform");
        this.regionsContainer.setAttribute("class", "twilio-player-regions");
        this.segmentHighlighterContainer.setAttribute("class", "twilio-player-segments");
        this.segmentHighlighterContainer.appendChild(this.segmentHighlighterLeft);
        this.segmentHighlighterContainer.appendChild(this.segmentHighlighterCenter);
        this.segmentHighlighterContainer.appendChild(this.segmentHighlighterRight);
        this.waveformContainer.appendChild(this.segmentHighlighterContainer);
        container.appendChild(this.waveformContainer);
        container.appendChild(this.timelineContainer);
        const timelineOptions = {
            ...defaultTimelineOptions,
            ...opt.timeline,
            container: this.timelineContainer,
        };
        const plugins = [
            TimelinePlugin$1.create({
                ...timelineOptions,
                formatTimeCallback: this.timelineFormatter,
            }),
        ];
        const wsParams = {
            ...defaultPlayerOptions,
            container: this.waveformContainer,
            backend: "MediaElement",
            mediaType: "audio",
            normalize: true,
            plugins,
            removeMediaElementOnDestroy: true,
            renderer: Drawer$1,
            splitChannels: true,
            ...opt,
        };
        this.wsParams = wsParams;
    }
    initWS() {
        this.ws = WaveSurfer.create(this.wsParams);
        this.ws.on("pause", this.wsHandlePause);
        this.ws.on("play", this.wsHandlePlay);
        this.ws.on("ready", this.wsHandleReady);
        this.ws.on("seek", this.wsHandleSeek);
        this.ws.on("error", this.wsHandleError);
        this.ws.on("finish", this.wsHandleFinish);
        this.ws.on("audioprocess", this.wsHandleAudioProcess);
        this.ws.on("redraw", this.wsHandleRedraw);
        return this.ws;
    }
}

function removeUndefined(obj) {
    return Object.keys(obj).reduce((acc, key) => {
        if (obj[key] !== undefined) {
            acc[key] = obj[key];
        }
        return acc;
    }, {});
}

const Portal = (props) => reactDom.createPortal(props.children, props.node);

const MarkContext = React.createContext({
    segmentOffset: 0,
    pxPerSec: 0,
    containerWidth: 0,
    regionsContainer: null,
});
class Mark extends React.PureComponent {
    render() {
        const { children, offset, color, title } = this.props;
        return (React.createElement(MarkContext.Consumer, null, ({ pxPerSec, containerWidth, regionsContainer, segmentOffset }) => offset * pxPerSec <= containerWidth ? (React.createElement(React.Fragment, null,
            children && (React.createElement("div", { style: {
                    ...this.positionElementStyles(pxPerSec, containerWidth, this.props.offsetFromSegment ? segmentOffset : 0),
                    pointerEvents: "none",
                    zIndex: 6,
                } }, children)),
            regionsContainer && (React.createElement(Portal, { node: regionsContainer },
                React.createElement("div", { title: title, style: {
                        ...this.positionElementStyles(pxPerSec, containerWidth, this.props.offsetFromSegment ? segmentOffset : 0),
                        backgroundColor: color,
                    } }))))) : null));
    }
    positionElementStyles(pxPerSec, containerWidth, segmentOffset) {
        return {
            position: "absolute",
            top: "0",
            left: (this.props.offset + segmentOffset) * pxPerSec + "px",
            width: Math.min(this.props.duration * pxPerSec, containerWidth - (this.props.offset + segmentOffset) * pxPerSec) + "px",
            height: "100%",
        };
    }
}
Mark.defaultProps = {
    duration: 0,
    color: "transparent",
    offsetFromSegment: false,
};

class Player extends React.PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            isReady: false,
        };
        this.container = React.createRef();
        this.mediaElement = null;
        this.on = (event, fn) => {
            if (!this.core) {
                throw new Error("Cannot add listeners before Player is mounted");
            }
            return this.core.on(event, fn);
        };
        this.once = (event, fn) => {
            if (!this.core) {
                throw new Error("Cannot add listeners before Player is mounted");
            }
            return this.core.once(event, fn);
        };
        this.off = (event, fn) => {
            if (!this.core) {
                throw new Error("Cannot remove listeners before Player is mounted");
            }
            return this.core.off(event, fn);
        };
        this.getCurrentTime = () => {
            var _a;
            return (_a = this.core) === null || _a === void 0 ? void 0 : _a.getCurrentTime();
        };
        this.isPlaying = () => {
            var _a;
            return ((_a = this.core) === null || _a === void 0 ? void 0 : _a.isPlaying()) || false;
        };
        this.isReady = () => {
            var _a;
            return ((_a = this.core) === null || _a === void 0 ? void 0 : _a.isReady()) || false;
        };
        this.play = (start, end) => {
            if (!this.core) {
                throw new Error("Player.play() cannot be called before the component is mounted");
            }
            return this.core.play(start, end);
        };
        this.pause = () => {
            if (!this.core) {
                throw new Error("Player.pause() cannot be called before the component is mounted");
            }
            return this.core.pause();
        };
        this.seekToSecond = (seconds, offsetFromSegment = true) => {
            if (!this.core) {
                throw new Error("Player.seekToSecond() cannot be called before the component is mounted");
            }
            return this.core.seekToSecond(seconds, offsetFromSegment);
        };
        this.getCurrentSegment = () => {
            if (this.props.segments) {
                if (this.props.currentSegment) {
                    const segment = this.props.segments.find(s => s.id === this.props.currentSegment);
                    if (segment) {
                        return [segment.duration, segment.offset];
                    }
                }
                return [this.props.segments[0].duration, this.props.segments[0].offset];
            }
            return [0, 0];
        };
        this.onReady = () => {
            const [duration, offset] = this.getCurrentSegment();
            this.core.setCurrentSegment(duration, offset);
            if (this.props.onReady) {
                this.props.onReady(this);
            }
            this.setState({ isReady: true });
        };
        this.onError = (e) => {
            if (this.props.onError) {
                this.props.onError(e);
            }
        };
        this.onRedraw = () => {
            this.forceUpdate();
        };
        this.setPlaybackRate = (rate) => {
            return this.core.setPlaybackRate(rate);
        };
    }
    componentDidMount() {
        this.core = new PlayerCore(this.container.current, removeUndefined(this.props.options || {}));
        this.mediaElement = this.core.mediaElement;
        this.core.on("ready", this.onReady);
        this.core.on("redraw", this.onRedraw);
        this.core.on("error", this.onError);
        this.load();
    }
    componentWillUnmount() {
        this.core.destroy();
        this.core.removeAllListeners();
    }
    componentDidUpdate(prevProps) {
        if (prevProps.recordingUrl !== this.props.recordingUrl) {
            const url = new URL(prevProps.recordingUrl);
            const prevUrl = new URL(this.props.recordingUrl);
            if (url.origin + url.pathname === prevUrl.origin + prevUrl.pathname) {
                this.core.hotLoad(this.props.recordingUrl);
            }
            else {
                return this.load();
            }
        }
        if (prevProps.currentSegment !== this.props.currentSegment) {
            const [duration, offset] = this.getCurrentSegment();
            this.core.setCurrentSegment(duration, offset);
        }
        if (prevProps.playbackRate !== this.props.playbackRate) {
            this.setPlaybackRate(this.props.playbackRate);
        }
    }
    load() {
        var _a;
        if (this.state.isReady) {
            this.setState({ isReady: false });
        }
        this.core.load(this.props.recordingUrl, this.props.channels, { isAuthenticatedEndpoint: !!((_a = this.props.options) === null || _a === void 0 ? void 0 : _a.xhr) });
        this.core.setPlaybackRate(this.props.playbackRate);
    }
    render() {
        return (React.createElement("div", { ref: this.container, className: "twilio-player-container", style: { ...this.props.style, position: "relative" } },
            React.createElement("div", { className: "twilio-player-markings" }, this.state.isReady && this.container.current && this.core.ws && (React.createElement(MarkContext.Provider, { value: {
                    segmentOffset: this.getCurrentSegment()[1],
                    containerWidth: this.container.current.clientWidth,
                    pxPerSec: this.container.current.clientWidth /
                        this.core.ws.getDuration(),
                    regionsContainer: this.core.regionsContainer,
                } }, this.props.children)))));
    }
}

exports.Mark = Mark;
exports.Player = Player;
exports.defaultTimeFormatter = defaultTimeFormatter;
//# sourceMappingURL=index.js.map
