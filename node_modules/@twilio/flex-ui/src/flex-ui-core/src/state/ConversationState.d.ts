import { AggregatedDeliveryReceipt, Conversation, EmailRecipientDescriptor, Media, Message, Participant, User } from "@twilio/conversations";
import { Action, Dispatch } from "redux";
import { Channel } from "twilio-chat";
import { ConversationHelper } from "../ConversationHelper";
import { Paginator } from "./ChannelState";
import { ChatState } from "./ChatState";
export type ParticipantType = Map<string, ParticipantState>;
export type TransferWithNotes = {
    sid: string;
    channelSid: string;
    type: string;
    from: string;
    to: string;
    status: string;
    summary: string;
    reason: string;
    dateCreated: Date;
};
/**
 * A state of remote client in a Conversations.
 * @typedef {object} ParticipantState
 * @property {Participant} source - Represents the remote client in a Conversation. See structure [here](http://media.twiliocdn.com/sdk/js/conversations/releases/1.1.0/docs/Participant.html).
 * @property {string} friendlyName - It represents the friendly name of the remote client.
 * @property {boolean} online - It represents if the participant is online or not.
 * @memberof AppState
 */
export interface ParticipantState {
    readonly source: Participant;
    readonly friendlyName: string;
    readonly online: boolean;
}
type PendingMessage = Pick<Message, "media" | "dateCreated" | "conversation" | "author" | "index" | "type"> & {
    body: string | null;
    participantSid?: string;
    memberSid?: string;
    subject?: string;
    sid: null;
    channel?: Channel;
    timestamp?: Date;
    aggregatedDeliveryReceipt?: AggregatedDeliveryReceipt | null;
    attachedMedia?: Array<Media> | null;
};
export type MessageSource<CustomAttributesType extends undefined = undefined> = CustomAttributesType extends undefined ? (Message & {
    channel?: Channel;
    timestamp?: Date;
}) | PendingMessage : MessageWithCustomAttributes<CustomAttributesType>;
export type MessageWithCustomAttributes<CustomAttributesType extends undefined> = Omit<Message, "attributes"> & {
    attributes: CustomAttributesType;
};
export declare enum DeliveryStatus {
    Sent = "sent",
    Pending = "pending",
    Undelivered = "undelivered",
    Failed = "failed"
}
export type EmailMessageRecipientsType = Map<string, EmailRecipientDescriptor[]>;
/**
 * An object which represents a state of a single message.
 * @typedef {object} ChatState.MessageState
 * @property {boolean} isFromMe - Is the message from me.
 * @property {boolean} [isFromCCAIVirtualAgent] - Is the message from virtual agent
 * @property {Message} source - Represents the message object. See structure [here](http://media.twiliocdn.com/sdk/js/conversations/releases/1.1.0/docs/Message.html).
 * @property {boolean} groupWithNext - should the message be grouped with the next message.
 * @property {boolean} groupWithPrevious - should the message be grouped with the previous message.
 * @property {number} index - index of the message within the remote messages array.
 * @property {string} [authorName] - Represents the friendly name of the message author.
 * @property {boolean} [error] - If set to true, the message has failed to be delivered.
 */
export interface MessageState<CustomAttributesType extends undefined = undefined> {
    readonly isFromMe: boolean;
    readonly isFromCCAIVirtualAgent?: boolean;
    readonly source: MessageSource<CustomAttributesType>;
    readonly groupWithNext: boolean;
    readonly groupWithPrevious: boolean;
    readonly index: number;
    readonly authorName?: string;
    readonly isSending?: boolean;
    readonly error?: boolean;
    readonly bodyAttachment?: string;
    readonly deliveryStatus?: DeliveryStatus;
}
/**
 * An object which represents a state of a conversation.
 * @typedef {object} ConversationState
 * @property {Paginator} [currentPaginator] Paginator class to request messages on previous or next pages. See structure [here](https://media.twiliocdn.com/sdk/js/chat/releases/3.2.4/docs/Paginator.html).
 * @property {boolean} isLoadingMessages=false Indicates if messages are currently loading
 * @property {boolean} isLoadingParticipants=false Indicates if participants are currently loading
 * @property {boolean} isLoadingConversation=false Indicates if conversation is currently loading
 * @property {number} lastReadMessageIndex=0 Index of the last read message
 * @property {Map<string, ParticipantState>} participants Participants of the chat
 * @property {Array<MessageState>} messages=Map() Messages in the conversation
 * @property {Conversation} [source] Reference to the conversation. See structure [here](http://media.twiliocdn.com/sdk/js/conversations/releases/1.1.0/docs/Conversation.html).
 * @property {Array<ParticipantState>} typers Participants, who are currently typing a message
 * @property {boolean} errorWhileLoadingConversation=false Indicates if there was an error while loading a conversation
 * @memberof AppState
 */
export interface ConversationState {
    readonly currentPaginator?: Paginator<Message>;
    readonly isLoadingMessages: boolean;
    readonly isLoadingParticipants: boolean;
    readonly lastReadMessageIndex: number;
    readonly lastReadMessageByCurrentUserIndex: number;
    readonly listener?: ConversationListener;
    readonly participants: ParticipantType;
    readonly unreadMessages: MessageState[];
    readonly messages: MessageState[];
    readonly pendingMessages: MessageState[];
    readonly source?: Conversation;
    readonly typers: ParticipantState[];
    readonly isLoadingConversation: boolean;
    readonly errorWhileLoadingConversation: boolean;
    readonly showScrollDownBtn: boolean;
    readonly lastScrollPosition: number;
    readonly messageRecipients: EmailMessageRecipientsType;
    readonly isLoadingRecipients: boolean;
    readonly recipientsPaginator?: Paginator<EmailRecipientDescriptor>;
    readonly transfers: TransferWithNotes[];
}
export interface InitConversationPayload {
    conversation: Conversation;
    identity: string;
    listener: ConversationListener;
}
export type ConversationActionPayload = InitConversationPayload | ParticipantType | Paginator<Message> | Message | ParticipantState | string;
export interface ConversationAction extends Action {
    payload?: any;
    meta: {
        conversationSid: string;
        chatState?: ChatState;
    };
}
export declare const ACTION_ADDED_MESSAGE = "CONVERSATION_ADD_MESSAGE";
export declare const ACTION_ADDED_PARTICIPANT = "CONVERSATION_ADD_PARTICIPANT";
export declare const ACTION_USER_UPDATED = "CONVERSATION_USER_UPDATED";
export declare const ACTION_INIT_CONVERSATION = "CONVERSATION_INIT";
export declare const ACTION_UNLOAD_CONVERSATION = "CONVERSATION_UNLOAD";
export declare const ACTION_UNSUBSCRIBE_CONVERSATION = "ACTION_UNSUBSCRIBE_CONVERSATION";
export declare const ACTION_INIT_CONVERSATION_PARTICIPANTS = "CONVERSATION_INIT_PARTICIPANTS";
export declare const ACTION_CONSUME_MESSAGE = "ACTION_CONSUME_MESSAGE";
export declare const ACTION_LOAD_CONVERSATION_MESSAGES = "CONVERSATION_LOAD_MESSAGES";
export declare const ACTION_REMOVED_MESSAGE = "CONVERSATION_REMOVE_MESSAGE";
export declare const ACTION_REMOVED_PARTICIPANT = "CONVERSATION_REMOVE_PARTICIPANT";
export declare const ACTION_UPDATED_PARTICIPANT = "CONVERSATION_UPDATED_PARTICIPANT";
export declare const ACTION_UPDATED_MESSAGE = "CONVERSATION_UPDATE_MESSAGE";
export declare const ACTION_TYPING_STARTED = "CONVERSATION_TYPING_STARTED";
export declare const ACTION_TYPING_ENDED = "CONVERSATION_TYPING_ENDED";
export declare const ACTION_UPDATE_CONVERSATION = "CONVERSATION_UPDATE";
export declare const ACTION_LOAD_CONVERSATION = "CONVERSATION_LOAD";
export declare const ACTION_ADD_PENDING_MEDIA_MESSAGE = "ACTION_ADD_PENDING_MEDIA_MESSAGE";
export declare const ACTION_REMOVE_PENDING_MEDIA_MESSAGE = "ACTION_REMOVE_PENDING_MEDIA_MESSAGE";
export declare const ACTION_MEDIA_MESSAGE_REJECTED = "ACTION_MEDIA_MESSAGE_REJECTED";
export declare const ACTION_UPDATE_MESSAGE_STATE = "ACTION_UPDATE_MESSAGE_STATE";
export declare const ACTION_SHOW_SCROLL_DOWN_BUTTON = "SHOW_SCROLL_DOWN_BUTTON";
export declare const ACTION_UPDATE_LAST_SCROLL_POSITION = "UPDATE_LAST_SCROLL_POSITION";
export declare const ACTION_LOAD_CONVERSATION_MESSAGES_RECIPIENTS = "CONVERSATION_LOAD_MESSAGES_RECIPIENTS";
export declare const ACTION_LOAD_CONVERSATION_MESSAGE_RECIPIENTS = "CONVERSATION_LOAD_MESSAGE_RECIPIENTS";
export declare const ACTION_LOAD_CHANNEL_TRANSFERS = "CONVERSATION_LOAD_TRANSFERS";
export declare function reduce(state: ConversationState, action: ConversationAction): ConversationState;
export declare class Actions {
    private static readonly MESSAGE_LOAD_COUNT;
    private static _dispatcher;
    static get dispatcher(): Dispatch<any>;
    static set dispatcher(dispatcher: Dispatch<any>);
    static dispatchConversationAction(sid: string, type: string, payload?: any, chatState?: ChatState): void;
    static init(conversation: Conversation): Promise<void>;
    static unload(conversationSid: string): void;
    static unsubscribe(conversationSid: string): void;
    static loadMessagesFromHistory(conversation: ConversationState): false | Promise<void>;
    private static loadUserForMissingMembers;
    static updateLastReadMessageIndex(conversation: ConversationState, newIndex: number): void;
    static removeAllListeners(): void;
    static initWithConversationSid(sid: string): Promise<void>;
    static addPendingMessage(file: File, conversation: Conversation, channel: Channel, body?: string): void;
    static removePendingMessage(file: File, conversation: Conversation): void;
    static rejectMediaMessage(file: File, conversation: Conversation): void;
    private static getMediaFromFile;
    static addMessageBody(message: Message, bodyAttachment: string): void;
    static showScrollDownBtn(conversation: ConversationState, showBtn: boolean): boolean;
    static storeLastScrollPosition(conversationSid: string, lastScrollPosition: number): boolean;
}
export declare class ConversationListener {
    private _conversation;
    private _listening;
    private _users;
    constructor(conversation: Conversation);
    start(): void;
    stop(): void;
    unsubscribe(): void;
    startListeningUser(user: User): void;
    stopListeningUser(user: User): void;
    private dispatchMessageOrMemberAction;
    private handleMessageAdded;
    private handleMessageUpdated;
    private handleMessageRemoved;
    private handleParticipantJoined;
    private handleParticipantLeft;
    private handleParticipantUpdated;
    private handleTypingStarted;
    private handleTypingEnded;
    private handleUserUpdated;
    private handleConversationUpdated;
    private showNewMessageNotification;
    isListening(): boolean;
}
export { ConversationHelper };
