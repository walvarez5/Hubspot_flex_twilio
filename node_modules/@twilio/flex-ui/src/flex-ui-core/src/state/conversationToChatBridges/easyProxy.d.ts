type OriginalArguments = any[];
type Handler = ["method", ProxiedMethod] | ["property", ProxiedProperty];
export type ProxiedMethod = (originalArgs: any[], callOriginal: (...originalArguments: OriginalArguments) => unknown, originalObject: any) => void;
export type ProxiedProperty = (originalValue: any, ProxyedObj: any) => any;
/**
 * @private
 * @param ProxyedObj
 * @param proxiedMethods
 *
 * @example
    const myProxy = createNewProxy(myObject, {
        addListener: ["method", proxyAddListener],
        active: ["method", proxyActive],
    };

    const proxyAddListener: IProxiedMethod = (originalArgs, callOriginal) => {
        const [event, ...rest] = originalArgs; // args the method has been invoked with

        const newEvent = event.replace("_", "-");

        return callOriginal(newEvent, ...rest); // calling the original method with manipulated arguments
    };

    const proxyActive: IProxiedProperty = (_originalValue, originalObject) => {
        return originalObject.isActive; // return different property form the original object
    };
 */
export declare const createNewProxy: <T extends Record<string, any>>(originalObject: T, proxiedMethods?: Record<any, Handler>) => T;
export {};
