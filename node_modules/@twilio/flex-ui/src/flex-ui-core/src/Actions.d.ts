import { EventEmitter } from "events";
/**
 * @typedef ActionFunction
 * @callback ActionFunction
 * @param {ActionsManager.ActionPayload} payload action payload
 * @returns {Promise<any>} promise to be invoked for action
 * @memberof ActionsManager
 */
export type ActionFunction = (payload: any) => Promise<any>;
/**
 * @typedef ActionCancelFunction
 * @callback ActionCancelFunction
 * @returns {void}
 * @memberof ActionsManager
 */
export type ActionCancelFunction = () => void;
/**
 * @typedef ReplacedActionFunction
 * @callback ReplacedActionFunction
 * @param {ActionsManager.ActionPayload} payload action payload
 * @param {ActionsManager.ActionFunction} original original action invocation
 * @param {ActionsManager.ActionFunction} next next action invocation
 * @returns {Promise<any>} promise to be invoked for action
 * @memberof ActionsManager
 */
export type ReplacedActionFunction = (payload: ActionPayload, original: ActionFunction, next?: ActionFunction) => Promise<any>;
/**
 * @typedef PayloadUpdateFunction
 * @callback PayloadUpdateFunction
 * @param {ActionsManager.ActionPayload} payload action payload
 * @returns {ActionsManager.ActionPayload} updated action payload
 * @memberof ActionsManager
 */
export type PayloadUpdateFunction = (payload: ActionPayload) => ActionPayload;
/**
 * Action with payload
 * @typedef {object} ActionWithPayload
 * @property {ActionsManager.ActionName} action action code
 * @property {ActionsManager.ActionPayload} [payload] action payload
 * @memberof ActionsManager
 */
export interface ActionWithPayload {
    action: ActionName;
    payload?: ActionPayload;
}
/**
 * Actions with payload
 * @typedef {object} ActionsWithPayload
 * @property {ActionsManager.ActionWithPayload} [first] first action with payload
 * @property {ActionsManager.ActionPayload} [ACTION_CODE] action payload by action code in key
 * @memberof ActionsManager
 */
export interface ActionsWithPayload {
    [k: string]: ActionPayload;
    first?: ActionWithPayload;
}
/**
 * Action payload
 * @typedef {any} ActionPayload
 * @memberof ActionsManager
 */
export type ActionPayload = any;
/**
 * Action name
 * @typedef {string} ActionName
 * @memberof ActionsManager
 */
export type ActionName = string;
/**
 * Predicate to match action by payload
 * @typedef MatchActionPayloadPredicate
 * @callback MatchActionPayloadPredicate
 * @param {ActionsManager.ActionPayload} payload action payload
 * @param {string} action action code
 * @returns {boolean} true if payload is matched
 * @memberof ActionsManager
 */
export type MatchActionPayloadPredicate = (payload: ActionPayload, action: string) => boolean;
/**
 * Action payload or predicate to match
 * @typedef {(ActionsManager.MatchActionPayloadPredicate | ActionsManager.ActionPayload)} MatchActionPayload
 * @memberof ActionsManager
 */
export type MatchActionPayload = MatchActionPayloadPredicate | ActionPayload;
/**
 * Event fired before action is invoked
 * @event ActionsManager.before[Action]
 * @param {ActionsManager.ActionPayload} payload action payload
 * @param {ActionsManager.ActionCancelFunction} cancelFunction function to call to cancel action invocation
 */
/**
 * Event fired after action is invoked
 * @event ActionsManager.after[Action]
 * @param {ActionsManager.ActionPayload} payload action payload
 */
/**
 * Event fired when action blocked status was changed
 * @event ActionsManager.actionBlockedChanged
 * @param {boolean} blocked whether action was blocked or not
 * @param {string} action action name
 * @param {ActionsManager.ActionPayload} payload action payload
 */
/**
 * Event fired before any action invocation
 * @event ActionsManager.invocationBegin
 */
/**
 * Event fired after any action invocation
 * @event ActionsManager.invocationEnd
 */
/**
 * @class ActionsManager
 * @classdesc The Flex UI is constantly emitting event data that describes how the user is interacting with the Flex UI. As you write Plugins, the ActionsManager allows you to harness these events and define your own logic to describe how you want the Flex UI, CRM Data, or any other data, to change. You can register events before or after an action fires, or even replace the behavior of an Action.
 * @hideconstructor
 * @category UI Actions
 * @menuorder 100
 */
export declare class ActionsImpl {
    private actions;
    private replacedActions;
    private payloadUpdateFunctions;
    private pendingInvocations;
    private blockedActions;
    private emitter;
    constructor();
    /**
     * Registers an action
     * @function registerAction
     * @param {string} name Name of the action to register.
     * @param {ActionsManager.ActionFunction} action A function to execute when the action is invoked.
     * @param {ActionsManager.PayloadUpdateFunction} [payloadUpdateFunction] A function to update the payload.
     * @returns {void}
     * @memberof ActionsManager
     * @example
     * import { Actions, ActionFunction, PayloadUpdateFunction } from "@twilio/flex-ui";
     *
     * const myCustomAction = "MyCustomAction";
     * const myCustomActionFunction: ActionFunction = (payload) => Promise.resolve(payload);
     * const payloadUpdateFunction: PayloadUpdateFunction = (payload) => {
     *   payload.updated = true;
     *   return payload;
     * };
     * Actions.registerAction(myCustomAction, myCustomActionFunction, payloadUpdateFunction);
     */
    registerAction(name: string, action: ActionFunction, payloadUpdateFunction?: PayloadUpdateFunction): void;
    /**
     * Invokes an action
     * @function invokeAction
     * @param {string} name Name of the action to invoke.
     * @param {ActionsManager.ActionPayload} [payload] Data to be passed to an action while invoking.
     * @returns {Promise<any>} Action Promise
     * @memberof ActionsManager
     * @fires ActionsManager.invocationBegin
     * @fires ActionsManager.before[Action]
     * @fires ActionsManager.after[Action]
     * @fires ActionsManager.invocationEnd
     * @example
     * import { Actions } from "@twilio/flex-ui";
     *
     * Actions.invokeAction("StartOutboundCall", {
     *   destination: "+123456789"
     * });
     */
    invokeAction(name: string, payload?: ActionPayload): Promise<any>;
    private invokeReplacedActions;
    /**
     * To prevent promise.all to stop waiting for promises after the first rejection,,
     * we add a custom "catch" logic to each of the values returned from an eventListener,
     * if this is a promise.
     * @private
     */
    private catchErrorIfIsPromise;
    private customEmit;
    /**
     * Replace an existing action
     * @function replaceAction
     * @param {string} name An action name to be replaced.
     * @param {ActionsManager.ReplacedActionFunction} action A new function for an action to be replaced.
     * @returns {void}
     * @memberof ActionsManager
     * @example
     * import { Actions } from "@twilio/flex-ui";
     * Actions.replaceAction("AcceptTask", (payload, original) =>
     *   new Promise<void>((resolve, reject) => {
     *     alert("replaced Action");
     *     resolve(undefined);
     *   }).then(() => original(payload))
     * );
     */
    replaceAction(name: string, action: ReplacedActionFunction): void;
    /**
     * Add a new listener to the action
     * @function addListener
     * @param {string} event Event name
     * @param {Function} listener Event callback
     * @returns {EventEmitter} Event Emitter
     * @memberof ActionsManager
     * @example
     * import { Actions } from "@twilio/flex-ui";
     * const beforeAcceptTaskListener = (payload, abortFunction) => {
     *   alert("Before event");
     *   if (!window.confirm("Are you sure you want to accept the task?")) {
     *     abortFunction();
     *   }
     * };
     * Actions.addListener("beforeAcceptTask", beforeAcceptTaskListener);
     */
    addListener(event: string | symbol, listener: (...args: any[]) => void): EventEmitter;
    /**
     * Alias for addListener
     * @function on
     * @param {string | symbol} event Event name
     * @param {Function} listener Event callback
     * @returns {EventEmitter} Event Emitter
     * @deprecated
     * @deprecatedSince 1.7.0
     * @altRecommendation Use `addListener` instead
     * @altRecommendationExample
     * import { Actions } from "@twilio/flex-ui";
     * Actions.addListener("beforeAcceptTask", beforeAcceptTaskListener);
     * @altRecommendationLink https://assets.flex.twilio.com/docs/releases/flex-ui/latest/ui-actions/ActionsManager/#addlistener-event-listener-eventemitter
     * @memberof ActionsManager
     * @private
     */
    on(event: string | symbol, listener: (...args: any[]) => void): EventEmitter;
    /**
     * Removing a listener from the action
     * @function removeListener
     * @param {string | symbol} event Event name
     * @param {Function} listener Event callback
     * @returns {EventEmitter} Event Emitter
     * @memberof ActionsManager
     * @example
     * import { Actions } from "@twilio/flex-ui";
     * Actions.removeListener("beforeAcceptTask", beforeAcceptTaskListener);
     */
    removeListener(event: string | symbol, listener: (...args: any[]) => void): EventEmitter;
    private registerInvocation;
    private unregisterInvocation;
    /**
     * Find pending actions by action and payload
     * @function findPendingActions
     * @param {string|Array<string>} action Action or array of actions
     * @param {ActionsManager.MatchActionPayload} [payload] Payload to search for
     * @returns {ActionsManager.ActionsWithPayload} ActionsWithPayload object
     * @memberof ActionsManager
     * @example
     * import { Actions } from "@twilio/flex-ui";
     * const pendingAcceptTaskInvocations = Actions.findPendingActions("AcceptTask");
     */
    findPendingActions(action: string | Array<string>, payload?: MatchActionPayload): ActionsWithPayload;
    /**
     * Find blocked actions by action and payload
     * @function findBlockedActions
     * @param {string|Array<string>} action Action or array of actions
     * @param {ActionsManager.MatchActionPayload} [payload] Payload to search for
     * @returns {ActionsManager.ActionsWithPayload} ActionsWithPayload object
     * @memberof ActionsManager
     * @example
     * import { Actions } from "@twilio/flex-ui";
     * const blockedAcceptTaskInvocations = Actions.findBlockedActions("AcceptTask");
     */
    findBlockedActions(action: string | Array<string>, payload?: MatchActionPayload): ActionsWithPayload;
    /**
     * Block action with given payload
     * @function blockAction
     * @param {string} action Action
     * @param {ActionsManager.ActionPayload} [payload] Action payload
     * @returns {void}
     * @memberof ActionsManager
     * @fires ActionsManager.actionBlockedChanged
     * @example
     * import { Actions } from "@twilio/flex-ui";
     * Actions.blockAction("AcceptTask");
     */
    blockAction(action: string, payload?: ActionPayload): void;
    /**
     * Unblock previously blocked action with given payload.
     * @function unblockAction
     * @param {string} action Action name
     * @param {ActionsManager.MatchActionPayload} [payload] Action payload
     * @returns {void}
     * @memberof ActionsManager
     * @fires ActionsManager.actionBlockedChanged
     * @example
     * import { Actions } from "@twilio/flex-ui";
     * Actions.unblockAction("AcceptTask");
     */
    unblockAction(action: string, payload?: ActionPayload): void;
    private setActionBlocked;
}
/**
 * A singleton instance of Actions manager
 *
 * @private
 */
export declare const Actions: ActionsImpl;
