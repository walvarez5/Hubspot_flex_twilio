import { Media, Message } from "@twilio/conversations";
import { CoreUtils } from "../../internal-flex-commons/src";
import { DeepPartial } from "./types";
export interface Version {
    major: number;
    minor: number;
    build: number;
}
interface AnyObject {
    [key: string]: any;
}
interface HaveSameValuesMethodOptions {
    equalUndefinedToEmptyArray?: boolean;
}
export declare class Utils extends CoreUtils {
    /**
     * Deep merge two objects into a new object.
     * @param {A} obj1 obj1
     * @param {B} obj2 obj2
     * @param {boolean} override override
     * @returns {object} merged object
     * @template A, B
     * @public
     * @example
     * merge({}, {});
     */
    static merge<A extends Record<string, any>, B extends Record<string, any>>(obj1: DeepPartial<A & B>, obj2: B, override?: boolean): A & B;
    /**
     * Deep merge second object into the first one.
     *
     * @param obj1 first object to merge into
     * @param obj2 second object
     * @param override whether values in the first object will be overridden
     * @private
     */
    static mergeInto<A extends Record<string, any>, B extends Record<string, any>>(obj1: DeepPartial<A & B>, obj2: B, override?: boolean): A & B;
    static mergeArrayItems<T>(array: Array<T>): Array<T>;
    /**
     * Update static overrideProps for all components that have original defaultProps
     *
     * Use with components decorated with withDefaultPropsUpdate.
     *
     * @param allComponents
     * @param defaultPropsByComponent
     * @private
     */
    static updateDefaultProps<T>(allComponents: T, defaultPropsByComponent: {
        [P in keyof T]?: any;
    }): void;
    static getNameForMember(friendlyNameOverrides: boolean, customName: string, friendlyName: string, identity: string): string;
    static formatString(theString: string, ...params: Array<string>): string;
    static parseVersion(version: string): Version;
    static isGreaterThanTargetVersion(version: Version, targetVersion: Version): boolean;
    static simpleUrlRegexp: RegExp;
    static urlRegexp: RegExp;
    static copyMap<K, V>(sourceMap: Map<K, V>): Map<K, V>;
    static parseText(rawBody: string): any[];
    static parseMDText(rawBody?: string): string;
    static areEqual(obj1: any, obj2: any): boolean;
    /**
     * Similiar to `areEqual`, this methods deeply compares values.
     * Also, if two values are array, it compares them ignoring the sort order.
     *
     * @static
     * @param {{}} obj1
     * @param {{}} obj2
     * @param {{}} options
     * @returns boolean
     * @private
     */
    static haveSameValues(obj1: AnyObject, obj2: AnyObject, options?: HaveSameValuesMethodOptions): boolean;
    static getRandomValue: () => number;
    static startCase: (text?: string) => string;
    /**
     * Checks if two dates are the same.
     * @deprecated
     * @deprecatedSince 2.5.0
     * @altRecommendation Use `isSameDate` from `@twilio/flex-ui-core` instead.
     * @altRecommendationExample
     * import {isSameDate} from `@twilio/flex-ui-core`
     * const foo = isSameDate(date1, date2);
     * @param {Date} date1 - first date
     * @param {Date} date2 - second date
     * @returns {boolean} - true if dates are the same, false otherwise
     * @example Utils.isSameDate(new Date(), new Date());
     */
    static isSameDate(date1: Date, date2: Date): boolean;
    /**
     * Checks if the given date is today.
     * @param {Date} date - date to check
     * @returns {boolean} - true if date is today, false otherwise
     * @deprecated
     * @deprecatedSince 2.5.0
     * @altRecommendation Use `isToday` from `@twilio/flex-ui-core` instead.
     * @altRecommendationExample
     * import {isToday} from `@twilio/flex-ui-core`
     * const foo = isToday(new Date());
     * @example Utils.isToday(new Date());
     */
    static isToday(date: Date): boolean;
    /**
     * Checks if the given date is yesterday.
     * @param { Date } date - date to check
     * @returns {boolean} - true if date is yesterday, false otherwise
     * @deprecated
     * @deprecatedSince 2.5.0
     * @altRecommendation Use `isYesterday` from `@twilio/flex-ui-core` instead.
     * @altRecommendationExample
     * import {isYesterday} from `@twilio/flex-ui-core`
     * const foo = isYesterday(new Date());
     * @example Utils.isYesterday(new Date());
     */
    static isYesterday(date: Date): boolean;
    /**
     * Formats the given date to a string with the following format: "MM/DD/YYYY".
     * @param { Date } date - date to format
     * @returns {string} - formatted date
     * @example Utils.formatSeparatorDate(new Date());
     * @deprecated
     * @deprecatedSince 2.5.0
     * @altRecommendation Use `formatSeparatorDate` from `@twilio/flex-ui-core` instead.
     * @altRecommendationExample
     * import {formatSeparatorDate} from `@twilio/flex-ui-core`
     * const foo = formatSeparatorDate(new Date());
     */
    static formatSeparatorDate(date: Date): string;
    /**
     * This method formats dates based upon a millisecond value.  The format value is optional and defaults to 'full'.
     * @param {number} time - time to format
     * @param {string} format - 'full' | 'compact' | 'short'
     * @returns {string} - formatted time
     * @example Utils.formatTimeDuration(1000);
     * @deprecated
     * @deprecatedSince 2.5.0
     * @altRecommendation Use `formatTimeDuration` from `@twilio/flex-ui-core` instead.
     * @altRecommendationExample
     * import {formatTimeDuration} from `@twilio/flex-ui-core`
     * const foo = formatTimeDuration(1000, "full");
     */
    static formatTimeDuration(time: number, format?: "full" | "compact" | "short"): string;
    /**
     * Formats a timestamp to a Long localized time format.
     * @param {string} timeStamp - timestamp to format
     * @param {any} timeStyle - not considered in this implementation
     * @returns {string} - formatted timestamp in form of 12:00 AM
     * @example Utils.formatTimeStamp("2019-01-01T00:00:00.000Z");
     * @deprecated
     * @deprecatedSince 2.5.0
     * @altRecommendation Use `formatTimeStamp` from `@twilio/flex-ui-core` instead.
     * @altRecommendationExample
     * import {formatTimeStamp} from `@twilio/flex-ui-core`
     * const foo = formatTimeStamp("2019-01-01T00:00:00.000Z");
     */
    static formatTimeStamp: (timeStamp: string, timeStyle: any) => string;
}
export declare const fetchMediaContent: (media: Media, errorSubject?: string) => Promise<any>;
export declare function replaceImageSrcWithLinks(rawHtml: string, attachedMedia?: Map<string, string>): string;
/**
 * Filters all the inline attachments from the separate list of attachment received from conversation.
 * Agent will not see any inline image in separate attachment list as well message header's attachment detail section.</p>
 * <p>This logic has a limitation as it depends on "alt" value present in < img/ > tags for inline attachments.
 * As a result in case of two different images with same name will filter any one of the attachments.
 * If alt value is not present, it will not filter such inline attachment.</p>
 * @param {Message} messageSource Message source from conversation
 * @returns {Promise<Media[]>} Promise that resolves to a Media array
 * @example
 * getFilteredMediaAttachments({})
 */
export declare function getFilteredMediaAttachments(messageSource: Message): Promise<Media[]>;
/**
 * Checks if a given message is an email message by examining its content.
 * @param {Message} message - The message to check for email content.
 * @returns {boolean} - `true` if the message contains email content, `false` otherwise.
 * @example
 * const isEmail1 = isEmailMessage(emailMsg); // Returns true
 */
export declare const isEmailMessage: (message: Message) => boolean;
export {};
