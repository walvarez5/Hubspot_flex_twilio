import React, { Component, ErrorInfo, PropsWithChildren, ReactNode } from "react";
interface RenderProps {
    error: Error;
    resetErrorBoundary: VoidFunction;
    componentStack: string | undefined;
}
interface ErrorBoundaryProps extends PropsWithChildren<any> {
    onReset?: VoidFunction | null;
    onError?: ((error: Error, componentStack?: string) => void) | null;
    fallbackRenderProp?: ((props: RenderProps) => JSX.Element) | null;
    fallback?: React.ReactNode | null;
}
interface ErrorBoundaryState {
    error: Error | null;
    info: Info;
}
type Info = null | ErrorInfo;
declare class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
    static readonly defaultProps: ErrorBoundaryProps;
    state: ErrorBoundaryState;
    static getDerivedStateFromError(error: Error): {
        error: Error;
    };
    resetErrorBoundary: () => void;
    componentDidCatch(error: Error, info: ErrorInfo): void;
    render(): ReactNode;
}
declare const withErrorBoundary: <T extends object>(WrappedComponent: React.ComponentType<T>, errorBoundaryProps: ErrorBoundaryProps) => React.ElementType;
/**
 * Handle all event handlers and async errors that are missed by the default error boundary.
 *
 * @template T
 * @param {T} givenError - Passed in state.
 * @returns {React.Dispatch<React.SetStateAction<string>>} - SetState action.
 * @example
 * import {useErrorHandeler} from "@twilio/flex-ui-core";
 * const setError = useErrorHandler();
 * .
 * ..
 * setError(error);
 * ----- OR -----
 * import {useErrorHandeler} from "@twilio/flex-ui-core";
 * useErrorHandeler(error)
 */
declare function useErrorHandler<T>(givenError?: T): React.Dispatch<React.SetStateAction<string>>;
export { ErrorBoundary, ErrorBoundaryProps, ErrorBoundaryState, useErrorHandler, withErrorBoundary };
