import { TwilsockClient } from "twilsock";
/**
 * Abstract class that outlines required methods for EventDelegates
 * to reimplement. Basic idea is that we might have different
 * event categories that will require various transformations
 * (based on category) before reporting.
 *
 * ## How to use this class
 *
 * Once you have a new event category to report, create a new class
 * that inherits from AbstractTelemetryEventsDelegate. Once inherited, implement
 * a few functions:
 * - `format` that converts an arbitrary object (X) to the event shape (T) declared by the delegate
 * - `getSchemeName` that returns an even scheme name to use
 * - `getEventName` that returns a name of the event that will be reported once `report` is called
 *
 * That way, if we ever need to create a new event category, it should
 * boil down to creation of the new class with two pre-defined methods
 * @private
 */
export default abstract class AbstractTelemetryEventsDelegate<T extends Record<string, any>> {
    protected twilsockClient?: TwilsockClient;
    protected isTelemetryDisabled: boolean;
    initialize(twilsockClient: TwilsockClient): void;
    disableTelemetry(): void;
    /**
     * Calculate event name that will be used as an eventName field in the telemetry report
     * @private
     */
    abstract getEventName(): string;
    /**
     * Calculate an event schema name
     * @private
     */
    abstract getSchemaName(): string;
    /**
     * The telemetry service expects the event of each schema (e.g. Programmability) to be in a certain format. This
     * method is expected to be overriden by an event delegate in order to format its events accordingly.
     * @private
     */
    abstract format(event: Record<string, any>): T;
    /**
     * Reports the given telemetry event/s
     * @private
     */
    report(event: T | Array<T>): Promise<void>;
    /**
     * Prepares events to be shipped via Twilsock SDK
     * @private
     */
    private twilsockFormatEvent;
    private convertObjectKeysToSnakeCase;
}
