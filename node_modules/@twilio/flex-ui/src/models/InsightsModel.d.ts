import EventEmitter from "events";
import { IQueue, ITask, IWorker, TaskReservationStatus, TaskTaskStatus } from "./CommonModels";
/**
 * @private
 */
export interface InsightsWorkerData {
    worker_sid: string;
    friendly_name: string;
    activity_name: string;
    attributes: any;
    date_updated: string;
    date_activity_changed: string;
    team_sid?: string;
}
/**
 * @private
 */
export interface InsightsTaskData extends EventEmitter {
    key?: string;
    attributes: any;
    date_created: string;
    date_updated: string;
    queue_name: string;
    reservation_sid: string;
    status: TaskReservationStatus;
    task_age: number;
    task_channel_type: string;
    task_channel_unique_name: string;
    task_date_created: string;
    task_priority: number;
    task_sid: string;
    task_status: TaskTaskStatus;
    worker_name: string;
    worker_sid: string;
    workspace_sid: string;
    task_routing_target: string;
}
/**
 * @private
 */
export interface InsightsQueueData {
    date_updated: string;
    queue_sid: string;
    queue_name: string;
    workspace_sid: string;
}
/**
 * @private
 */
export interface InsightsWorkerBySid {
    [sid: string]: InsightsWorkerData;
}
/**
 * @private
 */
export interface InsightsQueueBySid {
    [sid: string]: InsightsQueueData;
}
/**
 * @private
 */
export interface InsightsTaskBySid {
    [sid: string]: InsightsTaskData;
}
/**
 * @private
 */
export declare class InsightsTask implements ITask {
    complete: () => Promise<never>;
    setAttributes: () => Promise<never>;
    dequeue: () => Promise<never>;
    redirectCall: () => Promise<never>;
    issueCallToWorker: () => Promise<never>;
    updateWorkerParticipant: () => Promise<never>;
    updateCustomerParticipant: () => Promise<never>;
    wrapUp: () => Promise<never>;
    transfer: () => Promise<never>;
    hold: () => Promise<never>;
    unhold: () => Promise<never>;
    addVoiceParticipant: () => Promise<never>;
    holdParticipant: () => Promise<never>;
    unholdParticipant: () => Promise<never>;
    kick: () => Promise<never>;
    cancelTransfer: () => Promise<never>;
    getChannels: () => Promise<never>;
    getParticipants: () => Promise<never>;
    setEndConferenceOnExit: () => Promise<never>;
    endConference: () => Promise<never>;
    joinCall: () => Promise<never>;
    private _source;
    constructor(source: InsightsTaskData);
    get source(): InsightsTaskData;
    get sourceObject(): InsightsTaskData;
    get addOns(): any;
    get age(): number;
    get attributes(): any;
    get dateCreated(): Date;
    get dateUpdated(): Date;
    get priority(): number;
    get queueName(): string;
    get queueSid(): any;
    get reason(): any;
    get taskSid(): string;
    get status(): TaskReservationStatus;
    get taskStatus(): TaskTaskStatus;
    get taskChannelSid(): any;
    get taskChannelUniqueName(): string;
    get timeout(): any;
    get workflowName(): any;
    get workflowSid(): any;
    get sid(): string;
    get workerSid(): string;
    get routingTarget(): string;
    get defaultFrom(): any;
    get formattedAttributes(): {
        from?: string;
        outbound_to?: string;
    };
    get channelType(): any;
    get incomingTransferObject(): any;
    get outgoingTransferObject(): any;
    get conference(): import("../state/Conferences").Conference;
}
/**
 * @private
 */
export declare class InsightsWorker implements IWorker<InsightsWorkerData> {
    private _source;
    constructor(source: InsightsWorkerData);
    private static availabilityByNameCache;
    get source(): InsightsWorkerData;
    get sid(): string;
    get name(): string;
    get fullName(): any;
    get activityName(): string;
    get attributes(): any;
    get dateUpdated(): Date;
    get teamSid(): string;
    get activityDuration(): string;
    get isAvailable(): boolean;
    private static ensureAvailabilityCache;
    private findAvailabilityByActivityName;
}
/**
 * @private
 */
export declare class InsightsQueue implements IQueue<InsightsQueueData> {
    private _source;
    constructor(source: InsightsQueueData);
    get source(): InsightsQueueData;
    get sid(): string;
    get name(): string;
    get dateUpdated(): Date;
    get workspaceSid(): string;
}
export interface ProjectDashboardResponse {
    projectDashboard: {
        meta: {
            identifier: string;
            author?: string;
            category?: string;
            contributor?: string;
            created?: string;
            deprecated?: string;
            isProduction?: number;
            locked?: number;
            summary?: string;
            tags?: string;
            title?: string;
            updated?: string;
            uri?: string;
        };
        content: {
            filters: any;
            rememberFilters: number;
            tabs: Array<{
                identifier: string;
                title: string;
                items: Array<any>;
            }>;
        };
    };
}
export interface ProjectDashboard {
    identifier: string;
    category?: string;
    link?: string;
    title?: string;
    author?: string;
    tabs?: Array<{
        title: string;
        identifier: string;
    }>;
}
export interface AnalyticalDashboard {
    identifier: string;
    category?: string;
    link?: string;
    title?: string;
    author?: string;
    widgets?: string[];
}
export interface AnalyticalDashboardResponse {
    analyticalDashboard: {
        meta: {
            identifier: string;
            locked?: number;
            author?: string;
            uri?: string;
            tags?: string;
            created?: string;
            deprecated?: string;
            summary?: string;
            isProduction?: number;
            title?: string;
            category?: string;
            updated?: string;
            contributor?: string;
        };
        content: {
            filterContent?: string;
            layout?: unknown;
            widgets?: Array<string>;
        };
    };
}
export interface DashboardQueryResponse {
    query: {
        meta: {
            category: string;
            summary?: number;
            title?: string;
        };
        entries: DashboardQueryEntry[];
    };
}
export interface DashboardQueryEntry {
    link: string;
    title: string;
    updated: string;
    sharedWithSomeone?: number;
    created: string;
    summary: string;
    locked?: number;
    isProduction?: number;
    author: string;
    identifier: string;
    unlisted?: number;
    deprecated: string;
    contributor: string;
    category: string;
    tags: string;
}
export interface AnalyticalDashboardWidget {
    kpi?: {
        content?: {
            metric: string;
            drillTo?: {
                projectDashboardTab?: string;
            };
        };
    };
    visualizationWidget?: {
        content?: {
            visualization: string;
        };
        meta: {
            uri: string;
        };
    };
}
export interface WidgetMetricsResponse {
    objects: {
        items: Array<AnalyticalDashboardWidget>;
    };
}
export interface WorkspaceAttributesResponse {
    objects: {
        items: Array<WorkspaceAttribute>;
        paging?: {
            next?: string;
        };
    };
}
export interface WorkspaceAttribute {
    attribute: {
        content: {
            displayForms: Array<{
                content: {
                    type: string;
                };
                meta: {
                    uri: string;
                };
            }>;
        };
        meta?: {
            deprecated?: string;
            isProduction?: number;
        };
    };
}
export interface GoodDataProfileInfo {
    links?: {
        self?: string;
        projects?: string;
        auditEvents?: string;
        domain?: string;
    };
    firstName?: string;
    lastName?: string;
    companyName?: any;
    position?: any;
    created?: string;
    updated?: string;
    country?: any;
    phoneNumber?: any;
    authenticationModes?: any[];
    login?: string;
    timezone?: any;
    ssoProvider?: string;
    email?: string;
    language?: string;
    ipWhitelist?: any;
    effectiveIpWhitelist?: any;
}
export type DrilldownIntersection = Record<number, {
    header: {
        identifier: string;
        uri: string;
    };
    id: string;
    title: string;
}>;
export interface GoodDataDrillDownEvent {
    drillTo?: {
        uri: string;
    };
    drillContext?: {
        type: "table" | "bar";
        intersection?: DrilldownIntersection;
        row?: Record<number, {
            id: string;
            name: string;
            uri: string;
        }>;
        points?: Record<number, {
            intersection: DrilldownIntersection;
            x: number;
            y: number;
        }>;
        rowIndex: number;
    };
}
