typeof window<"u"&&(window.global=window);import{__classPrivateFieldSet as _,__classPrivateFieldGet as i}from"../../../../../node_modules/tslib/tslib.es6.js";import{getReservationsByTask as O,canHold as I,sendTrackingEvent as n}from"../../ActionUtils.js";import"../../../logger/Logger/LogEntry.js";import{LoggerName as T}from"../../../logger/Logger/LoggerName.js";import{getLogger as x}from"../../../logger/LoggerFactory/getLogger.js";import"../../../logger/LoggerFactory/LoggerConfigImpl.js";import{FlexSdkError as M}from"../../../error/FlexSdkError/FlexSdkError.js";import{ErrorCode as S}from"../../../error/ErrorCode/ErrorCodes.js";import"../../../error/ErrorCode/InternalErrorCodes.js";import"../../../error/ErrorCode/ErrorCodeHelper.js";import{ErrorSeverity as C}from"../../../error/ErrorSeverity/ErrorSeverity.js";import{EVENTS as s}from"../../../analytics/Analytics.js";import{AnalyticsImpl as j}from"../../../analytics/AnalyticsImpl.js";import{CbmImpl as U}from"../../../cbm/CbmImpl.js";import{TaskRouterImpl as B}from"../../../../packages/taskrouter/TaskRouterImpl.js";var e,v,p;class D{constructor(g,d,c){e.set(this,void 0),v.set(this,void 0),p.set(this,void 0),_(this,e,g,"f"),_(this,v,d,"f"),_(this,p,c,"f")}async run(g){var d,c,u,P;const m=g,E=m.getInstanceOf(B),b=x(m)(T.Client),a=m.getInstanceOf(j),w=m.getInstanceOf(U),o=E.worker,h=(d=i(this,p,"f"))===null||d===void 0?void 0:d.holdMusicUrl,k=((c=i(this,p,"f"))===null||c===void 0?void 0:c.holdMusicMethod)||"GET",y=O(o,i(this,v,"f")).find(t=>t.status==="accepted");if(!y||!I(y,o)){const t="holdParticipant: Can't hold participant";throw b.error(t),n(s.HoldParticipantCompleted,a,o,t),new M(S.SDK,{severity:C.Error},t)}const l=y.task,H=await w.getParticipantBySid(i(this,e,"f"),l);if(H&&H.type==="external")try{return await w.holdParticipant(l,i(this,e,"f")),n(s.HoldParticipantCompleted,a,o),Promise.resolve()}catch{const r=`holdParticipant: Could not hold external participant ${i(this,e,"f")}`;throw n(s.HoldParticipantCompleted,a,o,r),new M(S.SDK,{severity:C.Error},r)}const f=(await w.getParticipantsByTask(l)).find(t=>{var r;return((r=t.routingProperties)===null||r===void 0?void 0:r.workerSid)===i(this,e,"f")});if(f&&(!((u=f.routingProperties)===null||u===void 0)&&u.workerSid)&&f.type==="agent")return await l.hold((P=f.routingProperties)===null||P===void 0?void 0:P.workerSid,!0,Object.assign(Object.assign({},h&&{holdUrl:h}),k&&{holdMethod:k})),n(s.HoldParticipantCompleted,a,o),Promise.resolve();try{return await l.updateParticipant(Object.assign(Object.assign({hold:!0},h&&{holdUrl:h}),{holdMethod:k})),n(s.HoldParticipantCompleted,a,o),Promise.resolve()}catch{const r=`holdParticipant: Could not hold participant ${i(this,e,"f")}`;throw n(s.HoldParticipantCompleted,a,o,r),new M(S.SDK,{severity:C.Error},r)}}}e=new WeakMap,v=new WeakMap,p=new WeakMap;export{D as HoldParticipant};
//# sourceMappingURL=HoldParticipant.js.map
