typeof window<"u"&&(window.global=window);import{__classPrivateFieldSet as S,__classPrivateFieldGet as e}from"../../../../../node_modules/tslib/tslib.es6.js";import{getLogger as E}from"loglevel";import{AnalyticsImpl as _}from"../../../analytics/AnalyticsImpl.js";import{CbmImpl as U}from"../../../cbm/CbmImpl.js";import"../../../logger/Logger/LogEntry.js";import{LoggerName as M}from"../../../logger/Logger/LoggerName.js";import"../../../logger/LoggerFactory/getLogger.js";import"../../../logger/LoggerFactory/LoggerConfigImpl.js";import{TaskRouterImpl as I}from"../../../../packages/taskrouter/TaskRouterImpl.js";import{getReservationsByTask as b,canHold as x,sendTrackingEvent as a}from"../../ActionUtils.js";import{EVENTS as s}from"../../../analytics/Analytics.js";import{FlexSdkError as l}from"../../../error/FlexSdkError/FlexSdkError.js";import{ErrorCode as m}from"../../../error/ErrorCode/ErrorCodes.js";import"../../../error/ErrorCode/InternalErrorCodes.js";import"../../../error/ErrorCode/ErrorCodeHelper.js";import{ErrorSeverity as h}from"../../../error/ErrorSeverity/ErrorSeverity.js";var i,f;class D{constructor(P,p){i.set(this,void 0),f.set(this,void 0),S(this,i,P,"f"),S(this,f,p,"f")}async run(P){var p,w;const v=P,C=v.getInstanceOf(I),c=E(M.Actions),o=C.worker,n=v.getInstanceOf(_),g=v.getInstanceOf(U);if(c.debug(`holdParticipant invoked with taskSid: ${e(this,f,"f")}`),!o){const t="unholdParticipant: Worker is not initialized";return c.error(t),Promise.reject(new l(m.SDK,{severity:h.Error},t))}const k=b(o,e(this,f,"f")).find(t=>t.status==="accepted");if(!k||!x(k,o)){const t="unholdParticipant: Reservation not found or worker cannot unhold it";throw c.error(t),a(s.UnholdParticipantCompleted,n,o,t),new l(m.SDK,{severity:h.Error},t)}const d=k.task,y=await g.getParticipantBySid(e(this,i,"f"),d);if(y&&y.type==="external")try{return await g.unholdParticipant(d,e(this,i,"f")),a(s.UnholdParticipantCompleted,n,o),Promise.resolve()}catch{const r=`unholdParticipant: Could not unhold external participant ${e(this,i,"f")}`;throw c.error(r),a(s.UnholdParticipantCompleted,n,o,r),new l(m.SDK,{severity:h.Error},r)}const u=(await g.getParticipantsByTask(d)).find(t=>{var r;return((r=t.routingProperties)===null||r===void 0?void 0:r.workerSid)===e(this,i,"f")});if(u&&(!((p=u.routingProperties)===null||p===void 0)&&p.workerSid)&&u.type==="agent")try{return await d.hold((w=u.routingProperties)===null||w===void 0?void 0:w.workerSid,!1),a(s.UnholdParticipantCompleted,n,o),Promise.resolve()}catch{const r=`unholdParticipant: Could not unhold agent participant ${e(this,i,"f")}`;throw c.error(r),a(s.UnholdParticipantCompleted,n,o,r),new l(m.SDK,{severity:h.Error},r)}try{return await d.updateParticipant({hold:!1}),a(s.UnholdParticipantCompleted,n,o),Promise.resolve()}catch{const r=`unholdParticipant: Could not unhold participant ${e(this,i,"f")}`;throw c.error(r),a(s.UnholdParticipantCompleted,n,o,r),new l(m.SDK,{severity:h.Error},r)}}}i=new WeakMap,f=new WeakMap;export{D as UnholdParticipant};
//# sourceMappingURL=UnholdParticipant.js.map
