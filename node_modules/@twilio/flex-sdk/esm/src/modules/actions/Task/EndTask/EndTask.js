typeof window<"u"&&(window.global=window);import{__classPrivateFieldSet as T,__classPrivateFieldGet as s}from"../../../../../node_modules/tslib/tslib.es6.js";import{CompleteTask as E}from"../CompleteTask/CompleteTask.js";import{FlexSdkError as d}from"../../../error/FlexSdkError/FlexSdkError.js";import{ErrorCode as c}from"../../../error/ErrorCode/ErrorCodes.js";import"../../../error/ErrorCode/InternalErrorCodes.js";import"../../../error/ErrorCode/ErrorCodeHelper.js";import{ErrorSeverity as f}from"../../../error/ErrorSeverity/ErrorSeverity.js";import"../../../logger/Logger/LogEntry.js";import{LoggerName as y}from"../../../logger/Logger/LoggerName.js";import{getLogger as C}from"../../../logger/LoggerFactory/getLogger.js";import"../../../logger/LoggerFactory/LoggerConfigImpl.js";import{TaskRouterImpl as S}from"../../../../packages/taskrouter/TaskRouterImpl.js";import{CbmImpl as h}from"../../../cbm/CbmImpl.js";import{sendTrackingEvent as p,getReservationsByTask as P,isCallTask as I}from"../../ActionUtils.js";import{EVENTS as k}from"../../../analytics/Analytics.js";import{AnalyticsImpl as M}from"../../../analytics/AnalyticsImpl.js";import{WrapUpTask as _}from"../WrapUpTask/WrapUpTask.js";var e;class D{constructor(o){e.set(this,void 0),T(this,e,o,"f")}async run(o){const n=o,v=n.getInstanceOf(S),i=C(n)(y.Actions),t=v.worker,a=n.getInstanceOf(M),l=n.getInstanceOf(h);if(i.debug(`endTask invoked with taskSid: ${s(this,e,"f")}`),!t){const r="endTask: worker is not initialized";return i.error(r),Promise.reject(new d(c.SDK,{severity:f.Error},r))}if(!l){const r="endTask: CBM SDK is not initialized";return i.error(r),p(k.EndTaskCompleted,a,t,r),Promise.reject(new d(c.SDK,{severity:f.Error},r))}const w=P(t,s(this,e,"f")),m=w.find(r=>r.status==="accepted"),g=w.find(r=>r.status==="wrapping");if(!m&&!g){const r=`endTask: Reservation for task ${s(this,e,"f")} is not found`;return i.error(r),p(k.EndTaskCompleted,a,t,r),Promise.reject(new d(c.SDK,{severity:f.Error},r))}try{if(m&&I(m.task))return(await l.endConference(m)).task;if(g)return Promise.resolve(await new E(s(this,e,"f")).run(o));const{task:r}=await new _(s(this,e,"f")).run(o);return p(k.EndTaskCompleted,a,t),Promise.resolve(r)}catch(r){const u=`endTask: Could not end task: ${r.message}`;return p(k.EndTaskCompleted,a,t,u),Promise.reject(new d(c.SDK,{severity:f.Error},u))}}}e=new WeakMap;export{D as EndTask};
//# sourceMappingURL=EndTask.js.map
