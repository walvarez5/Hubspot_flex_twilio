/// <reference types="node" />

import { EventEmitter } from 'events';
import log from 'loglevel';
import { Reservation } from 'twilio-taskrouter';
import { Task } from 'twilio-taskrouter';
import { TaskRouterEventHandler } from 'twilio-taskrouter';
import { Worker as Worker_2 } from 'twilio-taskrouter';

/**
 * Accept the reservation
 * @param reservation - The reservation to be accepted
 * @returns Rejected if unable to issue Accept instruction on the reservation
 * @public
 */
declare function acceptReservation(reservation: Reservation): Promise<Reservation>;

/**
 * Add a participant to this task, currently only used for e-mail tasks
 * @param task - The task to add participant to
 * @param options - add email participant options
 * @returns Promise of a participant, rejected if unable to add participant to the task
 * @public
 */
declare function addEmailParticipant(task: Task, options: AddEmailParticipantOptions): Promise<CbmParticipant>;

/**
 * Add participant options
 * @public
 */
export declare type AddEmailParticipantOptions = {
    /**
     * Participant level in an email, possible values ['to', 'cc', 'bcc']
     */
    level: ParticipantLevel;
    /**
     * Full name of the customer
     */
    toName: string;
    /**
     * The e-mail address of the customer
     */
    address: string;
};

/**
 * Add a Participant to an Interaction Channel
 * @param interactionSid - The sid of the interaction to add participant to
 * @param interactionChannelSid - The sid of the channel to add participant to
 * @param participantType - The type of the participant to add
 * @param identity - (optional) The identity of the participant to add

 * @returns Rejected if unable to add participant
 * @public
 */
declare function addInteractionChannelParticipant(
interactionSid: string,
interactionChannelSid: string,
participantType: ParticipantType,
identity?: string
): Promise<Participant>;

/**
 * Add a SMS participant to this task
 * @param task - The task to add participant to
 * @param options - add sms participant options
 * @returns Promise of a participant, rejected if unable to add participant to the task
 * @public
 */
declare function addSmsParticipant(task: Task, options: AddSmsParticipantOptions): Promise<CbmParticipant>;

/**
 * Add SMS participant options
 * @public
 */
export declare type AddSmsParticipantOptions = {
    /**
     * Full name of the customer
     */
    toName: string;
    /**
     * The phone number of the sender (Twilio proxy number)
     */
    from: string;
    /**
     * The phone number of the customer
     */
    to: string;
};

/**
 * Add voice participant to the task
 * @param task - the task to add participant to
 * @param options - add voice participant options
 * @returns sid, channel sid, interaction sid and a promise of a participant, rejected if unable to add participant to the task
 * @public
 */
declare function addVoiceParticipant(
task: Task,
options: AddVoiceParticipantOptions
): Promise<AddVoiceParticipantResponse>;

/**
 * Media properties for add voice participant
 * @public
 */
declare type AddVoiceParticipantMediaProperties = {
    call?: ParticipantCallProperties;
    callSid?: string;
    muted?: boolean;
    beep?: string;
    startConferenceOnEnter?: boolean;
    endConferenceOnExit?: boolean;
    coaching?: boolean;
    hold?: boolean;
    callSidToCoach?: string;
    earlyMedia?: boolean;
    waitUrl?: string;
    waitMethod?: "GET" | "POST";
    transcribe?: boolean;
    transcriptionConfiguration?: string;
    jitterBufferSize?: string;
};

/**
 * Add voice participant options
 * @public
 */
export declare type AddVoiceParticipantOptions = {
    /**
     * Type of the voice participant, 'agent', 'customer', 'supervisor' or 'external'
     */
    type: ParticipantType;
    /**
     * The phone number the call is made from
     */
    from: string;
    /**
     * The phone number to call to
     */
    to: string;
    /**
     * Routing properties for the Agent participant
     */
    routingProperties?: RoutingProperties;
    /**
     * Media properties for the Agent participant
     */
    mediaProperties?: AddVoiceParticipantMediaProperties;
};

/**
 * Add voice participant response
 * @public
 */
export declare type AddVoiceParticipantResponse = {
    /**
     * Response for the adding participant request.
     */
    pendingParticipantResponse: ParticipantResponse;
    /**
     * Wait for the success or failure event for adding a Participant.
     */
    waitForParticipantToSettle: Promise<CbmParticipant>;
};

/**
 * Add a WebChat participant to this task
 * @param task - The task to add participant to
 * @param options - add web chat participant options
 * @returns Rejected if unable to add participant to the task
 * @public
 */
declare function addWebChatParticipant(task: Task, options: AddWebChatParticipantOptions): Promise<CbmParticipant>;

/**
 * Add web chat participant options
 * @public
 */
export declare type AddWebChatParticipantOptions = {
    /**
     * A unique participant identifier
     */
    identity: string;
};

/**
 * Add a WhatsApp participant to this task
 * @param task - The task to add participant to
 * @param options - add WhatsApp participant options
 * @returns Promise of a customer, rejected if not able to add a WhatsApp participant
 * @public
 */
declare function addWhatsAppParticipant(task: Task, options: AddWhatsAppParticipantOptions): Promise<CbmParticipant>;

/**
 * Add WhatsApp participant options
 * @public
 */
export declare type AddWhatsAppParticipantOptions = {
    /**
     * Full name of the customer
     */
    toName: string;
    /**
     * The phone number of the sender
     */
    from: string;
    /**
     * The phone number of the customer
     */
    to: string;
};

/**
 * A {@link CbmChannel} distinguishes tasks into specific types (e.g. Default, Chat, SMS, Video, Voice)
 * @public
 */
export declare interface CbmChannel {
    /**
     * The sid of this {@link CbmChannel} (UOxxx)
     */
    readonly sid: string;
    /**
     * The sid of the interaction
     */
    readonly interactionSid: string;
    /**
     * The type of the Channel associated to this {@link CbmChannel}
     */
    readonly type: MediaChannelType;
    /**
     * The status of this channel
     */
    readonly status: ChannelStatus;
    /**
     * The sid of the media meeting
     */
    readonly mediaSid: string;
}

/**
 * Construct a custom logger
 * @public
 */
export declare class CbmLogger {
    /**
     * @param moduleName - the name of the logging module
     * @param logLevel - the level to log, possible options ['trace', 'debug', 'info', 'warn', 'error', 'silent']
     */
    constructor(moduleName: string, logLevel?: LogLevel);
    trace(...args: any[]): void;
    debug(...args: any[]): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
    setLevel(level: string): void;
    getLogger(): log.Logger;
    getLevel(): string;
}

/**
 * Participant entity
 * @public
 */
export declare class CbmParticipant {
    /**
     * The sid of the participant (UTxxx)
     */
    readonly participantSid: string;
    /**
     * The type of the participant
     */
    readonly type: ParticipantType;
    /**
     * The type of the channel
     */
    readonly channelType: MediaChannelType;
    /**
     * The sid of the channel (UOxxx)
     */
    readonly channelSid: string;
    /**
     * The sid of the interaction (KDxxx)
     */
    readonly interactionSid: string;
    /**
     * The index of the last read message
     */
    readonly lastReadMessageIndex?: number;
    /**
     * The timestamp of the last read message
     */
    readonly lastReadTimestamp?: Date;
    /**
     * The routing properties of the participant
     */
    readonly routingProperties?: RoutingProperties;
    /**
     * Media properties of the participant
     */
    readonly mediaProperties?: MediaProperties;
    constructor(participantData: ParticipantEventData);
}

/**
 * Create a CbmSdkClient representing a TaskRouter CbmSdkClient
 * @public
 */
export declare class CbmSdk extends EventEmitter {
    /**
     * TaskRouter SDK's token
     */
    readonly token: string;
    constructor(token: string, options: CbmSdkClientOptions);
    /**
     * Add an Email participant to this task
     * @param task - The TR task to add participant to
     * @param options - add email participant options
     * @returns Promise of participant, rejected if unable to add participant to the task
     */
    addEmailParticipant: typeof addEmailParticipant;
    /**
     * Add a SMS participant to this task
     * @param task - The TR task to add participant to
     * @param options - add sms participant options
     * @returns Promise of a participant, rejected if unable to add participant to the task
     */
    addSmsParticipant: typeof addSmsParticipant;
    /**
     * Add a WhatsApp participant to this task
     * @param task - The TR task to add participant to
     * @param options - add WhatsApp participant options
     * @returns Promise of a participant, rejected if unable to add participant to the task
     */
    addWhatsAppParticipant: typeof addWhatsAppParticipant;
    /**
     * Add a WebChat participant to this task
     * @param task - The TR task to add participant to
     * @param options - add web chat participant options
     * @returns Promise of a participant, rejected if unable to add participant to the task
     */
    addWebChatParticipant: typeof addWebChatParticipant;
    /**
     * Add voice participant to the task
     * @param task - the TR task to add participant to
     * @param options - add voice participant options
     * @returns sid, channel sid, interaction sid and a promise of a participant, rejected if unable to add participant to the task
     */
    addVoiceParticipant: typeof addVoiceParticipant;
    /**
     * Add a participant to an interaction channel
     * @param interactionSid - The sid of the interaction to add the participant to
     * @param interactionChannelSid - The sid of the channel to add the participant to
     * @param participantType - The type of the participant to add
     * @param identity - (optional) The identity of the participant to add
     * @returns Promise of a participant, rejected if unable to add participant to the channel
     */
    addInteractionChannelParticipant: typeof addInteractionChannelParticipant;
    /**
     * Remove a participant from this task, currently only used for e-mail tasks
     * @param task - The TR task to remove participant from
     * @param sid - The conversation participant sid or universal participant sid
     * @returns Promise of a participant, rejected if unable to remove participant from the task
     */
    removeParticipant: typeof removeParticipant;
    /**
     * Remove a participant from this task
     * @param task - The TR task to remove participant from
     * @param sid - The conversation participant sid or universal participant sid
     * @returns Promise of a participant, rejected if unable to remove participant from the task
     */
    removeVoiceParticipant: typeof removeVoiceParticipant;
    /**
     * Get list of channels for the task
     * @param task - The TR task to get channels for
     * @returns Promise of an array of CbmChannel, rejected if unable to fetch channels for this task
     */
    getChannels: typeof getChannels;
    /**
     * Get list of participants in a {@link CbmChannel} for the task
     * @param task - The TR task to get participants for
     * @param channelSid - Sid of the {@link CbmChannel} the participants are requested for
     * @returns Promise of an array of participants, rejected if unable to fetch participants from a {@link CbmChannel} for this task
     */
    getParticipants: typeof getParticipants;
    /**
     * Accept the reservation
     * @param reservation - The TR reservation to be accepted
     * @returns Promise of a reservation, rejected if unable to issue Accept instruction on the reservation
     */
    acceptReservation: typeof acceptReservation;
    /**
     * Complete the reservation
     * @param reservation - The TR reservation to be completed
     * @returns Promise of a reservation, rejected if unable to complete the reservation
     */
    completeReservation: typeof completeReservation;
    /**
     * Hold the external conference participant associated to this task and specified ParticipantSid
     * @param task - The TR task associated to the conference on which a participant should be put on hold
     * @param participantSid - The target participant's sid
     * @returns Promise of a participant
     */
    holdParticipant: typeof holdParticipant;
    /**
     * Unhold the external conference participant associated to this task and specified ParticipantSid
     * @param task - The TR task associated to the conference on which a participant should be removed from hold
     * @param participantSid - The target participant's sid
     * @returns Promise of a participant
     */
    unHoldParticipant: typeof unHoldParticipant;
    /**
     * Ends the conference for all participants
     * @param task - The TR task associated with the conference
     * @return Sid, status and media_sid of
     */
    endConference: typeof endConference;
    /**
     * Set the flag to end conference for all participants after the agent exits
     * @param task - The task associated with the conference
     * @param participantSid - The target participant's sid
     * @param endConferenceOnExit - Conference will end after the agent exits
     * @returns Promise with ParticipantResponse
     */
    setEndConferenceOnExit: typeof setEndConferenceOnExit;
    /**
     * Reject the reservation
     * @param reservation - TR reservation to be rejected
     * @returns Promise of rejected reservation, rejected if unable to issue Reject instruction on the reservation
     */
    rejectReservation: typeof rejectReservation;
    /**
     * Wrap the reservation
     * @param reservation - TR reservation to be wrapped
     * @returns Promise of wrapped reservation, rejected if unable to issue Wrap instruction on the reservation
     */
    wrapReservation: typeof wrapReservation;
    /**
     * Create an Email Task
     * @param worker - The TR worker to whom to create the task
     * @param workflowSid - The Sid of the Workflow this Task should belong to (WWxxx)
     * @param taskQueueSid - The Sid of the taskqueue this Task should belong to, used for reporting
     *     purposes only (WQxxx)
     * @param options - Options for creating a task
     * @returns - Returns the TaskSid of the created Task. Rejected if unable to create a Task on behalf of the worker.
     */
    createEmailTask: typeof createEmailTask;
    /**
     * Create a WhatsApp Task
     * @param worker - The TR worker to whom to create the task
     * @param workflowSid - The Sid of the Workflow this Task should belong to (WWxxx)
     * @param taskQueueSid - The Sid of the taskqueue this Task should belong to, used for reporting
     *     purposes only (WQxxx)
     * @param options - Options for creating a task
     * @returns - Returns the TaskSid of the created Task. Rejected if unable to create a Task on behalf of the worker.
     */
    createWhatsAppTask: typeof createWhatsAppTask;
    /**
     * Create an SMS Task
     * @param worker - The TR worker to whom to create the task
     * @param workflowSid - The Sid of the Workflow this Task should belong to (WWxxx)
     * @param taskQueueSid - The Sid of the taskqueue this Task should belong to, used for reporting
     *     purposes only (WQxxx)
     * @param options - Options for creating a task
     * @returns - Returns the TaskSid of the created Task. Rejected if unable to create a Task on behalf of the worker.
     */
    createSmsTask: typeof createSmsTask;
    /**
     * Create a Web Task
     * @param worker - The TR worker to whom to create the task
     * @param workflowSid - The Sid of the Workflow this Task should belong to (WWxxx)
     * @param taskQueueSid - The Sid of the taskqueue this Task should belong to, used for reporting
     *     purposes only (WQxxx)
     * @param options - Options for creating a task
     * @returns - Returns the TaskSid of the created Task. Rejected if unable to create a Task on behalf of the worker.
     */
    createWebTask: typeof createWebTask;
    /**
     * Get custom logger which logs to console on given log level
     * @param prefix - module name
     * @returns custom logger which logs to console on given log level
     */
    getLogger(prefix: string): CbmLogger;
    /**
     * Update token
     * @param newToken - The new token that should be used for authentication
     * @returns Emits error if unable to update token
     */
    updateToken(newToken: string): void;
    /**
     * Leave the conversation
     * @deprecated Use leaveChannel instead
     * @param interactionSid - string,
     * @param channelSid - string
     * @param agentSid - string
     * @returns Promise of leave a conversation call
     */
    leaveConversation: typeof leaveConversation;
    /**
     * Leave the channel
     * @param interactionSid - string,
     * @param channelSid - string
     * @param agentSid - string
     * @returns Promise of leave a channel call
     */
    leaveChannel: typeof leaveChannel;
    /**
     * Create an InteractionChannel.
     * @param interactionSid - The sid of the interaction to create the channel for
     * @param channelMediaType - The type of the channel to create
     * @param initiatedBy - One of either: agent or customer
     * @param participants - An optional list of participants to add to the channel
     *
     * @returns Returns the ChannelSid and media properties of the created Channel. Rejected if unable to create a Channel.
     * @public
     */
    createInteractionChannel: typeof createInteractionChannel;
    /**
     * Update an InteractionChannel.
     * @param interactionSid - The sid of the interaction to create the channel for
     * @param interactionChannelSid - The sid of the interaction channel to update
     * @param status - The status to update to
     *
     * @returns Returns the ChannelSid, status and media properties. Rejected if update fails.
     * @public
     */
    updateInteractionChannel: typeof updateInteractionChannel;
    /**
     * Close an InteractionChannel.
     * @param interactionSid - The sid of the interaction to create the channel for
     * @param interactionChannelSid - The sid of the interaction channel to update
     *
     * @returns Returns the ChannelSid, status and media properties. Rejected if update fails.
     * @public
     */
    closeInteractionChannel: typeof closeInteractionChannel;
    /**
     * Pause the conversation
     * @param interactionSid - string
     * @param channelSid - string
     * @param taskStatus - string
     * @param routingStatus - string
     * @returns Promise of pause a conversation
     */
    pauseEmailConversation: typeof pauseEmailConversation;
    /**
     * Pause the channel
     * @param interactionSid - string
     * @param channelSid - string
     * @param taskStatus - string
     * @param routingStatus - string
     * @returns Promise of pause a channel
     */
    pauseChannel: typeof pauseChannel;
    /**
     * Resume the conversation
     * @param interactionSid - string
     * @param channelSid - string
     * @param taskStatus - string
     * @returns Promise of resume a conversation call
     */
    resumeEmailConversation: typeof resumeEmailConversation;
    /**
     * Resume the channel
     * @param interactionSid - string
     * @param channelSid - string
     * @param taskStatus - string
     * @returns Promise of resume a channel call
     */
    resumeChannel: typeof resumeChannel;
    /**
     * Get all paused tasks.
     * @param taskStatus - string
     * @param pageSize - number
     * @returns Promise of all paused conversations
     */
    getPausedEmailConversations: typeof getPausedEmailConversations;
    /**
     * Get all paused channels.
     * @param pageSize - number
     * @returns Promise of all paused channels
     */
    getPausedChannels: typeof getPausedChannels;
    /**
     * Transfer a channel to another Agent or Queue or Workspace in Warm or Cold mode.
     * @param instanceSid - Flex Instance SID
     * @param interactionSid - The unique interaction SID
     * @param channelSid - The unique meeting SID
     * @param type - Type of Transfer that can be initiated. warm or cold
     * @param from - Unique Participant Sid Identifier
     * @param to - Worker Sid or Workflow Sid or Queue Sid
     * @param noteSid - Optional Note Sid
     * @returns Transfer resource
     */
    transferChannel: typeof transferChannel;
    /**
     * Gets the list of Transfers for a channel
     * @param instanceSid - string
     * @param interactionSid - string
     * @param channelSid - string
     * @returns Promise of a list of Transfers
     */
    getChannelTransfers: typeof getChannelTransfers;
}

/**
 * Options for CbmSdkClient initiation
 * @public
 */
export declare type CbmSdkClientOptions = {
    /**
     * The sid of the connection activity
     */
    connectActivitySid?: string;
    /**
     * The EventBridge URI
     */
    ebServer?: string;
    /**
     * The WebSocket URI
     */
    wsServer?: string;
    /**
     * the realm for connections (ex. "stage-us1")
     */
    region?: string;
    /**
     * the ingress for connections (ex. "sydney")
     */
    edge?: string;
    /**
     * The level of logging to enable: ['error', 'warn', 'info', 'debug', 'trace', 'silent']
     */
    logLevel?: LogLevel;
    /**
     * The timeout in ms for waiting for events from BE
     */
    eventsTimeout?: number;
};

/**
 * Channel status
 * @public
 */
export declare enum ChannelStatus {
    Active = "active",
    Setup = "setup",
    Closed = "closed",
    Failed = "failed"
}

/**
 * Close an Interaction Channel.  Equivalent to updateInteractionChannel(interactionSid, interactionChannelSid, 'close')
 * @param interactionSid - The sid of the interaction to update the channel for
 * @param interactionChannelSid - The sid of the interaction channel to update
 * @returns Sid, status and possibly media_sid
 * @public
 */
declare function closeInteractionChannel(
interactionSid: string,
interactionChannelSid: string
): Promise<UpdateInteractionChannelResponse>;

/**
 * Complete the reservation
 * @param reservation - The reservation to be completed
 * @returns Rejected if unable to complete the reservation
 * @public
 */
declare function completeReservation(reservation: Reservation): Promise<Reservation>;

/**
 * Constructs the configuration for the worker
 * @class
 */
export declare class Configuration {
    /**
     * Worker's token
     */
    token: string;
    /**
     * Identifier for log
     */
    readonly logIdentifier: Date;
    /**
     * The EventBridge URI
     */
    readonly ebServer: string;
    /**
     * The WebSocket URI
     */
    readonly wsServer: string;
    /**
     * The level of logging to enable: ['error', 'warn', 'info', 'debug', 'trace', 'silent']
     */
    readonly logLevel: LogLevel;
    /**
     * Constructs the configuration for the worker
     * @constructor
     * @param token -
     * @param options -
     * @throws TwilioError
     */
    constructor(token: string, options?: ConfigurationOptions);
    /**
     * Update the token
     * @param newToken - The new token to be used
     */
    updateToken(newToken: string): void;
    /**
     * Get the identifier for log
     * @returns Date as an identifier for log
     */
    getLogIdentifier(): Date;
}

/**
 * Configuration options
 * @public
 */
export declare type ConfigurationOptions = {
    /**
     * The EventBridge URI
     */
    ebServer?: string;
    /**
     * The WebSocket URI
     */
    wsServer?: string;
    /**
     * the realm for connections (ex. "stage-us1")
     */
    region?: string;
    /**
     * the ingress for connections (ex. "sydney")
     */
    edge?: string;
    /**
     * The level of logging to enable: ['error', 'warn', 'info', 'debug', 'trace', 'silent']
     */
    logLevel?: LogLevel;
};

/**
 * Response for create task request,
 * @public
 */
export declare type CreateCbmTaskResponse = {
    interactionSid: string;
    taskSid: string;
};

/**
 * Participant parameters for createInteractionChannel method.
 * @public
 */
declare type CreateChannelParticipantParams = {
    type: ParticipantType;
    identity?: string;
};

/**
 * Create an Email Task
 * @param worker - The worker to whom to create the task
 * @param workflowSid - The Sid of the Workflow this Task should belong to
 * @param taskQueueSid - The Sid of the task queue this Task should belong to, used for reporting
 *     purposes only
 * @param options - Options for the task creation request
 * @returns Returns the TaskSid of the created Task. Rejected if unable to create a Task on behalf of the worker.
 * @public
 */
declare function createEmailTask(
worker: Worker_2,
workflowSid: string,
taskQueueSid: string,
options: CreateEmailTaskOptions
): Promise<CreateCbmTaskResponse>;

/**
 * Additional parameters to createEmailTask method
 * @public
 */
export declare type CreateEmailTaskOptions = {
    /**
     * The contact uri of the customer.
     */
    to: string;
    /**
     * The contact uri of the worker.
     */
    from: string;
    /**
     * Who is the initiater
     */
    fromName?: string;
    /**
     * Who is the receiver
     */
    toName?: string;
    /**
     * Task's unique channel name
     */
    taskUniqueChannelName?: string;
    /**
     * Task's channel identifier
     */
    taskChannelSid?: string;
    /**
     * Attributes to the request
     */
    attributes?: Object;
};

/**
 * Create an Interaction Channel.
 * @param interactionSid - The sid of the interaction to create the channel for
 * @param channelMediaType - The type of the channel to create
 * @param initiatedBy - One of either: agent or customer
 * @param participants - An optional list of participants to add to the channel
 *
 * @returns Returns an CreateInteractionChannelResponse
 * @public
 */
declare function createInteractionChannel(
interactionSid: string,
channelMediaType: MediaChannelType,
initiatedBy: string,
participants?: [CreateChannelParticipantParams]
): Promise<InteractionChannel>;

/**
 * Create an SMS Task
 * @param worker - The worker to whom to create the task
 * @param workflowSid - The Sid of the Workflow this Task should belong to
 * @param taskQueueSid - The Sid of the task queue this Task should belong to, used for reporting
 *     purposes only
 * @param options - Options for the task creation request
 * @returns Returns the TaskSid of the created Task. Rejected if unable to create a Task on behalf of the worker.
 * @public
 */
declare function createSmsTask(
worker: Worker_2,
workflowSid: string,
taskQueueSid: string,
options: CreateSmsTaskOptions
): Promise<CreateCbmTaskResponse>;

/**
 * Additional parameters to createSmsTask method
 * @public
 */
export declare type CreateSmsTaskOptions = {
    /**
     * The contact uri of the customer.
     */
    to: string;
    /**
     * The contact uri of the worker.
     */
    from: string;
    /**
     * Who is the receiver
     */
    toName?: string;
    /**
     * Task's unique channel name
     */
    taskUniqueChannelName?: string;
    /**
     * Task's channel identifier
     */
    taskChannelSid?: string;
    /**
     * Attributes to the request
     */
    attributes?: Object;
};

/**
 * Create a Web Task
 * @param worker - The worker to whom to create the task
 * @param workflowSid - The Sid of the Workflow this Task should belong to
 * @param taskQueueSid - The Sid of the task queue this Task should belong to, used for reporting
 *     purposes only
 * @param options - Options for the task creation request
 * @returns Returns the TaskSid of the created Task. Rejected if unable to create a Task on behalf of the worker.
 * @public
 */
declare function createWebTask(
worker: Worker_2,
workflowSid: string,
taskQueueSid: string,
options: CreateWebTaskOptions
): Promise<CreateCbmTaskResponse>;

/**
 * Additional parameters to createWebTask method
 * @public
 */
export declare type CreateWebTaskOptions = {
    /**
     * The contact uri of the customer.
     */
    to: string;
    /**
     * Task's unique channel name
     */
    taskUniqueChannelName?: string;
    /**
     * Task's channel identifier
     */
    taskChannelSid?: string;
    /**
     * Attributes to the request
     */
    attributes?: Object;
};

/**
 * Create a WhatsApp Task
 * @param worker - The worker to whom to create the task
 * @param workflowSid - The Sid of the Workflow this Task should belong to
 * @param taskQueueSid - The Sid of the task queue this Task should belong to, used for reporting
 *     purposes only
 * @param options - Options for the task creation request
 * @returns Returns the TaskSid of the created Task. Rejected if unable to create a Task on behalf of the worker.
 * @public
 */
declare function createWhatsAppTask(
worker: Worker_2,
workflowSid: string,
taskQueueSid: string,
options: CreateWhatsAppTaskOptions
): Promise<CreateCbmTaskResponse>;

/**
 * Additional parameters to createWhatsAppTask method
 * @public
 */
export declare type CreateWhatsAppTaskOptions = {
    /**
     * The contact uri of the customer.
     */
    to: string;
    /**
     * The contact uri of the worker.
     */
    from: string;
    /**
     * Who is the receiver
     */
    toName?: string;
    /**
     * Task's unique channel name
     */
    taskUniqueChannelName?: string;
    /**
     * Task's channel identifier
     */
    taskChannelSid?: string;
    /**
     * Attributes to the request
     */
    attributes?: Object;
};

/**
 * Ends the conference for all participants
 * @param task - The task assosiated with the conference
 * @returns Sid, status and possibly media_sid of the conference
 * @public
 */
declare function endConference(task: Task): Promise<EndConferenceResponse>;

/**
 * Response for ending conference
 * @public
 */
export declare type EndConferenceResponse = {
    /**
     * Channel identifier
     */
    sid: string;
    /**
     * Task status
     */
    status: string;
    /**
     * Media identifier
     */
    media_sid?: string;
};

/**
 * Get list of channels for the task
 * @param task - The task to get channels for
 * @returns Rejected if unable to fetch channels for this task
 * @public
 */
declare function getChannels(task: Task): Promise<CbmChannel[]>;

/**
 * Gets the list of Transfers for a channel
 * @param instanceSid - string
 * @param interactionSid - string
 * @param channelSid - string
 * @returns Promise of a list of Transfers
 */
declare function getChannelTransfers(
instanceSid: string,
interactionSid: string,
channelSid: string
): Promise<Transfer[]>;

/**
 * Get list of participants in a {@link CbmChannel} for the task
 * @param task - The task to get participants for
 * @param channelSid - Sid of the {@link CbmChannel} the participants are requested for
 * @param options - Optional parameters
 * @returns An array of participants. Rejected if unable to fetch participants from a {@link CbmChannel} for this task
 * @public
 */
declare function getParticipants(task: Task, channelSid: string, options?: Options_2): Promise<CbmParticipant[]>;

/**
 * Get all paused channels
 * @param pageSize - number
 * @returns Promise of paused channels call
 */
declare function getPausedChannels(pageSize: number): Promise<PausedChannelsResponse>;

/**
 * Get all paused tasks
 * @param taskStatus - string
 * @param pageSize - number
 * @returns Promise of paused conversations call
 * @deprecated Use getPausedChannels instead
 */
declare function getPausedEmailConversations(
taskStatus: string,
pageSize: number
): Promise<PausedEmailConversationsResponse>;

/**
 * Hold the external conference participant associated to this task and specified ParticipantSid
 * @param task - The task assosiated to the conference on which a participant should be put on hold
 * @param participantSid - The target participant's sid
 * @returns Promise of a participant
 * @public
 */
declare function holdParticipant(task: Task, participantSid: string): Promise<CbmParticipant>;

/**
 * Interaction Channel entity
 * @public
 */
declare type InteractionChannel = {
    sid: string;
    interactionSid: string;
    type: string;
    status: string;
    mediaSid: string;
    mediaProperties: MediaProperties;
};

/**
 * Leave the conversation
 * @param interactionSid - string,
 * @param channelSid - string
 * @param channelStatus - string
 * @param taskStatus - string
 * @returns Promise of leave a conversation call
 */
declare function leaveChannel(
interactionSid: string,
channelSid: string,
channelStatus: string,
taskStatus: string
): Promise<LeaveChannelResponse>;

/**
 * LeaveChannelResponse Response
 * @public
 */
declare type LeaveChannelResponse = {
    action: "leave";
    participants: [
        {
        sid: string;
        interaction_sid: string;
        channel_sid: string;
        participant_sid: string;
        type: string;
        media_properties: MediaProperties | null;
        routing_properties: RoutingData | null;
    }
    ];
};

/**
 * Leave the conversation
 * @param interactionSid - string,
 * @param channelSid - string
 * @param channelStatus - string
 * @param taskStatus - string
 * @returns Promise of leave a conversation call
 * @deprecated Use leaveChannel instead
 */
declare function leaveConversation(
interactionSid: string,
channelSid: string,
channelStatus: string,
taskStatus: string
): Promise<LeaveConversationResponse>;

/**
 * LeaveConversation Response
 * @public
 * @deprecated Use LeaveChannelResponse instead
 */
declare type LeaveConversationResponse = {
    action: "leave";
    participants: [
        {
        sid: string;
        interaction_sid: string;
        channel_sid: string;
        participant_sid: string;
        type: string;
        media_properties: MediaProperties | null;
        routing_properties: RoutingData | null;
    }
    ];
};

/**
 * Possible log levels
 * @public
 */
export declare enum LogLevel {
    Trace = "trace",
    Debug = "debug",
    Info = "info",
    Warn = "warn",
    Error = "error",
    Silent = "silent"
}

/**
 * Media channel type
 * @public
 */
export declare enum MediaChannelType {
    Email = "email",
    Sms = "sms",
    WhatsApp = "whatsapp",
    Web = "web",
    Voice = "voice",
    Messenger = "messenger",
    Chat = "chat",
    Gbm = "gbm",
    Video = "video"
}

/**
 * Media properties
 * @public
 */
export declare type MediaProperties = {
    [key: string]: any;
};

/**
 * Remove a participant from this task, currently used for e-mail tasks and Digital Transferred Tasks
 * @param task - The task to remove participant from
 * @param sid - The conversation participant sid or universal participant sid
 * @returns Promise of a participant, rejected if unable to remove participant from the task
 * @public
 */
declare interface Options {
    closeChannelIfLastParticipant?: boolean;
}

declare interface Options_2 {
    status?: string;
}

/**
 * A direct mapping of Interaction Channel Participant
 * @public
 */
declare type Participant = {
    /**
     * The sid of the participant (UTxxx)
     */
    sid: string;
    /**
     * The type of the participant
     */
    type: ParticipantType;
    /**
     * The sid of the channel (UOxxx)
     */
    channelSid: string;
    /**
     * Media properties of the participant
     */
    mediaProperties: MediaProperties | null;
};

/**
 * Call properties for add voice participant
 * @public
 */
declare type ParticipantCallProperties = {
    timeout: number;
    statusCallBack: ParticipantCallStatusProperties;
    record: ParticipantCallRecordProperties;
    sip: ParticipantSipProperties;
};

/**
 * Call record properties for add voice participant
 * @public
 */
declare type ParticipantCallRecordProperties = {
    url: string;
    method: "GET" | "POST";
    channels: string;
};

/**
 * Call status properties for add voice participant
 * @public
 */
declare type ParticipantCallStatusProperties = {
    url: string;
    method: "GET" | "POST";
    events: string;
};

/**
 * Data of a participant received from REST API endpoints
 * @public
 */
export declare type ParticipantData = {
    /**
     * The sid of the participant (UTxxx)
     */
    sid: string;
    /**
     * The type of the participant
     */
    type: ParticipantType;
    /**
     * The type of the channel
     */
    channel_type: MediaChannelType;
    /**
     * The sid of the channel (UOxxx)
     */
    channel_sid: string;
    /**
     * The sid of the interaction (KDxxx)
     */
    interaction_sid: string;
    /**
     * The routing properties of the participant
     */
    routing_properties: RoutingData | null;
    /**
     * Media properties of the participant
     */
    media_properties: MediaProperties | null;
};

/**
 * Data of a participant received from events
 * @public
 */
export declare type ParticipantEventData = {
    /**
     * The sid of the participant (UTxxx)
     */
    participant_sid: string;
    /**
     * The type of the participant
     */
    type: ParticipantType;
    /**
     * The type of the channel
     */
    channel_type: MediaChannelType;
    /**
     * The sid of the channel (UOxxx)
     */
    channel_sid: string;
    /**
     * The sid of the interaction (KDxxx)
     */
    interaction_sid: string;
    /**
     * The routing properties of the participant
     */
    routing_properties: RoutingData | null;
    /**
     * Media properties of the participant
     */
    media_properties: MediaProperties | null;
};

/**
 * Handler for Participant events
 * @public
 */
export declare class ParticipantEventHandler extends TaskRouterEventHandler {
    readonly _worker: Worker_2;
    readonly _logLevel: LogLevel;
    readonly _log: CbmLogger;
    constructor(worker: Worker_2, options?: ParticipantEventHandlerOptions);
    getTREventsToHandlerMapping(): {
        [key: string]: string;
    };
    _participantEventHandler(eventData: ParticipantEventData, eventType: string): void;
}

/**
 * LogLevel for ParticipantEventHandler
 * @public
 */
export declare type ParticipantEventHandlerOptions = {
    logLevel?: LogLevel;
};

/**
 * Participant level in an email
 * @public
 */
export declare enum ParticipantLevel {
    To = "to",
    CC = "cc",
    BCC = "bcc"
}

/**
 * Response for the participant endpoint request
 * @public
 */
export declare type ParticipantResponse = {
    /**
     * The identifier of the participant who is added to the channel
     */
    sid: string;
    /**
     * The channel sid of the channel where the participant is added
     */
    channel_sid: string;
    /**
     * The identifier of the interaction  where the participant is added
     */
    interaction_sid: string;
    /**
     * Optional media properties of the participant
     */
    media_properties: MediaProperties | null;
};

/**
 * Sip properties for add voice participant
 * @public
 */
declare type ParticipantSipProperties = {
    username: string;
    password: string;
};

/**
 * Type of the participant, 'agent', 'customer', 'supervisor', 'external' or 'unknown'
 * @public
 */
export declare enum ParticipantType {
    Agent = "agent",
    Customer = "customer",
    Supervisor = "supervisor",
    External = "external",
    Unknown = "unknown"
}

/**
 * Pause the channel
 * @param interactionSid - string
 * @param channelSid - string
 * @param taskStatus - string
 * @param routingStatus - string
 * @returns Promise of pause a channel
 */
declare function pauseChannel(
interactionSid: string,
channelSid: string,
taskStatus: string,
routingStatus: string
): Promise<PauseChannelResponse>;

/**
 * PauseChannelResponse Response
 * @public
 */
declare type PauseChannelResponse = {
    sid: string;
    interaction_sid: string;
    type: string;
    status: string;
    error_code: string;
    error_message: string;
};

/**
 * PausedChannelsResponse Response
 * @public
 */
declare type PausedChannelsResponse = {
    content: [
        {
        sid: string;
        account_sid: string;
        interaction_sid: string;
        workspace_sid: string;
        workflow_sid: string;
        wds_queue_sid: string;
        participant_sid: string;
        task_channel_sid: string;
        attributes: {
            customerAddress: string;
            flexChannelInviteSid: string;
            conversationSid: string;
            channelType: string;
            customers: {
                email: string;
            };
            conversations: {
                initiated_by: string;
                conversation_id: string;
                media: [
                    {
                    conversation_sid: string;
                    type: string;
                }
                ];
                external_contact: string;
            };
            flexInteractionChannelSid: string;
            initiatedBy: string;
            flexInteractionSid: string;
            direction: string;
        };
        date_created: string;
        date_updated: string;
        action: string;
        agent_identity: string;
    }
    ];
};

/**
 * PausedEmailConversations Response
 * @public
 */
declare type PausedEmailConversationsResponse = {
    content: [
        {
        sid: string;
        account_sid: string;
        interaction_sid: string;
        workspace_sid: string;
        workflow_sid: string;
        wds_queue_sid: string;
        participant_sid: string;
        task_channel_sid: string;
        attributes: {
            customerAddress: string;
            flexChannelInviteSid: string;
            conversationSid: string;
            channelType: string;
            customers: {
                email: string;
            };
            conversations: {
                initiated_by: string;
                conversation_id: string;
                media: [
                    {
                    conversation_sid: string;
                    type: string;
                }
                ];
                external_contact: string;
            };
            flexInteractionChannelSid: string;
            initiatedBy: string;
            flexInteractionSid: string;
            direction: string;
        };
        date_created: string;
        date_updated: string;
        action: string;
        agent_identity: string;
    }
    ];
};

/**
 * Pause the conversation
 * @param interactionSid - string
 * @param channelSid - string
 * @param taskStatus - string
 * @param routingStatus - string
 * @returns Promise of pause a conversation
 * @deprecated Use pauseChannel instead
 */
declare function pauseEmailConversation(
interactionSid: string,
channelSid: string,
taskStatus: string,
routingStatus: string
): Promise<PauseEmailConversationResponse>;

/**
 * PauseEmailConversation Response
 * @public
 */
declare type PauseEmailConversationResponse = {
    sid: string;
    interaction_sid: string;
    type: string;
    status: string;
    error_code: string;
    error_message: string;
};

/**
 * Reject the reservation
 * @param reservation - reservation to be rejected
 * @returns Promise of a reservation, rejected if unable to issue Reject instruction on the reservation
 * @public
 */
declare function rejectReservation(reservation: Reservation): Promise<Reservation>;

declare function removeParticipant(task: Task, sid: string, options?: Options): Promise<CbmParticipant>;

/**
 * Remove a participant from this task
 * @param task - The task to remove participant from
 * @param sid - The conversation participant sid or universal participant sid
 * @returns Promise of a participant, rejected if unable to remove participant from the task
 * @public
 */
declare function removeVoiceParticipant(task: Task, sid: string): Promise<CbmParticipant>;

/**
 * Resume the channel
 * @param interactionSid - string
 * @param channelSid - string
 * @param taskStatus - string
 * @returns Promise of resume a channel call
 */
declare function resumeChannel(
interactionSid: string,
channelSid: string,
taskStatus: string
): Promise<ResumeChannelResponse>;

/**
 * ResumeChannel Response
 * @public
 */
declare type ResumeChannelResponse = {
    sid: string;
    interaction_sid: string;
    type: string;
    status: string;
    created_at: string;
    updated_at: string;
    error_code: string;
    error_message: string;
};

/**
 * Resume the conversation
 * @param interactionSid - string
 * @param channelSid - string
 * @param taskStatus - string
 * @returns Promise of resume a conversation call
 * @deprecated Use resumeChannel instead
 */
declare function resumeEmailConversation(
interactionSid: string,
channelSid: string,
taskStatus: string
): Promise<ResumeEmailConversationResponse>;

/**
 * ResumeEmailConversation Response
 * @public
 */
declare type ResumeEmailConversationResponse = {
    sid: string;
    interaction_sid: string;
    type: string;
    status: string;
    created_at: string;
    updated_at: string;
    error_code: string;
    error_message: string;
};

/**
 * Data used for routing
 * @public
 */
export declare type RoutingData = {
    /**
     * Sid of a task this routing data corresponds to (WTxxx)
     */
    task_sid: string;
    /**
     * Sid of a worker this routing data corresponds to (WKxxx)
     */
    worker_sid?: string;
    /**
     * Sid of a reservation this routing data corresponds to (WRxxx)
     */
    reservation_sid?: string;
};

/**
 * Routing properties of one participant
 * @public
 */
export declare class RoutingProperties {
    /**
     * Sid of a task these routing properties correspond to (WTxxx)
     */
    readonly taskSid: string;
    /**
     * Sid of a worker these routing properties correspond to (WKxxx)
     */
    readonly workerSid?: string;
    /**
     * Sid of a reservation these routing properties correspond to (WRxxx)
     */
    readonly reservationSid?: string;
    constructor(routingData: RoutingData);
}

/**
 * Set the flag to end conference for all participants after the agent exits
 * @param task - The task associated with the conference
 * @param participantSid - The target participant's sid
 * @param endConferenceOnExit - Conference will end, after agent exits
 * @returns Promise with ParticipantResponse
 * @public
 */
declare function setEndConferenceOnExit(
task: Task,
participantSid: string,
endConferenceOnExit: boolean
): Promise<ParticipantResponse>;

declare type Transfer = {
    sid: string;
    accountSid: string;
    instanceSid: string;
    interactionSid: string;
    channelSid: string;
    type: string;
    from: string;
    to: string;
    status: string;
    executionSid: string;
    noteSid: string;
    summarySid: string;
    reason: string;
    dateCreated: string;
    dateUpdated: string;
};

/**
 * Transfer a channel to another Agent or Queue or Workspace in Warm or Cold mode.
 * @param instanceSid - Flex Instance SID
 * @param interactionSid - The unique interaction SID
 * @param channelSid - The unique meeting SID
 * @param type - Type of Transfer that can be initiated. warm or cold
 * @param from - Unique Participant Sid Identifier
 * @param to - Worker Sid or Workflow Sid or Queue Sid
 * @param noteSid - Optional Note Sid
 * @returns Transfer resource
 */
declare function transferChannel(
instanceSid: string,
interactionSid: string,
channelSid: string,
from: string,
to: string,
noteSid?: string,
type?: "warm" | "cold"
): Promise<TransferChannelResponse>;

declare type TransferChannelResponse = {
    sid: string;
    account_sid: string;
    instance_sid: string;
    interaction_sid: string;
    channel_sid: string;
    execution_sid: string;
    summarySid: string | null;
    type: "warm" | "cold";
    from: string;
    to: string;
    status: string;
    note_sid: string;
};

/**
 * Unhold the external conference participant associated to this task and specified ParticipantSid
 * @param task - The task assosiated to the conference on which a participant should be removed from hold
 * @param participantSid - The target participant's sid
 * @returns Promise of a participant
 * @public
 */
declare function unHoldParticipant(task: Task, participantSid: string): Promise<CbmParticipant>;

/**
 * Update an Interaction Channel
 * @param interactionSid - The sid of the interaction to update the channel for
 * @param interactionChannelSid - The sid of the interaction channel to update
 * @param status - The status to update the channel to
 * @returns Sid, status and possibly media_sid
 * @public
 */
declare function updateInteractionChannel(
interactionSid: string,
interactionChannelSid: string,
status: string
): Promise<UpdateInteractionChannelResponse>;

/**
 * Response for updating an Interaction Channel
 * @public
 */
declare type UpdateInteractionChannelResponse = {
    /**
     * Channel identifier
     */
    sid: string;
    /**
     * Task status
     */
    status: string;
    /**
     * Media identifier
     */
    media_sid?: string;
};

/**
 * Wrap the reservation
 * @param reservation - reservation to be wrapped
 * @returns - Rejected if unable to issue Wrap instruction on the reservation
 * @public
 */
declare function wrapReservation(reservation: Reservation): Promise<Reservation>;

export { }
