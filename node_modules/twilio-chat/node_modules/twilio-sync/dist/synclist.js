/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2016, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

This software includes Backoff library under the following license

    Copyright (C) 2012 Mathieu Turcotte

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is furnished to do
    so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

This software includes Event-to-Promise library under the following license

    Copyright (c) 2014, Julien Fontanet <julien.fontanet@isonoe.net>.

    Permission to use, copy, modify, and/or distribute this software for any purpose
    with or without fee is hereby granted, provided that the above copyright notice
    and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
    OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
    TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
    THIS SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib_es6 = require('./node_modules/tslib/tslib.es6.js');
var sanitize = require('./utils/sanitize.js');
var uri = require('./utils/uri.js');
var syncerror = require('./utils/syncerror.js');
var logger = require('./utils/logger.js');
var entity = require('./entity.js');
var synclistitem = require('./synclistitem.js');
var paginator = require('./paginator.js');
var itemsCache = require('./itemsCache.js');
var mergingqueue = require('./mergingqueue.js');
var closeable = require('./closeable.js');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');
require('./node_modules/lodash/lodash.js');
var lodash = require('./_virtual/lodash.js');

class SyncListImpl extends entity.SyncEntity {
    /**
     * @private
     */
    constructor(services, descriptor, removalHandler) {
        super(services, removalHandler);
        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }
            : acc;
        this.updateMergingQueue = new mergingqueue.NamespacedMergingQueue(updateRequestReducer);
        this.cache = new itemsCache.ItemsCache();
        this.descriptor = descriptor;
        this.descriptor.date_updated = new Date(this.descriptor.date_updated);
    }
    // private props
    get uri() {
        return this.descriptor.url;
    }
    get revision() {
        return this.descriptor.revision;
    }
    get lastEventId() {
        return this.descriptor.last_event_id;
    }
    get links() {
        return this.descriptor.links;
    }
    get dateExpires() {
        return this.descriptor.date_expires;
    }
    static get type() {
        return 'list';
    }
    get type() {
        return 'list';
    }
    // below properties are specific to Insights only
    get indexName() {
        return undefined;
    }
    get queryString() {
        return undefined;
    }
    // public props, documented along with class description
    get sid() {
        return this.descriptor.sid;
    }
    get uniqueName() {
        return this.descriptor.unique_name || null;
    }
    get dateUpdated() {
        return this.descriptor.date_updated;
    }
    async _addOrUpdateItemOnServer(url, data, ifMatch, ttl) {
        const requestBody = { data };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        const response = await this.services.network.post(url, requestBody, ifMatch);
        response.body.data = data;
        response.body.date_updated = new Date(response.body.date_updated);
        return response.body;
    }
    async push(value, itemMetadata) {
        let ttl = (itemMetadata || {}).ttl;
        let item = await this._addOrUpdateItemOnServer(this.links.items, value, undefined, ttl);
        let index = Number(item.index);
        this._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);
        return this.cache.getValue(index);
    }
    async set(index, value, itemMetadataUpdates) {
        const input = itemMetadataUpdates || {};
        return this.updateMergingQueue.squashAndAdd(index, input, (input) => this._updateItemUnconditionally(index, value, input.ttl));
    }
    async _updateItemUnconditionally(index, data, ttl) {
        let existingItem = await this.get(index);
        const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.url, data, undefined, ttl);
        this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);
        return this.cache.getValue(index);
    }
    async _updateItemWithIfMatch(index, mutatorFunction, ttl) {
        const existingItem = await this.get(index);
        const data = mutatorFunction(sanitize.deepClone(existingItem.data));
        if (data) {
            const ifMatch = existingItem.revision;
            try {
                const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.url, data, ifMatch, ttl);
                this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);
                return this.cache.getValue(index);
            }
            catch (error) {
                if (error.status === 412) {
                    await this._getItemFromServer(index);
                    return this._updateItemWithIfMatch(index, mutatorFunction, ttl);
                }
                else {
                    throw error;
                }
            }
        }
        else {
            return existingItem;
        }
    }
    async mutate(index, mutator, itemMetadataUpdates) {
        const input = itemMetadataUpdates || {};
        return this.updateMergingQueue.add(index, input, (input) => this._updateItemWithIfMatch(index, mutator, input.ttl));
    }
    async update(index, obj, itemMetadataUpdates) {
        return this.mutate(index, remote => Object.assign(remote, obj), itemMetadataUpdates);
    }
    async remove(index) {
        const item = await this.get(index);
        const previousItemData = sanitize.deepClone(item.data);
        const response = await this.services.network.delete(item.url);
        this._handleItemRemoved(index, response.body.last_event_id, previousItemData, new Date(response.body.date_updated), false);
    }
    async get(index) {
        let cachedItem = this.cache.get(index);
        if (cachedItem) {
            return cachedItem.value;
        }
        return this._getItemFromServer(index);
    }
    async _getItemFromServer(index) {
        // queryItemsFromServer is used only here!
        let result = await this._queryItemsFromServer({ index });
        if (result.items.length < 1) {
            throw new syncerror.SyncError(`No item with index ${index} found`, 404, 54151);
        }
        else {
            return result.items[0];
        }
    }
    /**
     * Query items from the List
     * @param args Argument pack for the query.
     *             May include the following parameters:
     *
     *             - index -- Returns the Item with the specified index or an empty items array, if one doesn't exist.
     *             - from -- Item index offset specifying the starting point of the query (inclusive). If not specified,
     *                       the query starts from either the first or the last item in the List (by index),
     *                       depending on the Order query parameter.
     *             - order -- String(Optional) -- Determines the order of the query. Items are ordered numerically by index.
     *                                            One of {asc, desc}, defaults to asc.
     *             - pageSize -- Maximum number of Items in the response (i.e. in this page). Defaults to 50.
     *                           The max page size is 1000. Note: PageSize between 100 and 1000 returns at most 100 items.
     *             - pageToken - Direct paging token, for starting from a specific page.
     *             - Metadata - May have the value list. If specified, returns the state of the List in the list attribute of the response.
     *             - HideExpired - Determines whether expired List items are filtered out from the result list. By default, is false.
     *
     *             Stuff not accepted by the service, internal to SDK:
     *
     *             - limit
     *
     *   Valid query parameter combinations
     *   These are the valid query parameter combinations. [x] should be read as “if x is not provided, the default value is assumed”.
     *   The combinations are in order of precedence - e.g., if both Index and PageToken are provided, PageToken is ignored.
     *   +-----------------------------------------+------------------------------------------------------------------------------+
     *   | Index, [Metadata]                       | Returns 0-1 Items with the given Index                                       |
     *   | PageToken, [Metadata]                   | Returns a page based on the PageToken returned from a previous query,        |
     *   |                                         | with this and all following pages modified by any provided query parameters. |
     *   | [From], [Order], [Pagesize], [Metadata] | Performs an initial query from a specified offset.                           |
     *   |                                         | Returned PageTokens in the meta block should be used for pagination.         |
     *   +-----------------------------------------+------------------------------------------------------------------------------+
     * @private
     */
    async queryItems(args) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        // If the index is specified, fetch only a single item.
        if (args.index) {
            const cached = this.cache.get(args.index);
            if (cached) {
                return this.makePaginator(cached.isValid ? [cached.value] : [], args, false, false);
            }
            return this._querySingleItemFromServer(args.index);
        }
        // If a paginator calls here with nextPageItemId or prevPageItemId it means we are trying to fetch a next or previous
        // page accordingly. the task is to determine the direction (based on args.order and direction of queried page) and
        // prefill it from the cache as much as possible.
        const fillingSubsequentPage = !!args.nextPageItemId || !!args.prevPageItemId;
        const oldArgs = Object.assign({}, args);
        if (fillingSubsequentPage) {
            args.from = (_b = (_a = args.nextPageItemId) !== null && _a !== void 0 ? _a : args.prevPageItemId) !== null && _b !== void 0 ? _b : args.from;
        }
        const goingBackwards = !!args.prevPageItemId;
        // If from and order are specified, fetch page of items.
        let cacheIterator = args.order === 'desc'
            ? (goingBackwards
                ? this.cache.getIterator((_d = (_c = args.prevPageItemId) !== null && _c !== void 0 ? _c : args.from) !== null && _d !== void 0 ? _d : null)
                : this.cache.getReverseIterator((_f = (_e = args.nextPageItemId) !== null && _e !== void 0 ? _e : args.from) !== null && _f !== void 0 ? _f : null))
            : (goingBackwards
                ? this.cache.getReverseIterator((_h = (_g = args.prevPageItemId) !== null && _g !== void 0 ? _g : args.from) !== null && _h !== void 0 ? _h : null)
                : this.cache.getIterator((_k = (_j = args.nextPageItemId) !== null && _j !== void 0 ? _j : args.from) !== null && _k !== void 0 ? _k : null));
        let cachedItems = [];
        const itemsCountToGet = fillingSubsequentPage ? args.limit + 1 : args.limit;
        for (let item of cacheIterator) {
            if (fillingSubsequentPage && item.value.index == args.from) {
                continue;
            }
            cachedItems.push(item.value);
            if (cachedItems.length >= args.limit) {
                if (goingBackwards) {
                    lodash.lodash.exports.reverse(cachedItems);
                }
                // We've got a full page of items, so we can easily generate prev/next page navigation
                // However, the first item in the page cannot be collectionBegin, and the last item cannot be collectionEnd
                return this.makePaginator(cachedItems, args, this._prevPageAllowed(cachedItems, args.order), this._nextPageAllowed(cachedItems, args.order));
            }
        }
        // cache was not enough, so continue fetching from the server in the same direction
        // whatever the last fetched item was, it will be the next `from`
        if (cachedItems.length > 0) {
            args.from = lodash.lodash.exports.last(cachedItems).index;
        }
        // Maximum sync page size is 100 items, 10 is simply 1/10th of that.
        const getLimit = Math.max(itemsCountToGet - cachedItems.length, 10);
        if (goingBackwards) {
            args.order = args.order === 'desc' ? 'asc' : 'desc';
        }
        const doFetch = args.from !== (oldArgs.order === 'desc'
            ? (goingBackwards ? this.cache.collectionEnd : this.cache.collectionBegin)
            : (goingBackwards ? this.cache.collectionBegin : this.cache.collectionEnd));
        if (doFetch) {
            const fetchedItems = await this._queryItemsFromServer(Object.assign(Object.assign({}, args), { limit: getLimit }));
            const items = fetchedItems.items;
            this.cache.populate(items, !fetchedItems.hasPrevPage, !fetchedItems.hasNextPage);
            for (let item of items) {
                if ((cachedItems.length > 0 || fillingSubsequentPage) && item.index == args.from) {
                    // Skip the key we already have in cachedItems
                    continue;
                }
                if (goingBackwards) {
                    cachedItems.unshift(item);
                }
                else {
                    cachedItems.push(item);
                }
                if (cachedItems.length >= args.limit) {
                    break;
                }
            }
        }
        else {
            if (goingBackwards) {
                lodash.lodash.exports.reverse(cachedItems);
            }
        }
        return this.makePaginator(cachedItems, oldArgs, this._prevPageAllowed(cachedItems, oldArgs.order), this._nextPageAllowed(cachedItems, oldArgs.order));
    }
    _prevPageAllowed(items, order) {
        return items.length > 0 && lodash.lodash.exports.head(items).index !== (order === 'desc' ? this.cache.collectionEnd : this.cache.collectionBegin);
    }
    _nextPageAllowed(items, order) {
        return items.length > 0 && lodash.lodash.exports.last(items).index !== (order === 'desc' ? this.cache.collectionBegin : this.cache.collectionEnd);
    }
    // Paginator depends on:
    // - items listed
    // - was there a previous token (prevPage)
    // - was there a next token (nextPage)
    // - order of items asc/desc
    makePaginator(items, args, prevPage, nextPage) {
        args.nextPageItemId = args.prevPageItemId = null;
        const hasPrevPage = prevPage && this._prevPageAllowed(items, args.order);
        const hasNextPage = nextPage && this._nextPageAllowed(items, args.order);
        return new paginator.Paginator(items, (adds) => this.queryItems(Object.assign(Object.assign({}, args), adds)), hasPrevPage ? lodash.lodash.exports.head(items).index : null, hasNextPage ? lodash.lodash.exports.last(items).index : null);
    }
    async _querySingleItemFromServer(index) {
        const fetchedItems = await this._queryItemsFromServer({ index });
        if (fetchedItems.items.length === 0) {
            // Successfully failed to fetch by key, mark it as a tombstone.
            this.cache.delete(index, null);
        }
        return fetchedItems;
    }
    async _queryItemsFromServer(args) {
        var _a, _b;
        const uri$1 = new uri.UriBuilder(this.links.items)
            .queryParam('HideExpired', true)
            // either
            .queryParam('Index', args.index)
            // or
            .queryParam('PageToken', args.pageToken)
            // or
            .queryParam('From', args.from)
            .queryParam('PageSize', args.limit) // @fixme use pageSize not limit?
            .queryParam('Order', args.order)
            .build();
        let response = await this.services.network.get(uri$1);
        let items = ((_b = (_a = response.body) === null || _a === void 0 ? void 0 : _a.items) !== null && _b !== void 0 ? _b : []).map(el => {
            el.date_updated = new Date(el.date_updated);
            // FIXME: handleItem mutated inserts items into the cache, so populate call later only updates the bounds? Split it.
            this._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);
            return this.cache.getValue(el.index);
        });
        const meta = response.body.meta;
        return this.makePaginator(items, args, !!meta.previous_token, !!meta.next_token);
    }
    async getItems(args) {
        args = args || {};
        sanitize.validatePageSize(args.pageSize);
        args.limit = args.pageSize || args.limit || 50;
        args.order = args.order || 'asc';
        return this.queryItems(args);
    }
    /**
     * @return {Promise<Object>} Context of List
     * @private
     */
    async getContext() {
        if (!this.context) {
            let response = await this.services.network.get(this.links.context);
            // store fetched context if we have't received any newer update
            this._updateContextIfRequired(response.body.data, response.body.last_event_id);
        }
        return this.context;
    }
    async setTtl(ttl) {
        try {
            const requestBody = { ttl };
            const response = await this.services.network.post(this.uri, requestBody);
            this.descriptor.date_expires = response.body.date_expires;
        }
        catch (error) {
            if (error.status === 404) {
                this.onRemoved(false);
            }
            throw error;
        }
    }
    async setItemTtl(index, ttl) {
        let existingItem = await this.get(index);
        const requestBody = { ttl };
        const response = await this.services.network.post(existingItem.url, requestBody);
        existingItem.updateDateExpires(response.body.date_expires);
    }
    async removeList() {
        await this.services.network.delete(this.uri);
        this.onRemoved(true);
    }
    onRemoved(locally) {
        this._unsubscribe();
        this.removalHandler(this.type, this.sid, this.uniqueName);
        this.broadcastEventToListeners('removed', { isLocal: locally });
    }
    shouldIgnoreEvent(key, last_event_id) {
        return this.cache.isKnown(key, last_event_id);
    }
    /**
     * Handle update, which came from the server.
     * @private
     */
    _update(update, isStrictlyOrdered) {
        const itemIndex = Number(update.item_index);
        update.date_created = new Date(update.date_created);
        // update.date_expires = new Date(update.date_expires);
        switch (update.type) {
            case 'list_item_added':
            case 'list_item_updated':
                {
                    this._handleItemMutated(itemIndex, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, update.date_expires, // orchestration events include date_expires since June 2020, SP-386
                    update.type === 'list_item_added', true);
                }
                break;
            case 'list_item_removed':
                {
                    this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);
                }
                break;
            case 'list_context_updated':
                {
                    this._handleContextUpdate(update.context_data, update.id, update.date_created);
                }
                break;
            case 'list_removed':
                {
                    this.onRemoved(false);
                }
                break;
        }
        if (isStrictlyOrdered) {
            this._advanceLastEventId(update.id, update.list_revision);
        }
    }
    _advanceLastEventId(eventId, revision) {
        if (this.lastEventId < eventId) {
            this.descriptor.last_event_id = eventId;
            if (revision) {
                this.descriptor.revision = revision;
            }
        }
    }
    _updateRootDateUpdated(dateUpdated) {
        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {
            this.descriptor.date_updated = dateUpdated;
            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });
        }
    }
    _handleItemMutated(index, url, lastEventId, revision, data, dateUpdated, dateExpires, added, remote) {
        if (this.shouldIgnoreEvent(index, lastEventId)) {
            logger["default"].trace(`Item ${index} update skipped, current: ${this.lastEventId}, remote: ${lastEventId}`);
            return;
        }
        this._updateRootDateUpdated(dateUpdated);
        const item = this.cache.getValue(index);
        if (!item) {
            const newItem = new synclistitem.SyncListItem({ index, url, lastEventId, revision, data, dateUpdated, dateExpires });
            this.cache.store(index, newItem, lastEventId);
            this.emitItemMutationEvent(newItem, remote, added);
            return;
        }
        const previousItemData = sanitize.deepClone(item.data);
        item.update(lastEventId, revision, data, dateUpdated);
        this.cache.store(index, item, lastEventId);
        if (dateExpires !== undefined) {
            item.updateDateExpires(dateExpires);
        }
        this.emitItemMutationEvent(item, remote, false, previousItemData);
    }
    /**
     * @private
     */
    emitItemMutationEvent(item, remote, added, previousItemData = null) {
        const eventName = added ? 'itemAdded' : 'itemUpdated';
        const args = { item, isLocal: !remote };
        if (!added) {
            args.previousItemData = previousItemData;
        }
        this.broadcastEventToListeners(eventName, args);
    }
    /**
     * @private
     */
    _handleItemRemoved(index, lastEventId, oldData, dateUpdated, remote) {
        this._updateRootDateUpdated(dateUpdated);
        this.cache.delete(index, lastEventId);
        this.broadcastEventToListeners('itemRemoved', { index: index, isLocal: !remote, previousItemData: oldData });
    }
    /**
     * @private
     */
    _handleContextUpdate(data, eventId, dateUpdated) {
        this._updateRootDateUpdated(dateUpdated);
        if (this._updateContextIfRequired(data, eventId)) {
            this.broadcastEventToListeners('contextUpdated', { context: data, isLocal: false });
        }
    }
    /**
     * @private
     */
    _updateContextIfRequired(data, eventId) {
        if (!this.contextEventId || eventId > this.contextEventId) {
            this.context = data;
            this.contextEventId = eventId;
            return true;
        }
        else {
            logger["default"].trace('Context update skipped, current:', this.lastEventId, ', remote:', eventId);
            return false;
        }
    }
}
/**
 * Represents a Sync list, which stores an ordered list of values.
 * Use the {@link SyncClient.list} method to obtain a reference to a Sync list.
 * Information about rate limits can be found [here](https://www.twilio.com/docs/sync/limits).
 */
class SyncList extends closeable.Closeable {
    /**
     * @internal
     */
    constructor(syncListImpl) {
        super();
        this.syncListImpl = syncListImpl;
        this.syncListImpl.attach(this);
    }
    // private props
    get uri() {
        return this.syncListImpl.uri;
    }
    get revision() {
        return this.syncListImpl.revision;
    }
    get lastEventId() {
        return this.syncListImpl.lastEventId;
    }
    get links() {
        return this.syncListImpl.links;
    }
    get dateExpires() {
        return this.syncListImpl.dateExpires;
    }
    static get type() {
        return SyncListImpl.type;
    }
    get type() {
        return SyncListImpl.type;
    }
    /**
     * Unique ID of the list, immutable identifier assigned by the system.
     */
    get sid() {
        return this.syncListImpl.sid;
    }
    /**
     * Unique name of the list, immutable identifier that can be assigned to the list during creation.
     */
    get uniqueName() {
        return this.syncListImpl.uniqueName;
    }
    /**
     * Date when the list was last updated, given in UTC ISO 8601 format (e.g., '2018-04-26T15:23:19.732Z').
     */
    get dateUpdated() {
        return this.syncListImpl.dateUpdated;
    }
    /**
     * Add a new item to the list.
     * @param data Data to be added.
     * @param itemMetadata Item metadata.
     * @return The newly added item.
     * @example
     * ```typescript
     * list.push({ name: 'John Smith' }, { ttl: 86400 })
     *   .then((item) => {
     *     console.log(`List Item push() successful, item index: ${item.index}, data:`, item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item push() failed', error);
     *   });
     * ```
     */
    async push(data, itemMetadata) {
        this.ensureNotClosed();
        return this.syncListImpl.push(data, itemMetadata);
    }
    /**
     * Assign new data to an existing item, given its index.
     * @param index Index of the item to be updated.
     * @param value New data to be assigned to an item.
     * @param itemMetadataUpdates New item metadata.
     * @return A promise with the updated item containing latest known data.
     * The promise will be rejected if the item does not exist.
     * @example
     * ```typescript
     * list.set(42, { name: 'John Smith' }, { ttl: 86400 })
     *   .then((item) => {
     *     console.log('List Item set() successful, item data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item set() failed', error);
     *   });
     * ```
     */
    async set(index, value, itemMetadataUpdates) {
        this.ensureNotClosed();
        return this.syncListImpl.set(index, value, itemMetadataUpdates);
    }
    /**
     * Modify an existing item by applying a mutation function to it.
     * @param index Index of the item to be changed.
     * @param mutator A function that outputs a new data based on the existing data.
     * @param itemMetadataUpdates New item metadata.
     * @return Resolves with the most recent item state, the output of a successful
     * mutation or a state that prompted graceful cancellation (mutator returned `null`). This promise
     * will be rejected if the indicated item does not already exist.
     * @example
     * ```typescript
     * const mutatorFunction = (currentValue) => {
     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;
     *     return currentValue;
     * };
     * list.mutate(42, mutatorFunction, { ttl: 86400 })
     *   .then((item) => {
     *     console.log('List Item mutate() successful, new data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item mutate() failed', error);
     *   });
     * ```
     */
    async mutate(index, mutator, itemMetadataUpdates) {
        this.ensureNotClosed();
        return this.syncListImpl.mutate(index, mutator, itemMetadataUpdates);
    }
    /**
     * Modify an existing item by appending new fields (or overwriting existing ones) with the values from the object.
     * This is equivalent to
     * ```typescript
     * list.mutate(42, (currentValue) => Object.assign(currentValue, obj));
     * ```
     * @param index Index of an item to be changed.
     * @param obj Set of fields to update.
     * @param itemMetadataUpdates New item metadata.
     * @return A promise with a modified item containing latest known data.
     * The promise will be rejected if the item was not found.
     * @example
     * ```typescript
     * // Say, the List Item (index: 42) data is `{ name: 'John Smith' }`
     * list.update(42, { age: 34 }, { ttl: 86400 })
     *   .then((item) => {
     *     // Now the List Item data is `{ name: 'John Smith', age: 34 }`
     *     console.log('List Item update() successful, new data:', item.data);
     *   })
     *   .catch((error) => {
     *     console.error('List Item update() failed', error);
     *   });
     * ```
     */
    async update(index, obj, itemMetadataUpdates) {
        this.ensureNotClosed();
        return this.syncListImpl.update(index, obj, itemMetadataUpdates);
    }
    /**
     * Delete an item given its index.
     * @param index Index of the item to be removed.
     * @return A promise to remove the item.
     * The promise will be rejected if the item was not found.
     * @example
     * ```typescript
     * list.remove(42)
     *   .then(() => {
     *     console.log('List Item remove() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List Item remove() failed', error);
     *   });
     * ```
     */
    async remove(index) {
        this.ensureNotClosed();
        return this.syncListImpl.remove(index);
    }
    /**
     * Retrieve an item by List index.
     * @param index Item index in the list.
     * @return A promise with the item containing latest known data.
     * The promise will be rejected if the item was not found.
     * @example
     * ```typescript
     * list.get(42)
     *   .then((item) => {
     *     console.log('List Item get() successful, item data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item get() failed', error);
     *   });
     * ```
     */
    async get(index) {
        this.ensureNotClosed();
        return this.syncListImpl.get(index);
    }
    /**
     * Retrieve a list context
     * @return A promise with the list's context
     * @internal
     */
    async getContext() {
        this.ensureNotClosed();
        return this.syncListImpl.getContext();
    }
    /**
     * Query a list of items from collection.
     * Information about the query limits can be found {@link https://www.twilio.com/docs/sync/limits|here}.
     * @param queryOptions Query options.
     * @example
     * ```typescript
     * const pageHandler = (paginator) => {
     *   paginator.items.forEach((item) => {
     *     console.log(`Item ${item.index}:`, item.data);
     *   });
     *   return paginator.hasNextPage
     *     ? paginator.nextPage().then(pageHandler)
     *     : null;
     * };
     * list.getItems({ from: 0, order: 'asc' })
     *   .then(pageHandler)
     *   .catch((error) => {
     *     console.error('List getItems() failed', error);
     *   });
     * ```
     */
    async getItems(queryOptions) {
        this.ensureNotClosed();
        return this.syncListImpl.getItems(queryOptions);
    }
    /**
     * Update the time-to-live of the list.
     * @param ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * list.setTtl(3600)
     *   .then(() => {
     *     console.log('List setTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List setTtl() failed', error);
     *   });
     * ```
     */
    async setTtl(ttl) {
        this.ensureNotClosed();
        return this.syncListImpl.setTtl(ttl);
    }
    /**
     * Update the time-to-live of a list item.
     * @param index Item index.
     * @param ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * list.setItemTtl(42, 86400)
     *   .then(() => {
     *     console.log('List setItemTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List setItemTtl() failed', error);
     *   });
     * ```
     */
    async setItemTtl(index, ttl) {
        this.ensureNotClosed();
        return this.syncListImpl.setItemTtl(index, ttl);
    }
    /**
     * Delete this list. It will be impossible to restore it.
     * @return A promise that resolves when the list has been deleted.
     * @example
     * list.removeList()
     *   .then(() => {
     *     console.log('List removeList() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List removeList() failed', error);
     *   });
     */
    async removeList() {
        this.ensureNotClosed();
        return this.syncListImpl.removeList();
    }
    /**
     * Conclude work with the list instance and remove all event listeners attached to it.
     * Any subsequent operation on this object will be rejected with error.
     * Other local copies of this list will continue operating and receiving events normally.
     * @example
     * ```typescript
     * list.close();
     * ```
     */
    close() {
        super.close();
        this.syncListImpl.detach(this.listenerUuid);
    }
}
/**
 * Fired when a new item appears in the list, regardless of whether its creator was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * {@link SyncListItem} `item` - added item
 *     * boolean `isLocal` - equals true if the item was added by a local actor, false otherwise
 * @example
 * ```typescript
 * list.on('itemAdded', (args) => {
 *   console.log(`List item ${args.item.index} was added`);
 *   console.log('args.item.data:', args.item.data);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncList.itemAdded = 'itemAdded';
/**
 * Fired when a list item is updated (not added or removed, but changed), regardless of whether the updater was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * {@link SyncListItem} `item` - updated item
 *     * boolean `isLocal` - equals true if the item was updated by a local actor, false otherwise
 *     * object `previousItemData` - contains a snapshot of the item data before the update
 * @example
 * ```typescript
 * list.on('itemUpdated', (args) => {
 *   console.log(`List item ${args.item.index} was updated`);
 *   console.log('args.item.data:', args.item.data);
 *   console.log('args.isLocal:', args.isLocal);
 *   console.log('args.previousItemData:', args.previousItemData);
 * });
 * ```
 * @event
 */
SyncList.itemUpdated = 'itemUpdated';
/**
 * Fired when a list item is removed, regardless of whether the remover was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * number `index` - index of the removed item
 *     * boolean `isLocal` - equals true if the item was removed by a local actor, false otherwise
 *     * object `previousItemData` - contains a snapshot of the item data before the removal
 * @example
 * ```typescript
 * list.on('itemRemoved', (args) => {
 *   console.log(`List item ${args.index} was removed`);
 *   console.log('args.previousItemData:', args.previousItemData);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncList.itemRemoved = 'itemRemoved';
/**
 * Fired when a list is deleted entirely, by any actor local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * boolean `isLocal` - equals true if the list was removed by a local actor, false otherwise
 * @example
 * ```typescript
 * list.on('removed', (args) => {
 *   console.log(`List ${list.sid} was removed`);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncList.removed = 'removed';
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject, [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object, Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], SyncList.prototype, "push", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.pureObject, [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number, Object, Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], SyncList.prototype, "set", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, 'function', [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number, Function, Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], SyncList.prototype, "mutate", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.pureObject, [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number, Object, Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], SyncList.prototype, "update", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number]),
    tslib_es6.__metadata("design:returntype", Promise)
], SyncList.prototype, "remove", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number]),
    tslib_es6.__metadata("design:returntype", Promise)
], SyncList.prototype, "get", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        declarativeTypeValidator.objectSchema('query options', {
            from: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
            pageSize: [declarativeTypeValidator.custom((value) => [sanitize.isPositiveInteger(value), 'a positive integer']), 'undefined'],
            order: [declarativeTypeValidator.custom((value) => [value === 'asc' || value === 'desc', `either 'asc' or 'desc'`]), 'undefined']
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], SyncList.prototype, "getItems", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number]),
    tslib_es6.__metadata("design:returntype", Promise)
], SyncList.prototype, "setTtl", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.nonNegativeInteger),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number, Number]),
    tslib_es6.__metadata("design:returntype", Promise)
], SyncList.prototype, "setItemTtl", null);

exports.SyncList = SyncList;
exports.SyncListImpl = SyncListImpl;
exports["default"] = SyncList;
//# sourceMappingURL=synclist.js.map
