{"version":3,"file":"itemsCache.js","sources":["../src/itemsCache.ts"],"sourcesContent":["import { TreeMap } from './utils/tree';\n\n/// Shared cache entry interface for Entry and Tombstone.\ninterface CacheEntry<V> {\n  value: V;\n  lastEventId: number;\n  isValid: boolean;\n  isLeftBound: boolean;\n  isRightBound: boolean;\n}\n\nclass Entry<V> implements CacheEntry<V> {\n  _data: V;\n  lastEventId: number;\n  isLeftBound: boolean;\n  isRightBound: boolean;\n\n  constructor(value: V, lastEventId: number, isLeft: boolean = false, isRight: boolean = false) {\n    this._data = value;\n    this.lastEventId = (lastEventId || 0);\n\n    this.isLeftBound = isLeft;\n    this.isRightBound = isRight;\n  }\n\n  get isValid(): boolean {\n    return true;\n  }\n\n  get value(): V {\n    return this._data;\n  }\n}\n\nclass Tombstone<V> implements CacheEntry<V> {\n  lastEventId: number;\n  isLeftBound: boolean;\n  isRightBound: boolean;\n\n  constructor(lastEventId: number) {\n    this.lastEventId = lastEventId;\n\n    this.isLeftBound = false;\n    this.isRightBound = false;\n  }\n\n  get isValid(): boolean {\n    return false;\n  }\n\n  get value(): V {\n    return null;\n  }\n}\n\n/// All values suitable for caching must conform to this interface.\ninterface CachedValue<Key> {\n  cacheKey: Key;\n  lastEventId: number;\n}\n\n/// A cache for ranges of items in a collection.\n/// Keeps track of the left and right bounds of the entire collection.\n/// Keeps track of the left and right bounds of the pages of items.\nclass ItemsCache<Key, V extends CachedValue<Key>> {\n  public readonly items: TreeMap<Key, CacheEntry<V>> = new TreeMap<Key, CacheEntry<V>>();\n  private beginKey: Key | null = null;\n  private endKey: Key | null = null;\n\n  constructor() {\n    this.items.clear(); // Set count to 0 instead of null.\n  }\n\n  /*\n   * Used in tests.\n   * @internal\n   */\n  get size(): number {\n    return this.items.size;\n  }\n\n  get collectionBegin(): Key {\n    return this.beginKey;\n  }\n\n  get collectionEnd(): Key {\n    return this.endKey;\n  }\n\n  has(key: Key): boolean {\n    let cacheEntry = this.items.get(key);\n    return cacheEntry?.isValid ?? false;\n  }\n\n  // Whether an entry exists in the cache either as a value or a tombstone.\n  exists(key: Key): boolean {\n    let cacheEntry = this.items.get(key);\n    return !!cacheEntry;\n  }\n\n  // Return only cached value or null if it is missing or marked with a tombstone.\n  getValue(key: Key): V {\n    let cacheEntry = this.items.get(key);\n    return cacheEntry?.value ?? null;\n  }\n\n  // Return a cache entry, can either be missing (null), valid or a tombstone.\n  get(key: Key): CacheEntry<V> | null {\n    return this.items.get(key);\n  }\n\n  // Get an item next to the given key in specified search order.\n  getNextItem(key: Key | null, order: 'asc' | 'desc', inclusive: boolean): V | null {\n    if (key === null) {\n      return this.getFirstItem(order);\n    }\n    if (inclusive) {\n      return this.getValue(key);\n    }\n    return this.getAdjacentItem(key, order);\n  }\n\n  // Find the first item in the cache based on query order.\n  // @internal\n  getFirstItem(order: 'asc' | 'desc'): V | null {\n    const key = (order === 'asc') ? this.beginKey : this.endKey;\n    if (this.exists(key)) {\n      const entry = this.items.get(key);\n      if (entry.isValid) {\n        return entry.value;\n      }\n      return this.getAdjacentItem(key, order);\n    }\n    return null;\n  }\n\n  // Find the first valid item next to the given one.\n  // @internal\n  getAdjacentItem(key: Key, order: 'asc' | 'desc'): V | null {\n    const iterator = (order === 'asc') ? this.items.getIterator(key) : this.items.getReverseIterator(key);\n    for (const [k, v] of iterator) {\n      if ((order === 'asc' ? v.isRightBound : v.isLeftBound)) {\n        break;\n      }\n\n      if (v.isValid) {\n        return v.value;\n      }\n    }\n    return null;\n  }\n\n  store(key: Key, data: V, lastEventId: number, isLeft: boolean = true, isRight: boolean = true): V | null {\n    let cacheEntry = this.items.get(key);\n    if (cacheEntry && cacheEntry.lastEventId > lastEventId) {\n      return cacheEntry.value;\n    }\n\n    this.items.set(key, new Entry<V>(data, lastEventId,\n        cacheEntry ? cacheEntry.isLeftBound && isLeft : isLeft,\n        cacheEntry ? cacheEntry.isRightBound && isRight : isRight\n    ));\n\n    // Update the `begin` and `end` markers. - FIXME can't do it here, because we don't know the pagination limits\n    if (this.beginKey && key < this.beginKey) {\n      // this.items[begin].isLeftBound = False // FIXME continuity?\n      this.beginKey = key;\n    }\n\n    if (this.endKey && this.endKey < key) {\n      // cache.items[end].isRightBound = False\n      this.endKey = key;\n    }\n\n    return data;\n  }\n\n  // Populate a contiguous range of items from a paginator page.\n  populate(entries: V[], isBegin: boolean, isEnd: boolean): void {\n    if (!entries.length) {\n      return;\n    }\n\n    const newEntries = [...entries];\n\n    // Backend-compatible lexicographical key sort\n    newEntries.sort((x1, x2) => {\n      if (x1.cacheKey === x2.cacheKey) {\n        return 0;\n      }\n      if (x1.cacheKey > x2.cacheKey) {\n        return 1;\n      }\n      return -1;\n    });\n\n    newEntries.forEach(((item, index) => {\n      this.store(item.cacheKey, item, item.lastEventId, index === 0, index === newEntries.length - 1);\n    }));\n\n    if (isBegin) {\n      const firstKey = newEntries[0].cacheKey;\n      if (!this.beginKey || firstKey < this.beginKey) {\n        this.beginKey = firstKey;\n      }\n    }\n    if (isEnd) {\n      const lastKey = newEntries[newEntries.length - 1].cacheKey;\n      if (!this.endKey || this.endKey < lastKey) {\n        this.endKey = lastKey;\n      }\n    }\n\n  }\n\n  delete(key: Key, lastEventId: number | null): void {\n    let cacheEntry = this.items.get(key);\n    /* Force delete when revision is unknown */\n    if (cacheEntry === null || lastEventId === null || cacheEntry.lastEventId < lastEventId) {\n      this.items.set(key, new Tombstone<V>(lastEventId));\n    }\n  }\n\n  // Shall we ignore the item with this key in an update?\n  isKnown(key: Key, lastEventId: number): boolean {\n    let cacheEntry = this.items.get(key);\n    return cacheEntry && cacheEntry.lastEventId >= lastEventId;\n  }\n\n  *getIterator(key: Key) {\n    if (key === null && this.beginKey !== null) {\n      key = this.beginKey;\n    }\n    if (key === null) {\n      return;\n    }\n    for (let [k, v] of this.items.getIterator(key)) {\n      if (!v.isValid) {\n        continue;\n      }\n\n      yield v;\n\n      if (v.isRightBound) {\n        break;\n      }\n    }\n  }\n\n  *getReverseIterator(key: Key) {\n    if (key === null && this.endKey !== null) {\n      key = this.endKey;\n    }\n    if (key === null) {\n      return;\n    }\n    for (let [k, v] of this.items.getReverseIterator(key)) {\n      if (!v.isValid) {\n        continue;\n      }\n\n      yield v;\n\n      if (v.isLeftBound) {\n        break;\n      }\n    }\n  }\n\n  forEach(callbackfn: (key: Key, value: V) => void): void {\n    if (this.items) {\n      for (let [key, entry] of this.items) {\n        if (entry.isValid) {\n          callbackfn(key, entry.value);\n        }\n      }\n    }\n  }\n}\n\nexport { ItemsCache };\nexport default ItemsCache;\n"],"names":["TreeMap"],"mappings":"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"}